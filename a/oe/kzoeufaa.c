//
// FILENAME:     KZOEUFAA.c
//
// DESCRIPTION:  This is the source file which contains Object services
//               operations that are available and kind of fall under
//               the category and general.
//               Also implements Zeidon String manipulation routines
//               used by code generated by VML.
// OPERATIONS:   OPERATIONS of a general nature.
// **********************************************************************
// * Copyright (c) 1993-2016 QuinSoft, Inc. All rights reserved. *
// * Confidential and Proprietary material subject to license -         *
// * do not reproduce or disclose. This material is an unpublished      *
// * work and is considered a trade secret belonging to the             *
// * copyright holder.                                                  *
// **********************************************************************
//  AUTHOR:  John Price
//  DATE:    12/2/92
//  API:     NONE
//  ENVIRONMENT: ANY
//

/*
CHANGE LOG

2002.10.08 HH
   R56768, error if source index points beyond end of the source string
2002.01.28 HH
   R56310, fix ZeidonStringConvertFromNumber crash (szWorkstring short).
2002.01.22 HH
   malloc the Probe storage to avoid global variables (SAS-C):
2001.09.04 PAS
   Added Probe functions for use in analyzing performance.  See
   UfZProveEnable for overview documentation.  The set of UfZProbeXXX
   could be released to Application developers if they are enhanced
   to have multiple sets of independent Probes.  This would allow
   the Probe sets for the Zeidon infrastructure to be left in the code
   and turned on/off via INI at a customer's site.

2001.08.30 PAS
   Changed UfEditFormatDateTime to allow for date formats without a
   day.  For example, MM/YYYY and Mmm'. 'YYYY  are now valid for both
   get and set functions of the Date domain.

2001.01.10 HH
   R53710, fix bug with target length in ZeidonStringConvertFromNumber.

2000.11.28 HH
   const char change ZeidonStringCompare, ZeidonStringConcat,
   ZeidonStringConvertFromNumber, ZeidonStringCopy.

2000.11.07 HH
   Changed UfDecryptString to handle empty input string.

2000.10.19 DGC All
   Changed UfEn/De-cryptString to handle any ASCII character.

2000.06.27 DGC All
   Re-instated fix for adding to datetimes.

2000.04.17 DGC All
   Removed code for Y2K stuff.

2000.03.07 DGC All
   Made change to UfDateTimeToString( ) as requested by Don...we'll be a little
   smarter handling the buffer length.

1999.06.11 DC Z10
   Modified ZeidonStringConcat to handle situation where the source
   string is null.

1999.05.26 DC Z10
   Added warning messages when trying to format a 2-digit year, either on
   input or on output.

*** Start of old log entries.

15.10.1996  GT
   Return an error if UfStringToDateTime( ) is called
   with invalid Datestring like "19960133"
09.12.1996  GT
   Use UfStringToDateTime( ) for Time:
   allow Datestring to be "00000000" for only Time string
13.02.1997  HH
   Compare pointer <= 0 did not compile under C370 MVS
   (ZeidonStringConvertFromNumber)

13.03.1997 DonC
   Corrected ZeidonStringConvertFromNumber which was always returning
   an error condition.

03.04.1997  GT
   Corrected UfFormatDateTime( ) for German windows installation, where
   we have no AM and PM language codes defined.

03.07.1997  DonC
   Modified fnDetermineDateTimeStrlen, UfEditFormatDateTime and
   UfFormatDateTime to handle the condition when
   AnchorBlock->hInternational->h1159 and lp2359 are zero.

03.07.1997  DonC
   Modified UfAddToDateTime so that adding to seconds properly handles the
   case where the result is 60 seconds.

18.07.1997  GT
   Corrected ZeidonStringConcat( ) - correct length checking.

28.07.1997  RG
   Remove any german 'umlaute' in function UfCompressName

20.11.1997  GT
   New operation UfDateTimeDiff( )

1998.12.01  DKS
   Corrected operation UfJulianToGregorian (was converting to one day
   too much).

1999.01.15  DGC
   Added error messages to ZeidonStringxxx( ) functions.

*/

#include "kzoephdr.h"

#include <stdlib.h>
#include <ctype.h>

///////////////////////// DATE/TIME Constants //////////////////////////////

#define Minute         1
#define Hour           (zULONG) (Minute * 60)
#define Day            (zULONG) (Hour * 24)
#define Week           (zULONG) (Day * 7)
#define Year           (zULONG) (Day * 365)
#define LeapYear       (zULONG) (Day * 366)
#define Century        (zULONG) ((Year * 76) + (LeapYear * 24))
#define LeapCentury    (zULONG) ((Year * 75) + (LeapYear * 25))
#define Year1900       (zULONG) ((Century * 14) + (LeapCentury * 5))
#define Year2000       (zULONG) ((Century * 15) + (LeapCentury * 5))

// Signed long to Asciiz right justified (with leading zeros) for length
// INPUT: Long value to be converted to Ascii string
//        Ascii string address to be returned
//        Return string length - not including null terminator
//
void
zltoal( zLONG lValue,
        zPCHAR pchAsciiString,
        zSHORT nLth )
{
   zLONG  k;
   zLONG  lPos;
   zCHAR  szTemp[ 64 ];

   zltoa( lValue, szTemp, zsizeof( szTemp ) );
   k = zstrlen( szTemp ) + 1;
   if ( k < nLth )
   {
      lPos = nLth - k;
      zmemset( pchAsciiString, '0', lPos );
   }
   else
   {
      lPos = 0;
      k = nLth;
   }

   szTemp[ nLth - lPos - 1 ] = 0;
   strncpy_s( pchAsciiString + lPos, nLth - lPos, szTemp, k );
   pchAsciiString[ nLth ] = 0;
}

// C implementations of what used to be defined in kzoeenaa.h
//#define zstrcpyp( pTgt, size, pSrc ) ((zPCHAR) strcpy_s( pTgt, size, pSrc ) + zstrlen( pTgt ))
//#define zstrcatp( pTgt, size, pSrc ) ((zPCHAR) strcat_s( pTgt, size, pSrc ) + zstrlen( pTgt ))

zPCHAR OPERATION
zstrcpyp( zPCHAR pchTgt, zLONG lMaxLth, zCPCHAR cpcSrc )
{
   strcpy_s( pchTgt, lMaxLth, cpcSrc );
   return( pchTgt + zstrlen( pchTgt ) );
}

zPCHAR OPERATION
zstrcatp( zPCHAR pchTgt, zLONG lMaxLth, zCPCHAR cpcSrc )
{
   strcat_s( pchTgt, lMaxLth, cpcSrc );
   return( pchTgt + zstrlen( pchTgt ) );
}

//./ ADD NAME=UfFormatDateTime
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  ENTRY:      UfFormatDateTime
//
//  PURPOSE:    DateTime attribute handling
//
//  PARAMETERS: pchReturnString  - area to return the formatted output
//              cpcDateTimeString - a date-time string (YYYYMMDDHHmmSSTht)
//                                 contains one of the following formats:
//                                    YYYYMMDDHHmmSSTht
//                                    YYYYMMDDHHmmSSTh
//                                    YYYYMMDDHHmmSST
//                                    YYYYMMDDHHmmSS
//                                    YYYYMMDDHHmm
//                                    YYYYMMDD
//
//                                        YYYY - year
//                                        MM   - month
//                                        DD   - day
//                                        HH   - hour
//                                        mm   - minute
//                                        ss   - seconds
//                                        T    - tenths of seconds
//                                        h    - hundredths of seconds
//                                        t    - thousandths of seconds
//
//              cpcEditString    - contains info on how to format the
//                                 cpcDateTimeString input.  If null then
//                                 the cpcDateTimeString is copied to
//                                 pchReturnString.
//
//      The following explains the Edit String characters that can be used
//      in formatting the DateTime String:
//
//       Characters     Replaced By
//
//          M/m         A one or two digit number that represents the
//                      month.
//
//         MM/mm        A two digit number that represents the month.
//
//          MON         A three character abbreviation for the month.
//
//          mmm         Month's three letter abbreviation. This symbol
//                      is case sensative; You can specify capitalization
//                      in the formatted value as follows:
//                         mmm   jan
//                         Mmm   Jan
//                         MMM   JAN
//
//          mmmm        Month's full name.  This symbol is case sensative;
//                      you can specify capitalization in the formatted
//                      value as follows:
//
//                         mmmm  january
//                         Mmmm  January
//                         MMMM  JANUARY
//
//           D/d        A one or two digit number that represents the day
//                      of the month.
//
//          DD/dd       A two digit number that represents the day
//                      of the month.
//
//          ddd         Day of week, three letter abbreviation.  This
//                      symbol is case sensative; You can specify
//                      capitalization is the formatted value as follows:
//                         ddd   sun
//                         Ddd   Sun
//                         DDD   SUN
//
//          dddd        Day of week, full name.  This symbol is case
//                      sensative; You can specify capitalization is the
//                      formatted value as follows:
//                         dddd  sunday
//                         Dddd  Sunday
//                         DDDD  SUNDAY
//
//          jjj         Julian day.
//
//           YY         The last two digits of the year.
//
//          YYYY        The four digits of the year.
//
//           HH         A two digit number that represents hours based
//                      on a 24 hour clock, unless AM or PM is present
//                      in the Edit String, in which case the base is a
//                      12 hour clock
//
//           MI         A two digit number that represents minutes.
//
//           SS         A two digit number that represents seconds.
//
//        AM or PM      Two characters that represents AM or PM.  Either
//                      of these will cause any HH in the Edit String
//                      to be based on a 12 hour clock.
//
//            9         A number with 1 to 3 digits
//           99         that represents
//          999         fractions of a second.
//
//
//      The following Edit String characters are moved from the Edit
//      String to the Return String as is:
//
//           (      left paren
//           )      right paren
//           :      colon
//           ,      comma
//           -      dash
//           /      slash
//           .      period
//                  space
//
//      The following delimiters may be used to put string constants in
//      the returned string.
//           "      quote
//           '      aposthorpe
//
//
//  RETURNS:
//
//              0 - pchReturnString has been set
//    zCALL_ERROR - Error in call
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 4
zSHORT OPERATION
UfFormatDateTime( zPCHAR  pchReturnString,
                  zLONG   lMaxLth,
                  zCPCHAR cpcDateTimeString,
                  zCPCHAR cpcEditString )
{
   zBOOL    bTwelveHour;
   zBOOL    bAM;
   zCHAR    chDelimiter = 0;
   zPCHAR   pchEditString;
   zPCHAR   pchOutString;
   zPCHAR   pchFractionsOfSeconds;
   zLONG    n;
   zLONG    lWSLength;           // length of WorkString

   pchReturnString[ 0 ] = 0;  // init to null string

   lWSLength = zstrlen( cpcDateTimeString );
   if ( lWSLength == 17 ||
        lWSLength == 14 ||
        lWSLength ==  8 ||
        lWSLength == 12 ||
        lWSLength == 16 ||
        lWSLength == 15 )
      ; // faster than anding nots together
   else
      return( zCALL_ERROR );

   if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )
   {
      // If no edit string, just copy the input work string to the return string.
      strcpy_s( pchReturnString, lMaxLth, cpcDateTimeString );
      return( 0 );
   }
   else
   {
      pchEditString = (zPCHAR) cpcEditString;
      pchOutString = pchReturnString;

      if ( zstrchr( cpcEditString, 'A' ) || zstrchr( cpcEditString, 'P' ) )
      {
         bTwelveHour = TRUE;
         bAM = TRUE;
      }
      else
         bTwelveHour = FALSE;

      while ( *pchEditString )
      {
         if ( chDelimiter )
         {
            if ( *pchEditString == chDelimiter )
            {
               chDelimiter = 0;
               pchEditString++;
            }
            else
               *pchOutString++ = *pchEditString++;
         }
         else
         switch ( *pchEditString )
         {
          case 'A':
          case 'P':
            if ( *(pchEditString + 1) == 'M' )
            {
               zPCHAR   pchTrailer;

               // get national text for AM or PM
               if ( bAM )
               {
                  LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

                  if ( lpInternational->sz1159 == 0 )
                     pchTrailer = NULL;
                  else
                     pchTrailer = lpInternational->sz1159;
               }
               else
               {
                  LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

                  if ( lpInternational->sz2359 == 0 )
                     pchTrailer = NULL;
                  else
                     pchTrailer = lpInternational->sz2359;
               }

               // if no national text defined, use default text
               if ( pchTrailer == NULL )
               {
                  if ( bAM )
                     pchTrailer = "AM";
                  else
                     pchTrailer = "PM";
               }

               n = zstrlen( pchTrailer );
               strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), pchTrailer, n );
               pchOutString[ n ] = 0;
               pchOutString += n;
               pchEditString += 2;
            }
            else
               return( zCALL_ERROR );

            break;

          case 'D':
            if ( zstrncmp( (pchEditString + 1), "ddd", 3 ) == 0 )
            {
               zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );
               strcpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchDOW[ lDOW ] );
               pchOutString += zstrlen( g_pchDOW[ lDOW ] );
               pchEditString += 4;
            }
            else
            if ( zstrncmp( (pchEditString + 1), "DDD", 3 ) == 0 )
            {
               zPCHAR pchMover;
               zLONG  lDOW = UfGetDayOfWeek( cpcDateTimeString );
               pchMover = g_pchDOW[ lDOW ];
               while ( *pchMover )
                  *pchOutString++ = ztoupper( *pchMover++ );

               pchEditString += 4;
            }
            else
            if ( zstrncmp( (pchEditString + 1), "dd", 2 ) == 0 )
            {
               zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );
               strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchDOW[ lDOW ], 3 );
               pchOutString += 3;
               pchEditString += 3;
            }
            else
            if ( zstrncmp( (pchEditString + 1), "DD", 2 ) == 0 )
            {
               zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );
               strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchDOW[ lDOW ], 3 );
               *pchOutString++ = *g_pchDOW[ lDOW ];
               *pchOutString++ = ztoupper( *(g_pchDOW[ lDOW ] + 1) );
               *pchOutString++ = ztoupper( *(g_pchDOW[ lDOW ] + 2) );
               pchEditString += 3;
            }
            else
            if ( *(pchEditString + 1) == 'D' || *(pchEditString + 1) == 'd' )
            {
               // move the day of the month (w/leading zero if < 10 ) to output
               *pchOutString++ = *(cpcDateTimeString + 6);
               *pchOutString++ = *(cpcDateTimeString + 7);
               pchEditString += 2;
            }
            else
            {
               // move the day of the month (w/o leading zero if < 10 ) to output
               if ( *(cpcDateTimeString + 6) != '0' )
               {
                  *pchOutString++ = *(cpcDateTimeString + 6);
               }

               *pchOutString++ = *(cpcDateTimeString + 7);
               pchEditString++;
            }

            break;

          case 'd':
            if ( zstrncmp( (pchEditString + 1), "ddd", 3 ) == 0 )
            {
               zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );
               strcpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchDOW[ lDOW ] );
               *pchOutString = tolower( *g_pchDOW[ lDOW ] );
               pchOutString += zstrlen( g_pchDOW[ lDOW ] );
               pchEditString += 4;
            }
            else
            if ( zstrncmp( (pchEditString + 1), "dd", 2 ) == 0 )
            {
               zLONG lDOW = UfGetDayOfWeek( cpcDateTimeString );
               *pchOutString++ = tolower( *g_pchDOW[ lDOW ] );
               *pchOutString++ = *(g_pchDOW[ lDOW ] + 1);
               *pchOutString++ = *(g_pchDOW[ lDOW ] + 2);
               pchEditString += 3;
            }
            else
            if ( *(pchEditString + 1) == 'd' )
            {
               // move the day of the month (w/leading zero if < 10 ) to output
               *pchOutString++ = *(cpcDateTimeString + 6);
               *pchOutString++ = *(cpcDateTimeString + 7);
               pchEditString += 2;
            }
            else
            {
               // move the day of the month (w/o leading zero if < 10 ) to output
               if ( *(cpcDateTimeString + 6) != '0' )
               {
                  *pchOutString++ = *(cpcDateTimeString + 6);
               }
               *pchOutString++ = *(cpcDateTimeString + 7);
               pchEditString++;
            }

            break;

          case 'H':
            if ( lWSLength >= 12 ) // ensure WorkString contains HH
            {
               // move the hour of the day to output
               *pchOutString++ = *(cpcDateTimeString + 8);
               *pchOutString++ = *(cpcDateTimeString + 9);
               if ( bTwelveHour )
               {
                  zLONG    lHour;

                  *pchOutString = 0;         // null term the hour field
                  pchOutString -= 2;         // start of output HH field
                  lHour = zatol( pchOutString );
                  if ( lHour == 0 )
                  {
                     lHour = 12;
                     zltoal( lHour, pchOutString, 3 );
                  }
                  else
                  if ( lHour > 11 )
                  {
                     bAM = 0;
                     if ( lHour > 12 )
                     {
                        lHour -= 12;
                        zltoal( lHour, pchOutString, 3 );
                     }
                  }
                  if ( *pchOutString == '0' )
                  {
                     if ( *(pchEditString + 1) != 'H' )
                     {
                        *pchOutString = *(pchOutString + 1);
                        pchOutString++;
                        pchEditString++;
                     }
                     else
                     {
                        pchOutString += 2;
                        pchEditString += 2;
                     }
                  }
                  else
                  {
                     pchOutString += 2;
                     pchEditString++;
                     if ( *pchEditString == 'H' )
                        pchEditString++;
                  }
               }
               else
               {
                  if ( *(cpcDateTimeString + 8) == '0' )
                  {
                     if ( *(pchEditString + 1) != 'H' )
                     {
                        pchOutString -= 2;
                        *pchOutString++ = *(cpcDateTimeString + 9);
                        pchEditString++;
                     }
                     else
                        pchEditString += 2;
                  }
                  else
                     pchEditString += 2;
               }
            }
            else
            {
               pchEditString++;
               if ( *pchEditString == 'H' )
                  pchEditString++;
            }

            break;

          case 'j':
            if ( zstrncmp( (pchEditString + 1), "jj", 2 ) == 0 )
            {
               zltoal( UfGetDayOfYear( cpcDateTimeString ), pchOutString, 4 );
               pchOutString += 3;
               pchEditString += 3;
            }
            else
               return( zCALL_ERROR );

            break;

          case 'M':
            if ( *(pchEditString + 1) == 'I' )
            {
               if ( lWSLength >= 12 ) // ensure WorkString contains MI
               {
                  // move the minute past hour to output
                  *pchOutString++ = *(cpcDateTimeString + 10);
                  *pchOutString++ = *(cpcDateTimeString + 11);
               }
               pchEditString += 2;
            }
            else
            {
               // move three char month to output
               zCHAR  szMonthNumber[ 3 ];
               zLONG  lMonth;

               // setup the following, assuming we're going to do something with the month
               szMonthNumber[ 0 ] = *(cpcDateTimeString + 4);
               szMonthNumber[ 1 ] = *(cpcDateTimeString + 5);
               szMonthNumber[ 2 ] = 0;
               lMonth = zatol( szMonthNumber );
               lMonth--;   // make relative to 0

               if ( zstrncmp( (pchEditString + 1), "mmm", 3 ) == 0 )
               {
                  strcpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchMon[ lMonth ] );
                  pchOutString += zstrlen( g_pchMon[ lMonth ] );
                  pchEditString += 4;
               }
               else
               if ( zstrncmp( (pchEditString + 1), "MMM", 3 ) == 0 )
               {
                  zPCHAR   pchMover;
                  pchMover = g_pchMon[ lMonth ];
                  while ( *pchMover )
                     *pchOutString++ = ztoupper( *pchMover++ );

                  pchEditString += 4;
               }
               else
               if ( zstrncmp( (pchEditString + 1), "mm", 2 ) == 0 )
               {
                  strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchMon[ lMonth ], 3 );
                  pchOutString += 3;
                  pchEditString += 3;
               }
               else
               if ( zstrncmp( (pchEditString + 1), "MM", 2 ) == 0 )
               {
                  strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchMon[ lMonth ], 3 );
                  *pchOutString++ = *g_pchMon[ lMonth ];
                  *pchOutString++ = ztoupper ( *(g_pchMon[ lMonth ] + 1) );
                  *pchOutString++ = ztoupper ( *(g_pchMon[ lMonth ] + 2) );
                  pchEditString += 3;
               }
               else
               if ( *(pchEditString + 1) == 'M' ||
                    *(pchEditString + 1) == 'm' )
               {
                  // move the two digit number representing month to output
                  *pchOutString++ = *(cpcDateTimeString + 4);
                  *pchOutString++ = *(cpcDateTimeString + 5);
                  pchEditString += 2;
               }
               else
#if 0
               if ( *(pchEditString + 1) == 'O' && *(pchEditString + 2) == 'N' )
               {
                  strncpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchMon[ lMonth ], 3 );
                  pchOutString += 3;
                  pchEditString += 3;
               }
               else
#endif
               {
                  // move the one/two digit number representing month to output
                  if ( *(cpcDateTimeString + 4) != '0' )
                     *pchOutString++ = *(cpcDateTimeString + 4);
                  *pchOutString++ = *(cpcDateTimeString + 5);
                  pchEditString++;
               }
            }

            break;

          case 'm':
            {
               // move three char month to output
               zCHAR  szMonthNumber[ 3 ];
               zLONG  lMonth;

               // setup the following, assuming we're going to do something
               // with the month
               szMonthNumber[ 0 ] = *(cpcDateTimeString + 4);
               szMonthNumber[ 1 ] = *(cpcDateTimeString + 5);
               szMonthNumber[ 2 ] = 0;
               lMonth = zatol( szMonthNumber );
               lMonth--;   // make relative to 0

               if ( zstrncmp( (pchEditString + 1), "mmm", 3 ) == 0 )
               {
                  strcpy_s( pchOutString, lMaxLth - (pchOutString - pchReturnString), g_pchMon[ lMonth ] );
                  *pchOutString = tolower( *g_pchMon[ lMonth ] );
                  pchOutString += zstrlen( g_pchMon[ lMonth ] );
                  pchEditString += 4;
               }
               else
               if ( zstrncmp( (pchEditString + 1), "mm", 2 ) == 0 )
               {
                  *pchOutString++ = tolower( *g_pchMon[ lMonth ] );
                  *pchOutString++ = *(g_pchMon[ lMonth ] + 1);
                  *pchOutString++ = *(g_pchMon[ lMonth ] + 2);
                  pchEditString += 3;
               }
               else
               if ( *(pchEditString + 1) == 'M' || *(pchEditString + 1) == 'm' )
               {
                  // move the two digit number representing month to output
                  *pchOutString++ = *(cpcDateTimeString + 4);
                  *pchOutString++ = *(cpcDateTimeString + 5);
                  pchEditString += 2;
               }
               else
               {
                  // move the one/two digit number representing month
                  // to output
                  if ( *(cpcDateTimeString + 4) != '0' )
                     *pchOutString++ = *(cpcDateTimeString + 4);
                  *pchOutString++ = *(cpcDateTimeString + 5);
                  pchEditString++;
               }
            }

            break;

          case 'S':
            if ( *(pchEditString + 1) == 'S' )
            {
               if ( lWSLength >= 14 ) // Ensure WorkString contains SS
               {
                  // move the second past minute to output
                  *pchOutString++ = *(cpcDateTimeString + 12);
                  *pchOutString++ = *(cpcDateTimeString + 13);
               }

               pchEditString += 2;
            }
            else
               return( zCALL_ERROR );

            break;

          case 'Y':
            if ( *(pchEditString + 1) == 'Y' )
            {
               if ( *(pchEditString + 2) == 'Y' && *(pchEditString + 3) == 'Y' )
               {
                  // move the four digit year to output
                  *pchOutString++ = *(cpcDateTimeString + 0);
                  *pchOutString++ = *(cpcDateTimeString + 1);
                  *pchOutString++ = *(cpcDateTimeString + 2);
                  *pchOutString++ = *(cpcDateTimeString + 3);
                  pchEditString += 4;
               }
               else
               {
                  // move the two digit year to output
                  *pchOutString++ = *(cpcDateTimeString + 2);
                  *pchOutString++ = *(cpcDateTimeString + 3);
                  pchEditString += 2;
               }
            }
            else
               return( zCALL_ERROR );

            break;

          case '9':
            if ( lWSLength >= 15 )
            {
               pchFractionsOfSeconds = (zPCHAR) (cpcDateTimeString + 14);
               while ( *pchEditString == '9' && *pchFractionsOfSeconds )
               {
                  *pchOutString++ = *pchFractionsOfSeconds++;
                  pchEditString++;
               }
            }

            while ( *pchEditString == '9' )
               pchEditString++;

            break;

          case '\"':  // quote
          case '\'':  // aposthorpe
            chDelimiter = *pchEditString++;
            break;

          case '(':   // left paren
          case ')':   // right paren
          case ':':   // colon
          case ',':   // comma
          case '-':   // dash
          case '/':   // slash
          case '.':   // period
          case ' ':   // space
            *pchOutString++ = *pchEditString++;
            break;

          default:
            return( zCALL_ERROR );
         }
      }

      *pchOutString = 0; // don't forget to null terminate the string
      if ( chDelimiter )
      {
         zCHAR sz[ 2 ];
         sz[ 0 ] = chDelimiter;
         sz[ 1 ] = 0;
         // "KZOEE360 - Missing ending delimiter "
         fnSysMessageBox( 0, "Zeidon Error", "Missing ending delimiter", 0 );
      // fnIssueCoreError( 0, lpView, 8, 360, 0, sz, 0 );
      }
   }

   return( 0 );
}

//./ ADD NAME=UfEditFormatDateTime
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  ENTRY:      UfEditFormatDateTime
//
//  PURPOSE:    DateTime attribute handling
//
//  PARAMETERS: pchDTString      - area to return the formatted output
//              cpcEditString    - contains info on how to format the
//                                 cpcDateTimeString input.  If null then
//                                 the cpcDateTimeString is copied to
//                                 pchReturnString.
//
//
//  RETURNS:
//              0 - szDtString has been set to YYYYMMDDHHmmssTht
//             -1 - Error, pchDTString invalid
//    zCALL_ERROR - Error in call, cpcEditString invalid
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 3
zSHORT OPERATION
UfEditFormatDateTime( zPCHAR  pchDTString,
                      zLONG   lMaxLth,
                      zCPCHAR cpcEditString )
{
   zPCHAR   pchReturnString = pchDTString;
   zCHAR    szDT[ 20 ];
   zCHAR    sz[ 20 ];
   zCHAR    szJulian[ 4 ];
   zCHAR    chDelimiter = 0;
   zLONG    k, n;
   zBOOL    bError = 0;
   zBOOL    bBadEditString = 0;
   zBOOL    bConvertJulian = 0;  // used when julian date is in the format
   zBOOL    bTwelveHourClock = 0;
   zBOOL    bAdjustTime = 0;     // used w/12 hour clock and time is PM
   zBOOL    bDayNeeded = 0;      // used to see if day is in edit string (e.g.mm/YYYY)

   // If null input, just return a 0.
   if ( pchDTString == 0 || pchDTString[ 0 ] == 0 )
      return( 0 );

   // If null edit string, error?
   if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )
      return( zCALL_ERROR );

   // init scan pointers
   k = zsizeof( szDT ) - 1;
   zmemset( szDT, 'X', k );
   *(szDT + k) = 0;

   while ( *cpcEditString )
   {
      if ( chDelimiter )
      {
         if ( *cpcEditString == chDelimiter )
         {
            chDelimiter = 0;
            cpcEditString++;
         }
         else
         {
            if ( *cpcEditString++ != *pchDTString++ )
            {
               // error
               bError = TRUE;
               break;
            }
         }
      }
      else
      switch ( *cpcEditString )
      {
         case 'A':
         case 'P':
            if ( *(cpcEditString + 1) == 'M' )
            {
               zPCHAR          pchTrailer;
               LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

               bTwelveHourClock = TRUE;
               if ( lpInternational->sz1159[ 0 ] == 0 )
                  pchTrailer = "AM";
               else
                  pchTrailer = lpInternational->sz1159;

               n = zstrlen( pchTrailer );

               // first check for the am time trailer
               if ( zstrncmp( pchDTString, pchTrailer, n ) == 0 )
               {
                  pchDTString += n;
                  cpcEditString += 2;
               }
               else
               {
                  LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

                  if ( lpInternational->sz2359[ 0 ] == 0 )
                     pchTrailer = "PM";
                  else
                     pchTrailer = lpInternational->sz2359;

                  n = zstrlen( pchTrailer );
                  // next check for the pm time trailer
                  if ( zstrncmp( pchDTString, pchTrailer, n ) == 0 )
                  {
                     bAdjustTime = TRUE;
                     pchDTString += n;
                     cpcEditString += 2;
                  }
                  else
                  {
                     // error
                     bError = TRUE;
                  }
               }
            }
            else
               bError = TRUE;

            break;

         case 'd':
         case 'D':
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "DD", 2 ) == 0 )
            {
               zBOOL bLongFormat = 0;

               if ( ztoupper( *(cpcEditString + 3) ) == 'D' )
                  bLongFormat = TRUE;

               bDayNeeded = TRUE;

               // Day of the week
               for ( k = 0; k < 7; k++ )
               {
                  if ( ztoupper( *pchDTString ) == *g_pchDOW[ k ] )
                  {
                     n = bLongFormat ? zstrlen( g_pchDOW[ k ] ) : 3;
                     if ( zstrncmpi( pchDTString, g_pchDOW[ k ], n ) == 0 )
                     {
                        pchDTString += n; // bump past the day of the week
                        cpcEditString += ( 3 + bLongFormat );
                        break;
                     }
                  }
               }
               if ( k == 7 )
               {
                  // error
                  bError = TRUE;
               }
            }
            else
            if ( ztoupper( *(cpcEditString + 1) ) == 'D' )
            {
               // two digit day of month
               bDayNeeded = TRUE;
               if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )
               {
                  *(szDT + 6) = *pchDTString++;
                  *(szDT + 7) = *pchDTString++;
                  cpcEditString += 2;
               }
               else
               {
                  // error
                  bError = TRUE;
               }
            }
            else
            {
               // must be day of month with no leading zero
               bDayNeeded = TRUE;
               if ( isdigit( *pchDTString ) )
               {
                  if ( isdigit( *(pchDTString + 1) ) )
                  {
                     *(szDT + 6) = *pchDTString++;
                     *(szDT + 7) = *pchDTString++;
                  }
                  else
                  {
                     *(szDT + 6) = '0';
                     *(szDT + 7) = *pchDTString++;
                  }
                  cpcEditString++;
               }
               else
               {
                  // error
                  bError = TRUE;
               }
            }

            break;

         case 'H':
            if ( *(cpcEditString + 1) == 'H' )
            {
               // Hour with leading zero
               if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )
               {
                  *(szDT + 8) = *pchDTString++;
                  *(szDT + 9) = *pchDTString++;
                  cpcEditString += 2;
               }
               else
               {
                  // error
                  bError = TRUE;
               }
            }
            else
            {
               // Hour without leading zero
               if ( isdigit( *pchDTString ) )
               {
                  if ( isdigit( *(pchDTString + 1) ) )
                  {
                     *(szDT + 8) = *pchDTString++;
                     *(szDT + 9) = *pchDTString++;
                  }
                  else
                  {
                     *(szDT + 8) = '0';
                     *(szDT + 9) = *pchDTString++;
                  }
                  cpcEditString++;
               }
               else
               {
                  // error
                  bError = TRUE;
               }
            }

            break;

         case 'j':
            if ( zstrncmp( (zPCHAR)(cpcEditString + 1), "jj", 2 ) == 0 )
            {
               if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) && isdigit( *(pchDTString + 2) ) )
               {
                  strncpy_s( szJulian, zsizeof( szJulian ), pchDTString, 3 );
                  szJulian[ 3 ] = 0;
                  bConvertJulian = TRUE;
                  bDayNeeded = TRUE;
                  cpcEditString += 3;
                  pchDTString += 3;
               }
               else
                  bError = TRUE;
            }
            else
               bError = TRUE;

            break;

         case 'M':
            if ( *(cpcEditString + 1) == 'I' )
            {
               // Minutes field
               if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )
               {
                  *(szDT + 10) = *pchDTString++;
                  *(szDT + 11) = *pchDTString++;
                  cpcEditString += 2;
                  break;
               }
               else
               {
                  bError = TRUE;
                  break;
               }
            }
            // break left out intentionally!!!

         case 'm':
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mm", 2 ) == 0 )
            {
               zBOOL bLongFormat = 0;

               // Month of year( could be short or long )
               if ( ztoupper( *(cpcEditString + 3) ) == 'M' )
                  bLongFormat = TRUE;

               for ( k = 0; k < 12; k++ )
               {
                  if ( ztoupper( *pchDTString ) == *g_pchMon[ k ] )
                  {
                     n = bLongFormat ? zstrlen( g_pchMon[ k ] ) : 3;
                     if ( zstrncmpi( pchDTString, g_pchMon[ k ], n ) == 0 )
                     {
                        pchDTString += n; // bump past the Month
                        cpcEditString += (3 + bLongFormat);
                        break;
                     }
                  }
               }
               if ( k == 12 )
               {
                  // error
                  bError = TRUE;
               }
               else
               {
                  zltoa( (zLONG) k + 101L, sz, zsizeof( sz ) );
                  *(szDT + 4) = *(sz + 1);
                  *(szDT + 5) = *(sz + 2);
               }
            }
            else
            if ( ztoupper( *(cpcEditString + 1) ) == 'M' )
            {
               // move the two digit number representing month to output
               *(szDT + 4) = *pchDTString++;
               *(szDT + 5) = *pchDTString++;
               cpcEditString += 2;
            }
            else
            {
               // move the one/two digit number representing month to output
               if ( isdigit( *pchDTString ) )
               {
                  if ( isdigit( *(pchDTString + 1) ) )
                  {
                     *(szDT + 4) = *pchDTString++;
                     *(szDT + 5) = *pchDTString++;
                  }
                  else
                  {
                     *(szDT + 4) = '0';
                     *(szDT + 5) = *pchDTString++;
                  }
                  cpcEditString++;
               }
               else
                  bError = TRUE;
            }

            break;

         case 'S':
            if ( *(cpcEditString + 1) == 'S' )
            {
               if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )
               {
                  *(szDT + 12) = *pchDTString++;
                  *(szDT + 13) = *pchDTString++;
                  cpcEditString += 2;
               }
               else
                  bError = TRUE;
            }
            else
               bError = TRUE;

            break;

         case 'Y':
            if ( *(cpcEditString + 1) == 'Y' )
            {
               if ( *(cpcEditString + 2) == 'Y' && *(cpcEditString + 3) == 'Y' )
               {
                  // move the four digit year to output
                  for ( k = 0; k < 4; k++ )
                  {
                     if ( !isdigit( *(pchDTString + k) ) )
                        break;
                  }
                  if ( k < 4 )
                  {
                     bError = TRUE;
                  }
                  else
                  {
                     zmemcpy( szDT, pchDTString, 4 );
                     pchDTString += 4;
                     cpcEditString += 4;
                  }
               }
               else
               {
                  // move the two digit year to output
                  if ( isdigit( *pchDTString ) && isdigit( *(pchDTString + 1) ) )
                  {
                     szDT[ 0 ] = '2';
                     *(szDT + 1) = '0';
                     *(szDT + 2) = *pchDTString++;
                     *(szDT + 3) = *pchDTString++;
                     cpcEditString += 2;
                  }
                  else
                     bError = TRUE;
               }
            }
            else
               bError = TRUE;

            break;

         case '9':
         {
            zPCHAR   pch;
            pch = (zPCHAR) (szDT + 14);
            zmemset( pch, '0', 3 ); // init fraction
            while ( *cpcEditString == '9' && *pch )
            {
               if ( isdigit( *pchDTString ) )
               {
                  *pch++ = *pchDTString++;
                  cpcEditString++;
               }
               else
               {
                  bError = TRUE;
                  break;
               }
            }

            if ( bError )
               break;

            while ( *cpcEditString == '9' )
               cpcEditString++;

            break;
         }

         case '\"':  // quote
         case '\'':  // aposthorpe
            chDelimiter = *cpcEditString++;
            break;

         case '(':   // left paren
         case ')':   // right paren
         case ':':   // colon
         case ',':   // comma
         case '-':   // dash
         case '/':   // slash
         case '.':   // period
         case ' ':   // space
            if ( *pchDTString++ != *cpcEditString++ )
               bError = TRUE;

            break;

         default:
         {
            bBadEditString = TRUE;
            bError = TRUE;
         }
      }

      if ( bError )
         break;
   }

   // We should now have a valid DateTime string in szDT.
   if ( bError == FALSE )
   {
      if ( bConvertJulian )
      {
         zCHAR szG[ 9 ];
         strncpy_s( sz, zsizeof( sz ), szDT, 4 ); // copy YYYY
         sz[ 4 ] = 0;
         strcat_s( sz, zsizeof( sz ), szJulian ); // copy jjj
         UfJulianToGregorian( sz, szG );
         zmemcpy( szDT, szG, 8 );
         // now we really have a vaid DateTime in szDT
      }

      if ( bDayNeeded == FALSE )
      {
         // Plug the day with "01" since the edit string doesnt require a valid day.
         if ( szDT[ 6 ] == 'X' )
            szDT[ 6 ] = '0';
         if ( szDT[ 7 ] == 'X' )
            szDT[ 7 ] = '1';
      }

      if ( bTwelveHourClock )
      {
         zLONG l;

         // Bump clock into the afternoon
         sz[ 0 ] = *(szDT + 8);
         *(sz + 1) = *(szDT + 9);
         *(sz + 2) = 0;
         l = zatol( sz );
         if ( bAdjustTime )
         {
            // if in here, we're in the pm time frame...
            if ( l < 12L )
            {
               l += 12L;
               zltoa( l, sz, zsizeof( sz ) );
               *(szDT + 8) = sz[ 0 ];
               *(szDT + 9) = *(sz + 1);
            }
         }
         else
         if ( l == 12L )
         {
            // adjust for 12 am
            *(szDT + 8) = '0';
            *(szDT + 9) = '0';
         }
      }

      // we should be all set, return value to the user.
      strcpy_s( pchReturnString, lMaxLth, szDT );
   }

   return( (bError ? (bBadEditString ? zCALL_ERROR : -1) : 0 ) );
}

/**** LOCAL FUNCTION *****/
zUSHORT
fnValidateDay( zUSHORT usMonth, zUSHORT usDay, zULONG ulYear );

/**** GLOBAL DayTable ****/
static                     // J  F  M  A  M  J  J  A  S  O  N  D
zCHAR    cMonth_Val[ 12 ] = { 6, 2, 2, 5, 0, 3, 5, 1, 4, 6, 2, 4 };

zUSHORT usDayTable[ 12 ] =
   { 0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };
zUSHORT usLeapDayTable[ 12 ] =
   { 0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335 };

//./ ADD NAME=UfStringToDateTime
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:   UfStringToDateTime
//
// PARAMETERS: lpDateTime       - pointer to the DateTime data
//             cpcDateTimeString - a date-time string (YYYYMMDDHHmmSSTht)
//                                contains one of the following formats:
//                                   YYYYMMDDHHmmSSTht
//                                   YYYYMMDDHHmmSSTh
//                                   YYYYMMDDHHmmSST
//                                   YYYYMMDDHHmmSS
//                                   YYYYMMDDHHmm
//                                   YYYYMMDD
//
//                                       YYYY - year
//                                       MM   - month
//                                       DD   - day
//                                       HH   - hour
//                                       mm   - minute
//                                       ss   - seconds
//                                       T    - tenths of seconds
//                                       h    - hundredths of seconds
//                                       t    - thousandths of seconds
//
// PURPOSE:    To convert a string to a DateTime (T) attribute type
//             The string is checked for correct values (e.g. 19960100
//             results in zCALL_ERROR, but 00000000112233 is valid,
//             because this is just a time).
//
// RETURNS:    0 - String converted, info set in DateTime area
//   zCALL_ERROR - Error in call
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfStringToDateTime( zCPCHAR cpcDateTimeString, LPDATETIME lpDateTime )
{
   zUSHORT        usStringLth;
   zUSHORT        usMonth;
   zUSHORT        usDay;
   zUSHORT        usDayOrg;
   zUSHORT        usSeconds;
   zUSHORT        usTSeconds;
   zULONG         ulYear;
   zULONG         ulHours;
   zUSHORT        usMinutes;
   zULONG         ulDateMinutes;
   zULONG         ulDays;
   zULONG         ulWorkYear;
   zCHAR          szWorkString[ 5 ];
   LPDTINTERNAL   lpDTInternal;
   zBOOL          bDateSet;
   zSHORT         nRC = 0;

   lpDTInternal = (LPDTINTERNAL) lpDateTime;

   // Null string will set the DateTime to 'NULL'
   if ( cpcDateTimeString == 0 || cpcDateTimeString[ 0 ] == 0 )
   {
      lpDTInternal->ulDateMinutes = (zULONG) lNullInteger;
      lpDTInternal->usTSeconds = 0;
      return( 0 );
   }

   usMonth = 0;
   usDay = 0;
   ulYear = 0;
   ulHours = 0;
   usMinutes = 0;
   usSeconds = 0;
   usTSeconds = 0;

   usStringLth = (zUSHORT) zstrlen( cpcDateTimeString );
   switch ( usStringLth )
   {
      case 17:   // YYYYMMDDHHmmSSTht
      case 16:   // YYYYMMDDHHmmSSTh
      case 15:   // YYYYMMDDHHmmSST
         // Get Thousandths of seconds Value
         strcpy_s( szWorkString, zsizeof( szWorkString ), (zPCHAR) (cpcDateTimeString + 14) );
         usTSeconds = (zUSHORT) zatol( szWorkString );
         if ( usStringLth < 17 )
            usTSeconds *= ( usStringLth == 16 ) ? 10 : 100 ;

      case 14:   // YYYYMMDDHHmmSS
         // Get Seconds Value
         szWorkString[ 0 ] = *(cpcDateTimeString + 12);
         szWorkString[ 1 ] = *(cpcDateTimeString + 13);
         szWorkString[ 2 ] = 0;
         usSeconds = (zUSHORT) zatol( szWorkString );
         if ( usSeconds > 59 )
         {
            usSeconds = 59;
            nRC = zCALL_ERROR;
         }

      case 12:   // YYYYMMDDHHmm
         // Get Minutes Value
         szWorkString[ 0 ] = *(cpcDateTimeString + 10);
         szWorkString[ 1 ] = *(cpcDateTimeString + 11);
         szWorkString[ 2 ] = 0;
         usMinutes = (zUSHORT) zatol( szWorkString );
         if ( usMinutes > 59 )
         {
            usMinutes = 59;
            nRC = zCALL_ERROR;
         }

         // Get Hours Value
         szWorkString[ 0 ] = *(cpcDateTimeString + 8);
         szWorkString[ 1 ] = *(cpcDateTimeString + 9);
         szWorkString[ 2 ] = 0;
         ulHours = (zULONG) zatol( szWorkString );
         if ( ulHours > 23 )
         {
            ulHours = 23;
            nRC = zCALL_ERROR;
         }

      case 8:    // YYYYMMDD
         // Get Day Value
         szWorkString[ 0 ] = *(cpcDateTimeString + 6);
         szWorkString[ 1 ] = *(cpcDateTimeString + 7);
         szWorkString[ 2 ] = 0;
         usDay = (zUSHORT) zatol( szWorkString );

         // Get Month Value
         szWorkString[ 0 ] = *(cpcDateTimeString + 4);
         szWorkString[ 1 ] = *(cpcDateTimeString + 5);
         szWorkString[ 2 ] = 0;
         usMonth = (zUSHORT) zatol( szWorkString );

         // Get Year Value
         strncpy_s( szWorkString, zsizeof( szWorkString ), cpcDateTimeString, 4 );
         szWorkString[ 4 ] = 0;
         ulYear = (zULONG) zatol( szWorkString );

         // Check to see if we have date/datetime or only time without date.
         bDateSet = (ulYear || usMonth || usDay);

         if ( !ulYear )
         {
           ulYear = 1900;
           if ( bDateSet )
             nRC = zCALL_ERROR;
         }
         // the year will be multiplied with minutes/year and then stored as unsigned long. These means, max. can be not much more than 8000
         if ( ulYear > 8000 )
         {
           ulYear = 8000;
           nRC = zCALL_ERROR;
         }

         // if month out of range, make it January
         if ( usMonth < 1 || usMonth > 12 )
         {
            usMonth = 1;
            if ( bDateSet )
               nRC = zCALL_ERROR;
         }

         // Get valid day for the month
         usDayOrg = usDay;
         usDay = fnValidateDay( usMonth, usDayOrg, ulYear );
         if ( usDay != usDayOrg )
         {
           if ( bDateSet )
             nRC = zCALL_ERROR;
         }
         break;

      default:
         return( zCALL_ERROR );
   }

   // Calculate Year in Minutes
   ulWorkYear = 0;
   ulDateMinutes = 0;

   // Fast path for dates starting Jan 1, 1900.  Start point set to beginning of century.
   if ( ulYear >= 1900L )
   {
      ulWorkYear = 1900L;
      ulDateMinutes = Year1900;
      if ( ulYear >= 2000L )
      {
         ulWorkYear = 2000L;
         ulDateMinutes += Century;
      }
   }

   // This will get us to Jan 1, of the desired year.  This will take a bit longer when the year is less than 1900.
   while ( ulWorkYear < ulYear )
   {
      if ( !(ulWorkYear % 4) && ((ulWorkYear % 100) || !(ulWorkYear % 400)) )
      {
         ulDateMinutes += LeapYear;
      }
      else
      {
         ulDateMinutes += Year;
      }

      ulWorkYear++;
   }

   // This will get the number of days from the Jan 1, to the beginning of the desired month.
   if ( !(ulWorkYear % 4) && ((ulWorkYear % 100) || !(ulWorkYear % 400)) )
   {
      ulDays = usLeapDayTable[ usMonth - 1 ];
   }
   else
   {
      ulDays = usDayTable[ usMonth - 1 ];
   }

   ulDays += usDay - 1;                 // add day of the month, for days
                                        // this year
   ulDateMinutes += ulDays * Day;       // add days_minutes to total minutes
   ulDateMinutes += ulHours * Hour;     // add hours_minutes to total minutes
   // add minutes to total minutes
   ulDateMinutes += (zULONG)(usMinutes * Minute);

   // Now save this, before we forget...
   lpDTInternal->ulDateMinutes = ulDateMinutes;

   // Convert seconds to thousandths, and save it too.
   lpDTInternal->usTSeconds = usTSeconds + (usSeconds * 1000);

   return( nRC );

}  /* END of StringToDateTime */


/****************  fnValidateDay ******************/
zUSHORT
fnValidateDay( zUSHORT usMonth, zUSHORT usDay, zULONG ulYear )
{
   zUSHORT   usMax;

   if ( usDay >= 1 && usDay <= 28 )
      return( usDay );

   if ( usDay < 1 )
      return( 1 );

   switch ( usMonth )
   {
      case 2:
         usMax = 28;
         if ( (ulYear % 4) == 0 && ((ulYear % 100) || (ulYear % 400) == 0) )
         {
            usMax = 29;
         }

         break;

      case 4:
      case 6:
      case 9:
      case 11:
         usMax = 30;
         break;

      default:
         usMax = 31;
   }

   if ( usDay > usMax )
      return( usMax );
   else
      return( usDay );

} /*** END fnValidateDay ***/


//./ ADD NAME=UfDateTimeToString
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// FUNCTION:   UfDateTimeToString
//
// PARAMETERS: lpDateTime       - pointer to the DateTime data
//             pchReturnString  - pointer to area to return string
//             nMaxLth          - length of pchReturnString (including
//                                null terminator.)
//
// PURPOSE:    To convert a DateTime (T) attribute type into a string.
//             If the DateTime attribute is 'NULL', a null string will
//             be returned.
//
// RETURNS:    0 - String returned.
//            -1 - Null string returned.
//
//          When nMaxLth is     format of returned string is
//
//                   9           YYYYMMDD
//                   13          YYYYMMDDHHmm
//                   15          YYYYMMDDHHmmSS
//                   16          YYYYMMDDHHmmSST
//                   17          YYYYMMDDHHmmSSTh
//                   18          YYYYMMDDHHmmSSTht
//
//
//                              (YYYYMMDDHHmmSSTht)
//                               YYYY - year
//                               MM   - month
//                               DD   - day
//                               HH   - hour
//                               mm   - minute
//                               SS   - seconds
//                               T    - tenths of seconds
//                               h    - hundredths of seconds
//                               t    - thousandths of seconds
//
//   zCALL_ERROR - Error in call
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 3
zSHORT OPERATION
UfDateTimeToString( LPDATETIME lpDateTime, zPCHAR pchReturnString,
                    zSHORT nMaxLth )
{
   zULONG         ulDateMinutes;
   zUSHORT        k;
   zUSHORT        usYear, usMonth, usDay, usHour, usMinute;
   zUSHORT        usSeconds, usTSeconds;
   LPDTINTERNAL   lpDTInternal;

   lpDTInternal = (LPDTINTERNAL) lpDateTime;

   if ( lpDTInternal->ulDateMinutes == (zULONG) lNullInteger )
   {
      *pchReturnString = 0;
      return( -1 );
   }

   if ( nMaxLth < 9 )
      return( zCALL_ERROR );
   else
   if ( nMaxLth < 13 )
      nMaxLth = 9;      // Let's assume 9.
   else
   if ( nMaxLth < 15 )
      nMaxLth = 13;     // Let's assume 13.

   ulDateMinutes = lpDTInternal->ulDateMinutes;
   usTSeconds = lpDTInternal->usTSeconds;

   if ( ulDateMinutes >= Year2000 )
   {
      usYear = 2000;
      ulDateMinutes -= Year2000;
   }
   else
   if ( ulDateMinutes >= Year1900 )
   {
      usYear = 1900;
      ulDateMinutes -= Year1900;
   }
   else
      usYear = 0;

   for ( ; ; )
   {
      if ( !(usYear % 4) && ((usYear % 100) || !(usYear % 400)) )
      {
         if ( ulDateMinutes >= LeapYear )
         {
            usYear++;
            ulDateMinutes -= LeapYear;
         }
         else
            break;
      }
      else
      {
         if ( ulDateMinutes >= Year )
         {
            usYear++;
            ulDateMinutes -= Year;
         }
         else
            break;
      }
   }

   usDay = (zUSHORT) ( ulDateMinutes / Day );
   ulDateMinutes %= Day;

   k = 1;
   if ( (usYear % 4) == 0 && ((usYear % 100) || (usYear % 400) == 0) )
   {
      while ( k < 12 && usDay >= usLeapDayTable[ k ] )
         k++;

      usMonth = k;
      if ( k == 12 || usDay <= usLeapDayTable[ k ] )
         k--;

      usDay -= usLeapDayTable[ k ];
   }
   else
   {
      while ( k < 12 && usDay >= usDayTable[ k ] )
         k++;

      usMonth = k;
      if ( k == 12 || usDay <= usDayTable[ k ] )
         k--;

      usDay -= usDayTable[ k ];
   }

   usDay++;
   usHour = (zUSHORT) (ulDateMinutes / Hour);
   usMinute = (zUSHORT) (ulDateMinutes % Hour);
   if ( usTSeconds )
   {
      usSeconds = (zUSHORT) (usTSeconds / 1000);
      usTSeconds %= 1000;
   }
   else
      usSeconds = 0;

   zltoal( (zLONG) usYear, pchReturnString, 5 );           // year to string
   zltoal( (zLONG) usMonth, pchReturnString + 4, 3 );      // month to string
   zltoal( (zLONG) usDay, pchReturnString + 6, 3 );        // day to string
   if ( nMaxLth == 9 )
      return( 0 );

   zltoal( (zLONG) usHour, pchReturnString + 8, 3 );       // hour to string
   zltoal( (zLONG) usMinute, pchReturnString + 10, 3 );    // minute to string
   if ( nMaxLth == 13 )
      return( 0 );

   zltoal( (zLONG) usSeconds, pchReturnString + 12, 3 ); // seconds to string
   if ( nMaxLth == 15 )
      return( 0 );

   // milliseconds to string
   zltoal( (zLONG) usTSeconds, pchReturnString + 14, (zSHORT) (((nMaxLth - 15 ) > 4) ? 4 : (nMaxLth - 15)));

   return( 0 );

}  /* END of DateTimeToString */


//./ ADD NAME=UfCompareDateTimeToDateTime
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfCompareDateTimeToDateTime
//
// PARAMETERS: lpDateTime1
//             lpDateTime2
//
// RETURNS: -1 - DateTime1 less than DateTime2
//           0 - DateTime1 equal DateTime2
//           1 - DateTime1 greater than DateTime2
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 3
zSHORT   OPERATION
UfCompareDateTimeToDateTime( LPDATETIME lpDateTime1,
                             LPDATETIME lpDateTime2 )
{
   return( fnCompareDateTimeToDateTime( (LPDTINTERNAL) lpDateTime1, (LPDTINTERNAL) lpDateTime2 ) );
}

//./ ADD NAME=UfGetDayOfWeek
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfGetDayOfWeek
//
// PURPOSE:    Determines the day of the week for a given date.  Based on
//             the Gregorian calendar.
//
// PARAMETERS: cpcDateTime  (YYYYMMDD...)
//
// RETURNS:   day of week...
//           0 - Sunday
//           1 - Monday
//           2 - Tuesday
//           3 - Wednesday
//           4 - Thursday
//           5 - Friday
//           6 - Saturday
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zLONG OPERATION
UfGetDayOfWeek( zCPCHAR cpcDateTime )
{
   zSHORT   nMonth;
   zSHORT   nDay;
   zSHORT   nYear;
   zLONG    lDOW;

   zCHAR    sz[ 5 ];

   // year
   strncpy_s( sz, zsizeof( sz ), cpcDateTime, 4 );
   sz[ 4 ] = 0;
   nYear = (zSHORT) zatol( sz );

   // month
   sz[ 0 ] = *(cpcDateTime + 4);
   sz[ 1 ] = *(cpcDateTime + 5);
   sz[ 2 ] = 0;
   nMonth = (zSHORT) zatol( sz );

   // day
   sz[ 0 ] = *(cpcDateTime + 6);
   sz[ 1 ] = *(cpcDateTime + 7);
   sz[ 2 ] = 0;
   nDay = (zSHORT) zatol( sz );

   lDOW = nDay + cMonth_Val[ nMonth - 1 ];

   if ( nMonth < 3 )
   {
      if ( !(nYear % 4) && (nYear % 100) || !(nYear % 400) )
         lDOW--;
   }

   lDOW += nYear + ( nYear / 4 );
   lDOW += (nYear / 400) - (nYear / 100);
   lDOW %= 7;
   return( lDOW );
}

//./ ADD NAME=UfGetDayOfYear
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfGetDayOfYear
//
// PURPOSE:    Determines the day of the year for a given date.
//
// PARAMETERS: cpcDateTime  (YYYYMMDD...)
//
// RETURNS:   day of year
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zLONG OPERATION
UfGetDayOfYear( zCPCHAR cpcDateTime )
{
   zSHORT   nMonth;
   zSHORT   nDay;
   zSHORT   nYear;
   zLONG    lDOY;

   zCHAR    sz[ 5 ];

   // year
   strncpy_s( sz, zsizeof( sz ), cpcDateTime, 4 );
   sz[ 4 ] = 0;
   nYear = (zSHORT) zatol( sz );

   // month
   sz[ 0 ] = *(cpcDateTime + 4);
   sz[ 1 ] = *(cpcDateTime + 5);
   sz[ 2 ] = 0;
   nMonth = (zSHORT) zatol( sz );
   if ( nMonth < 1 )
      nMonth = 1;
   else
   if ( nMonth > 12 )
      nMonth = 12;

   // day
   sz[ 0 ] = *(cpcDateTime + 6);
   sz[ 1 ] = *(cpcDateTime + 7);
   sz[ 2 ] = 0;
   nDay = (zSHORT) zatol( sz );

   if ( (nYear % 4) == 0 && ((nYear % 100) || (nYear % 400) == 0) )
   {
      lDOY = (zLONG) usLeapDayTable[ nMonth - 1 ] + nDay;
   }
   else
      lDOY = (zLONG) usDayTable[ nMonth - 1 ] + nDay;

   return( lDOY );
}

//./ ADD NAME=UfGetWeekOfYear
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfGetWeekOfYear
//
// PURPOSE:    Determines the Week of the year for a given date.
//
// PARAMETERS: cpcDateTime  (YYYYMMDD...)
//
// RETURNS:   Week of year
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zLONG OPERATION
UfGetWeekOfYear( zCPCHAR cpcDateTime )
{
   return( ((UfGetDayOfYear( cpcDateTime ) - 1) / 7 ) + 1 );
}

//./ ADD NAME=fnGetDateTimeComponent
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      fnGetDateTimeComponent
//
// PURPOSE:    Return long value for the requested component
//
// PARAMETERS:
//
// RETURNS:    long value of component
//          -1 for invalid component id
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zLONG
fnGetDateTimeComponent( LPDATETIME lpDateTime, zSHORT nCID )
{
   zCHAR    szDateTime[ 20 ];
   zLONG    lValue = -1L;

   UfDateTimeToString( lpDateTime, szDateTime, zsizeof( szDateTime ) );
   switch ( nCID )
   {
      case zDT_YEAR:
         szDateTime[ 4 ] = 0;
         lValue = zatol( szDateTime );
         break;

      case zDT_MONTH:
         szDateTime[ 6 ] = 0;
         lValue = zatol( szDateTime + 4 );
         break;

      case zDT_DAY:
         szDateTime[ 8 ] = 0;
         lValue = zatol( szDateTime + 6 );
         break;

      case zDT_HOUR:
         szDateTime[ 10 ] = 0;
         lValue = zatol( szDateTime + 8 );
         break;

      case zDT_MINUTE:
         szDateTime[ 12 ] = 0;
         lValue = zatol( szDateTime + 10 );
         break;

      case zDT_SECOND:
         szDateTime[ 14 ] = 0;
         lValue = zatol( szDateTime + 12 );
         break;
   }

   return( lValue );
}

//./ ADD NAME=fnSetDateTimeComponent
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      fnSetDateTimeComponent
//
// PURPOSE:    Set long value for the requested component
//
// PARAMETERS:
//
// RETURNS:   0 - set okay
//  zCALL_ERROR - invalid component
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT
fnSetDateTimeComponent( LPDATETIME lpDateTime, zSHORT nCID, zLONG lValue )
{
   zCHAR    szDateTime[ 20 ];
   zCHAR    sz[ 10 ];
   zSHORT   nRC = 0;

   nRC = UfDateTimeToString( lpDateTime, szDateTime, zsizeof( szDateTime ) );
   switch ( nCID )
   {
      case zDT_YEAR:
         zltoa( lValue + 10000L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime, sz + 1, 4 );
         break;

      case zDT_MONTH:
         zltoa( lValue + 100L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime + 4, sz + 1, 2 );
         break;

      case zDT_DAY:
         zltoa( lValue + 100L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime + 6, sz + 1, 2 );
         break;

      case zDT_HOUR:
         zltoa( lValue + 100L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime + 8, sz + 1, 2 );
         break;

      case zDT_MINUTE:
         zltoa( lValue + 100L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime + 10, sz + 1, 2 );
         break;

      case zDT_SECOND:
         zltoa( lValue + 100L, sz, zsizeof( sz ) );
         zmemcpy( szDateTime + 12, sz + 1, 2 );
         break;

      default:
         nRC = zCALL_ERROR;
   }

   if ( nRC == 0 )
      nRC = UfStringToDateTime( szDateTime, lpDateTime );

   return( nRC );
}

//./ ADD NAME=UfJulianToGregorian
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  ENTRY:      UfJulianToGregorian
//
//  PURPOSE:    Convert from a julian date format to gregorian format
//
//  PARAMETERS: cpcJulian        - YYYYJJJ,  i.e. 1955041
//              pchGregorian     - YYYYMMDD, i.e. 19550210
//
//  RETURNS:
//              0 - Conversion successful
//    zCALL_ERROR - Error in call
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfJulianToGregorian( zCPCHAR cpcJulian, zPCHAR pchGregorian )
{
   zULONG                  ulYear;
   zULONG                  ulWorkYear;
   zUSHORT                 usDay;
   DateTimeInternalRecord  DT_Rec;
   zCHAR                   sz[ 20 ];

   // Get Day Value
   strcpy_s( sz, zsizeof( sz ), (zPCHAR) (cpcJulian + 4) );
   usDay = (zUSHORT) zatol( sz );

   // Get Year Value
   strncpy_s( sz, zsizeof( sz ), cpcJulian, 4 );
   sz[ 4 ] = 0;
   ulYear = (zULONG) zatol( sz );
   if ( ulYear == 0 )
      ulYear = 1900;

   /* Calculate Year in Minutes */
   ulWorkYear = 0;
   DT_Rec.ulDateMinutes = 0;
   DT_Rec.usTSeconds = 0;

   // Fast path for dates starting Jan 1, 1900.
   // Start point set to beginning of century.
   if ( ulYear >= 1900L )
   {
      ulWorkYear = 1900L;
      DT_Rec.ulDateMinutes = Year1900;
      if ( ulYear >= 2000L )
      {
         ulWorkYear = 2000L;
         DT_Rec.ulDateMinutes += Century;
      }
   }

   // This will get us to Jan 1, of the desired year.  This will take a bit longer when the year is less than 1900.
   while ( ulWorkYear < ulYear )
   {
      if ( (ulWorkYear % 4) == 0 && ((ulWorkYear % 100) || (ulWorkYear % 400) == 0) )
      {
         DT_Rec.ulDateMinutes += LeapYear;
      }
      else
      {
         DT_Rec.ulDateMinutes += Year;
      }
      ulWorkYear++;
   }

   // add julian day count
   DT_Rec.ulDateMinutes += (zULONG) (usDay * (Day - 1));

   if ( UfDateTimeToString( (LPDATETIME) &DT_Rec, sz, 9 ) == zCALL_ERROR )
      return( zCALL_ERROR );

   strcpy_s( pchGregorian, zsizeof( sz ), sz );

   return( 0 );
}

unsigned
char  Encrypt1[] = { 22, 5, 13, 16, 15, 0, 6, 23, 2, 19, 12, 9, 10,
                     1, 25, 4, 17, 7, 18, 11, 21, 14, 24, 20, 3, 8 };
unsigned
char  Encrypt2[] = { 10, 17, 4, 22, 1, 6, 20, 13, 12, 19, 5, 24, 8,
                     15, 7, 23, 2, 11, 21, 9, 14, 0, 25, 3, 16, 18 };

unsigned
char  EncryptNonAlpha[] = {  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             '\"',    // ' '
                             '@',     // '\"'
                             '%',     // '!'
                             '4',     // '#'
                             '&',     // '$'
                             '$',     // '%'
                             '\'',    // '&'
                             '3',     // '\''
                             '[',     // '('
                             '(',     // ')'
                             ':',     // '*'
                             '5',     // '+'
                             '+',     // ','
                             '!',     // '-'
                             '#',     // '.'
                             '?',     // '/'
                             '|',     // '0'
                             '.',     // '1'
                             '/',     // '2'
                             '`',     // '3'
                             '6',     // '4'
                             ',',     // '5'
                             '7',     // '6'
                             '-',     // '7'
                             '9',     // '8'
                             '8',     // '9'
                             '*',     // ':'
                             '1',     // ';'
                             ';',     // '<'
                             '>',     // '='
                             '<',     // '>'
                             ')',     // '?'
                             ' ',     // '@'
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0,
                             '}',     // '['
                             '=',     // '\\'
                             '2',     // ']'
                             '{',     // '^'
                             '\\',    // '_'
                             ']',     // '`'
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                             0, 0, 0, 0, 0, 0,
                             '^',     // '{'
                             '_',     // '|'
                             '~',     // '}'
                             '0'  };  // '~'

//./ ADD NAME=UfEncryptString
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfEncryptString
//
// PARAMETERS: pchOut - return string encrypted
//             pchIn  - String to encrypt
//             uLth   - maximum length of string to encrypt
//
// DESCRIPTION - This utility takes in a string and returns an
//               encrypted version of the string with a length
//               of the passed length value. The maximum length
//               which may be passed is 26.
//
// RETURNS:  0 - Success
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfEncryptString( zPCHAR pchOut, zPCHAR pchIn, zUSHORT uLth )
{
   zUSHORT uChar;
   zSHORT  nOrderIdx;
   zLONG   lInLth;
   zCHAR   cChar;
   zBOOL   bNullFound;
// zCHAR   szMsg[ 256 ];

// sprintf_s( szMsg, zsizeof( szMsg ), "UfEncryptString Length: %d In: \"%s\"", uLth, pchIn );
// TraceLineS( szMsg, "" );

   if ( uLth > 26 )
      uLth = 26;

   uChar = 0;
   nOrderIdx = 0;
   bNullFound = FALSE;
   pchOut[ uLth ] = 0;
   while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )
      nOrderIdx++;

   lInLth = zstrlen( pchIn );
   while ( (zUSHORT) lInLth > uLth || lInLth > 25 )
      lInLth -= uLth;

   pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ lInLth ];
   nOrderIdx++;
   while ( uChar < (uLth - 1) )
   {
      while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )
         nOrderIdx++;

      if ( bNullFound == FALSE && pchIn[ uChar ] )
      {
         cChar = pchIn[ uChar ];

         if ( isalpha( cChar ) )
         {
            while ( cChar >= 'a' )
               cChar -= ' ';

            while ( cChar < 'A' )
               cChar += 11;

            cChar -= 'A';
            if ( uChar % 2 )
               pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ cChar ];
            else
               pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt2[ cChar ];
         }
         else
            pchOut[ Encrypt2[ nOrderIdx ] ] = EncryptNonAlpha[ cChar ] - 'a';
      }
      else
      {
         cChar += 17;
         if ( cChar > 25 )
            cChar -= 25;

         bNullFound = TRUE;
         if ( uChar % 2 )
            pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt2[ cChar ];
         else
            pchOut[ Encrypt2[ nOrderIdx ] ] = Encrypt1[ cChar ];
      }

      uChar++;
      nOrderIdx++;
   }

   for ( uChar = 0 ; uChar < uLth ; uChar++ )
      pchOut[ uChar ] += 'a';

// sprintf_s( szMsg, zsizeof( szMsg ), "UfEncryptString Out: \"%s\"", pchOut );
// TraceLineS( szMsg, "" );
   return( 0 );
}

//./ ADD NAME=UfDecryptString
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfDecryptString
//
// PARAMETERS: pchOut - return string Decrypted
//             pchIn  - Encrypted string
//             uLth   - maximum length of string to return
//
// DESCRIPTION - This utility takes in an Encrypted string and returns
//               the Decrypted version of ths string.
//
// RETURNS:  0 - Success
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfDecryptString( zPCHAR pchOut, zPCHAR pchIn, zUSHORT uLth )
{
   zUSHORT uChar;
   zSHORT  nOrderIdx;
   zUCHAR  ucChar;
   zCHAR   cWk;
   zCHAR   cReturnLth;
   zSHORT  nReturnLth;
// zCHAR   szMsg[ 256 ];

// sprintf_s( szMsg, zsizeof( szMsg ), "UfDecryptString Length: %d In: \"%s\"", uLth, pchIn );
// TraceLineS( szMsg, "" );

   if ( *pchIn == 0 )
   {
      *pchOut = 0;
      return( 0 );
   }

   if ( uLth > 26 )
      uLth = 26;

   uChar = 0;
   nOrderIdx = 0;
   while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )
      nOrderIdx++;

   cReturnLth = pchIn[ Encrypt2[ nOrderIdx ] ] - 'a';
   nReturnLth = 0;
   while ( Encrypt1[ nReturnLth ] != (zUCHAR) cReturnLth )
      nReturnLth++;

   cReturnLth = (zCHAR) nReturnLth;
   nOrderIdx++;
   while ( cReturnLth )
   {
      while ( Encrypt2[ nOrderIdx ] > (uLth - 1) )
         nOrderIdx++;

      ucChar = pchIn[ Encrypt2[ nOrderIdx ] ];
      if ( isalpha( ucChar ) )
      {
         ucChar -= 'a';
         if ( uChar % 2 )
         {
            cWk = 0;
            while ( Encrypt1[ cWk ] != ucChar )
               cWk++;

            pchOut[ uChar ] = cWk + 'a';
         }
         else
         {
            cWk = 0;
            while ( Encrypt2[ cWk ] != ucChar )
               cWk++;

            pchOut[ uChar ] = cWk + 'a';
         }
      }
      else
      {
         zSHORT nIdx;

         // Look for the encrypted char in the non-alpha table.
         for ( nIdx = 32; nIdx < 127; nIdx++ )
         {
            if ( EncryptNonAlpha[ nIdx ] == ucChar )
               break;
         }

         if ( nIdx == 127 )
         {
            SysMessageBox( 0, "Zeidon Internal Error", "Error decrypting string", 0 );
            return( zCALL_ERROR );
         }

         pchOut[ uChar ] = (zCHAR) nIdx;
      }

      cReturnLth--;
      uChar++;
      nOrderIdx++;
   }

   pchOut[ uChar ] = 0;
// sprintf_s( szMsg, zsizeof( szMsg ), "UfDecryptString Out: \"%s\"", pchOut );
// TraceLineS( szMsg, "" );
   return( nReturnLth );
}

//./ ADD NAME=UfAddToDateTime
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfAddToDateTime
//
// PARAMETERS: lpDateTime  -
//             nAmount     -
//             nAmountType -
//
// RETURNS:     0 - Success
//    zCALL_ERROR - error during call
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 4
zSHORT OPERATION
UfAddToDateTime( LPDATETIME   lpDateTime,
                 zLONG        lAmount,
                 zSHORT       nAmountType )
{
   zLONG                   lYM;
   zULONG                  ul;
   zUSHORT                 un = 0;
   zLONG                   lY, lM;
   DateTimeInternalRecord  dt;
   zBOOL                   bSubtract;
   zBOOL                   bYadjust = 0;
   zBOOL                   bDone = 0;
   zSHORT                  nRC = 0;

   // DGC:TODO -- use view passed in to get current task.  Uncomment other uses of lpCurrentTask
   //if ( (lpCurrentTask = fnOperationCall( iUfAddToDateTime, vTaskView )) == 0 )
   //   return( zCALL_ERROR );

   // If amount to add is zero, get out.
   if ( lAmount == 0 )
   {
   // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
      return( 0 );
   }

   // Establish if adding or subtracting...
   bSubtract = (lAmount < 0) ? 1 : 0;
   lAmount = labs( lAmount );

   // For safety's sake, make a copy
   zmemcpy( (zPCHAR) &dt, (zPCHAR) lpDateTime, sizeof( DateTimeRecord ) );

   // if date time is null set to 1-1-1 prior to 'add'
   if ( fnCompareDateTimeToDateTime( &stNullDateTime, &dt ) == 0 )
      UfStringToDateTime( "00010101", (LPDATETIME) &dt );

   switch ( nAmountType )
   {
      case zDT_YEAR:
         lY = fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR );
         if ( bSubtract )
         {
            lY -= lAmount;
            if ( lY < 1 )
            {
               // underflow...
               // "KZOEE236 - Integer underflow"
               fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );
            // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
               nRC = zCALL_ERROR;
               bDone = TRUE;
            }
         }
         else
         {
            lY += lAmount;
            if ( lY > 9999 )
            {
               // overflow...
               // "KZOEE235 - Integer overflow"
               fnSysMessageBox( 0, "Zeidon Error", "Year greater than 9999", 0 );
            // fnIssueCoreError( 0, lpView, 16, 235, 0, "Year greater than 9999", 0 );
               nRC = zCALL_ERROR;
               bDone = TRUE;
            }
         }

         if ( nRC == 0 )
         {
            nRC = fnSetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR, lY );
            bDone = TRUE;
         }
         break;

      case zDT_MONTH:
         lY = (zLONG) fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_YEAR );
         lM = (zLONG) fnGetDateTimeComponent( (LPDATETIME)&dt, zDT_MONTH );
         if ( bSubtract )
         {
            if ( lM <= lAmount )
            {
               bYadjust = TRUE;
               lYM = (lY * 12) + lM - lAmount;
               lM = lYM % 12;
               lY = (lYM / 12) - ( !lM ? 1 : 0 );
               if ( lM == 0 )
                  lM = 12;

               if ( lY < 1 )
               {
                  // underflow...
                  // "KZOEE236 - Integer underflow"
                  fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );
               // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
                  nRC = zCALL_ERROR;
                  bDone = TRUE;
               }
            }
            else
               lM -= lAmount;
         }
         else
         {
            lM += lAmount;
            if ( lM > 12 )
            {
               bYadjust = TRUE;
               lY += (lM / 12);
               lM = (lM % 12);
               if ( !lM )
               {
                  lY--;
                  lM = 12;
               }

               if ( lY > 9999 )
               {
                  // overflow...
                  // "KZOEE235 - Integer overflow"
                  fnSysMessageBox( 0, "Zeidon Error", "Year greater than 9999", 0 );
               // fnIssueCoreError( 0, lpView, 16, 235, 0, "Year greater than 9999", 0 );
                  nRC = zCALL_ERROR;
                  bDone = TRUE;
               }
            }
         }

         if ( nRC == 0 )
         {
            zUSHORT usDay;

            if ( bYadjust )
               fnSetDateTimeComponent( (LPDATETIME) &dt, zDT_YEAR, lY );

            nRC = fnSetDateTimeComponent( (LPDATETIME) &dt, zDT_MONTH, lM );

            // Make sure the day is valid.
            if ( nRC == zCALL_ERROR )
            {
               // Oops...day must be wrong.  Change it.
               usDay = (zUSHORT) fnGetDateTimeComponent( (LPDATETIME) &dt, zDT_DAY );
               usDay = fnValidateDay( (zUSHORT) lM, usDay, lY );
               nRC = fnSetDateTimeComponent( (LPDATETIME) &dt, zDT_DAY, usDay );
            }

            bDone = TRUE;
         }

         break;

      case zDT_DAY:
         ul = lAmount * Day;
         break;

      case zDT_HOUR:
         ul = lAmount * Hour;
         break;

      case zDT_MINUTE:
         ul = lAmount * Minute;
         break;

      case zDT_SECOND:
         ul = lAmount;
         if ( ul > 59 )
         {
            un = (zUSHORT)(ul % 60);
            ul /= 60;
         }
         else
         {
            un = (zUSHORT) ul;
            ul = 0;
         }
         un *= 1000;  // adjust to thousandths of a second
         break;

      default:
         // "KZOEE023 - Invalid parameter, "
         fnSysMessageBox( 0, "Zeidon Error", "Invalid parameter", 0 );
      // fnIssueCoreError( 0, lpView, 8, 23, 0, "lAmountType", 0 );
      // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
         return( zCALL_ERROR );
   }

   if ( bDone == FALSE )
   {
      if ( bSubtract )
      {
         // Subtract
         if ( un > dt.usTSeconds )
         {
            if ( ul > (dt.ulDateMinutes - 1) )
            {
               // underflow...
               // "KZOEE236 - Integer underflow"
               fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );
            // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
               nRC = zCALL_ERROR;
            }
            else
            {
               dt.usTSeconds += ( (zUSHORT)60000 - un );
               dt.ulDateMinutes -= ul + 1;
            }
         }
         else
         {
            if ( ul > dt.ulDateMinutes )
            {
               // underflow...
               // "KZOEE236 - Integer underflow"
               fnSysMessageBox( 0, "Zeidon Error", "Year less than 1", 0 );
            // fnIssueCoreError( 0, lpView, 16, 236, 0, "Year less than 1", 0 );
               nRC = zCALL_ERROR;
            }
            else
            {
               dt.usTSeconds -= un;
               dt.ulDateMinutes -= ul;
            }
         }
      }
      else
      {
         // Add
         dt.usTSeconds += un;
         if ( dt.usTSeconds >= 60000 )
         {
            dt.ulDateMinutes++;
            dt.usTSeconds -= 60000;
         }
         dt.ulDateMinutes += ul;

         if ( fnCompareDateTimeToDateTime( &dt, (LPDTINTERNAL) lpDateTime ) == -1 )
         {
            // overflow
            // "KZOEE235 - Integer overflow"
            fnSysMessageBox( 0, "Zeidon Error", "Integer overflow", 0 );
         // fnIssueCoreError( 0, lpView, 16, 235, 0, 0, 0 );
            nRC = zCALL_ERROR;
         }
      }
   }

   // if no problems copy back to user area.
   if ( nRC == 0 )
      zmemcpy( (zPCHAR) lpDateTime, (zPCHAR) &dt, sizeof( DateTimeRecord ) );

// fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
   return( nRC );
} // UfAddToDateTime


//./ ADD NAME=UfDateTimeDiff
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
// ENTRY:      UfDateTimeDiff
//
// PARAMETERS:
//             plDiff      - pointer to variable returning difference
//             lpDateTime1 - First Timestamp
//             lpDateTime2 - Second Timestamp
//             nDiffType   - unit for difference (zDT_SECOND, ...)
//
// RETURNS:     0 - Success
//             -1 - overflow
//    zCALL_ERROR - error during call (invalid AmountType)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 4
zSHORT OPERATION
UfDateTimeDiff( zPLONG  plDiff,
                LPDATETIME   lpDateTime1,
                LPDATETIME   lpDateTime2,
                zSHORT       nDiffType )
{
   zSHORT               nRC = 0;
   zUSHORT              usDiffLo;
   zULONG               ulDiffHi;
   zLONG                lDiff;
   zLONG                lY1, lY2, lM1, lM2, lD1, lD2;
   LPDTINTERNAL         lpDT1, lpDT2;
   DateTimeInternalRecord  dt, dt1, dt2;
   zBOOL                bNegative;
   zBOOL                bOverflow = FALSE;

   *plDiff = 0;
   memcpy( &dt1, lpDateTime1, sizeof(DateTimeInternalRecord) );
   memcpy( &dt2, lpDateTime2, sizeof(DateTimeInternalRecord) );
   lpDT1 = &dt1;
   lpDT2 = &dt2;

   // For Year, Month or Date
   if ( nDiffType == zDT_YEAR ||
        nDiffType == zDT_MONTH ||
        nDiffType == zDT_DAY )
   {
     // use only the date part of the timestamp
     lpDT1->usTSeconds = 0;
     lpDT2->usTSeconds = 0;
     ulDiffHi = lpDT1->ulDateMinutes % Day;
     lpDT1->ulDateMinutes -= ulDiffHi;
     ulDiffHi = lpDT2->ulDateMinutes % Day;
     lpDT2->ulDateMinutes -= ulDiffHi;
   }

   // determine the sign of the difference
   nRC = fnCompareDateTimeToDateTime( &dt1, &dt2 );
   bNegative = (nRC > 0);

   // shortcut for equal values.
   if ( nRC == 0 )
      return( 0 );

   // If negative, exchange the two date time values.
   if ( bNegative )
   {
     lpDT1 = &dt2;
     lpDT2 = &dt1;
   }

   // calculate the difference with carry bit
   ulDiffHi = lpDT2->ulDateMinutes - lpDT1->ulDateMinutes;
   if ( lpDT1->usTSeconds > lpDT2->usTSeconds )
   {
     ulDiffHi--;
     usDiffLo = (zUSHORT) (lpDT2->usTSeconds - lpDT1->usTSeconds + 60000);
   }
   else
   {
     usDiffLo = lpDT2->usTSeconds - lpDT1->usTSeconds;
   }

   switch ( nDiffType )
   {
      case zDT_YEAR:
         // calculate the difference of the year number
         lY1 = fnGetDateTimeComponent( (LPDATETIME) lpDT1, zDT_YEAR );
         lY2 = fnGetDateTimeComponent( (LPDATETIME) lpDT2, zDT_YEAR );
         lDiff = lY2 - lY1;

         // check for carry (e.g. "19970101" - "19961231" has lDiff=1
         // and has to be corrected!)
         UfAddToDateTime( (LPDATETIME) lpDT1, lDiff, zDT_YEAR);
         if ( fnCompareDateTimeToDateTime( lpDT1, lpDT2 ) == 1 )
         {
           lDiff--;
         }

         break;

      case zDT_MONTH:
         // get the days for additional carry, then set it 0 for calculation
         lD1 = fnGetDateTimeComponent( (LPDATETIME) lpDT1, zDT_DAY );
         lD2 = fnGetDateTimeComponent( (LPDATETIME) lpDT2, zDT_DAY );
         fnSetDateTimeComponent( (LPDATETIME) lpDT1, zDT_DAY, 0L );
         fnSetDateTimeComponent( (LPDATETIME) lpDT2, zDT_DAY, 0L );

         // calculate the difference of the years and the months
         lY1 = fnGetDateTimeComponent( (LPDATETIME) lpDT1, zDT_YEAR );
         lY2 = fnGetDateTimeComponent( (LPDATETIME) lpDT2, zDT_YEAR );
         lM1 = fnGetDateTimeComponent( (LPDATETIME) lpDT1, zDT_MONTH );
         lM2 = fnGetDateTimeComponent( (LPDATETIME) lpDT2, zDT_MONTH );
         lDiff = (lY2 - lY1) * 12 + lM2 - lM1;

         // check for carry caused by leap year (has to be corrected!)
         do
         {
           memcpy( &dt, lpDT1, sizeof(DateTimeInternalRecord) );
           UfAddToDateTime( (LPDATETIME)&dt, lDiff, zDT_MONTH);
           nRC = fnCompareDateTimeToDateTime( &dt, lpDT2 );

           lDiff += nRC;

         } while ( nRC );

         // check for carry caused by difference in days (and correct it)
         if ( lD2 < lD1 )
           lDiff--;

         break;

      case zDT_DAY:
         lDiff = (zLONG) (ulDiffHi / Day);
         break;

      case zDT_HOUR:
         lDiff = (zLONG) (ulDiffHi / Hour);
         break;

      case zDT_MINUTE:
         if (ulDiffHi > 0x7fffffff)
         {
           bOverflow = TRUE;
           break;
         }

         lDiff = (zLONG) ulDiffHi;
         break;

      case zDT_SECOND:
         if (ulDiffHi > (0x7fffffff / 60 - 1) )
         {
           bOverflow = TRUE;
           break;
         }

         lDiff = (zLONG) (ulDiffHi * 60 + usDiffLo / 1000);
         break;

      default:
         // "KZOEE023 - Invalid parameter, "
         fnSysMessageBox( 0, "Zeidon Error", "Invalid parameter", 0 );
      // fnIssueCoreError( 0, lpView, 8, 23, 0, "nDiffType", 0 );
      // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
         return( zCALL_ERROR );
   }

   if ( bOverflow )
   {
   // fnOperationReturn( iUfAddToDateTime, lpCurrentTask );
      return( -1 );
   }

   if ( bNegative )
     lDiff *= -1;

   *plDiff = lDiff;
   return( 0 );

} // UfDateTimeDiff

//./ ADD NAME=UfEditFormatString
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//   ENTRY:    UfEditFormatString
//
//   PURPOSE:  Validate an Input string format. This function takes in a
//             formatted character string and validates the format of
//             the string using the format mask provided.
//             The characters 9,A,a,N,X,L,U,H and * in an input
//             format string represent numeric, alphabatic,
//             alphabetic upper, alphanumeric and ANY character to be
//             validated in the input string.  All other characters
//             in the format string ( '(', ' ', ')','-', etc ) must
//             match the input String.
//
//             For example the String passed with a format mask of:
//
//                 '( 99AaX )' must contain a '(' in the first byte
//                 followed by a space, a digit 0-9, an uppercase
//                 alphabetic, an upper or lower case alphabetic, an
//                 alphanumeric, a trailing space and a final ')'.
//
// PARAMETERS:
//           pchReturnString   - the input/output string.
//           cpcFormat   - format string applied to pchReturnString.
//
// RETURNS:  0 - pchReturnString contains 'formatted' string. Note: if the
//               input string is null, an output string of null is
//               returned.
//           1 - pchReturnString contained characters that did not conform
//               to the format string.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfEditFormatString( zPCHAR pchReturnString, zCPCHAR cpcFormat )
{
   zSHORT   i, j, k, l;

   k = 0;
   j = 0;
   if ( cpcFormat == 0 || cpcFormat[ 0 ] == 0 || pchReturnString[ 0 ] == 0 )
      return( 0 );

   while ( pchReturnString[ j ] )
   {
      switch ( cpcFormat[ k ] )
      {
         case  0:
            return( 1 );

         case  '9':
            if ( !isdigit( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'A':
            if ( !isalpha( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'N':
            if ( !zisalnum( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'X':
            if ( !zisascii( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'L':
            if ( !islower( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'U':
            if ( !isupper( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  'H':
            if ( !isxdigit( pchReturnString[ j ] ) )
               return( 1 );
            break;

         case  '\\':
            if ( cpcFormat[ ++k ] == 0 )
               return( 1 );

            if ( pchReturnString[ j ] != cpcFormat[ k ] )
               return( 1 );

            i = j;
            do
            {
               pchReturnString[ i ] = pchReturnString[ i + 1 ];

            } while ( pchReturnString[ i++ ] );

            j--;
            break;

         case  ' ':
            // This code treats all spaces in pchReturnString as one space, seems like we should consider how many spaces are in cpcFormat.
            if ( pchReturnString[ j ] == ' ' )
            {
               i = j + 1;
               if ( cpcFormat[ k + 1 ] != ' ' )
               {
                  while( pchReturnString[ i ] == ' ' )
                     i++;
               }

               l = j;
               do
               {
                  pchReturnString[ l++ ] = pchReturnString[ i ];

               } while ( pchReturnString[ i++ ] );

               j--;
            }
            else
               return( 1 );

            break;

         default:
            if ( cpcFormat[ k ] != pchReturnString[ j ] )
               return( 1 );

            i = j;
            do
            {
               pchReturnString[ i ] = pchReturnString[ i + 1 ];

            } while ( pchReturnString[ i++ ] );

            j--;
      }

      k++;
      j++;
   }

   if ( cpcFormat[ k ] )
      return( 1 );

   return( 0 );
}

//./ ADD NAME=UfFormatString
// Source Module=kzoeufaa.c
//*******************************************************************
//
// ENTRY:    UfFormatString
//
// PURPOSE:  Format an output string. This function takes in an
//           unformatted character string and formats the string
//           by adding characters as defined in the format string
//           passed.
//           For example to format a telephone number the
//           string paramater should contain the telephone digits
//           ( ex. 6172718822 ) and the format string could contain
//           '( 999 ) 999-9999'.  The output string would be
//           '( 617 ) 271-8822'.
//
//           Each character in the format string directly represents
//           one character to be displayed (with the exception of escape
//           codes, which are prefixed by a '/' character).  If that
//           character is one of the following edit types, the
//           corresponding legal characters will be permitted. Otherwise,
//           the character is considered to be a constanct place holder.
//
// PARAMETERS:
//           pchReturnString   - the input/output string.
//           cpcFormat   - format string applied to pchReturnString.
//
// RETURNS:  0 - pchReturnString contains 'formatted' string. Note: if the
//               input string is null, an output string of null is
//               returned.
//           1 - pchReturnString contained characters that did not conform
//               to the format string.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfFormatString( zPCHAR pchReturnString, zCPCHAR cpcFormat )
{
   zSHORT k, j, i;

   k = 0;
   j = 0;

   if ( pchReturnString[ 0 ] == 0 )
      return( 0 );

   if ( cpcFormat == 0 || cpcFormat[ 0 ] == 0 )
      return( 0 );

   while ( cpcFormat[ k ] )
   {
      switch ( cpcFormat[ k ] )
      {
         case  '9':
            if ( !isdigit( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'A':
            if ( !isalpha( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'N':
            if ( !zisalnum( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'X':
            if ( !zisascii( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'U':
            if ( !isupper( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'L':
            if ( !islower( pchReturnString[ j ] ) )
               return( 1 );

            break;

         case  'H':
            if ( !isxdigit( pchReturnString[ j ] ) )
               return( 1 );

            break;

         default:
            if ( cpcFormat[ k ] == '\\' )
            {
               if ( cpcFormat[ k + 1 ] )
                  k++;
               else
                  break;
            }

            i = j;
            while ( pchReturnString[ i ] )
               i++;

            while ( i >= j ) // brute force
            {
               pchReturnString[ i + 1 ] = pchReturnString[ i ];
               i--;
            }

            pchReturnString[ j ] = cpcFormat[ k ];
      }

      k++;
      j++;
   }

   // Error if the string is 'longer' than the format string.
   if ( pchReturnString[ j ] )
      return( -1 );

   return( 0 );
}

//./ ADD NAME=fnDetermineDateTimeStrlen
// Source Module=kzoeufaa.c
//*******************************************************************
//
// ENTRY:    fnDetermineDateTimeStrlen
//
// PURPOSE:  Format an output string. This function takes in an
//
// PARAMETERS:
//           cpcEditString - format string applied to scan.
//
// RETURNS:  >0 - length of longest possible string, using the input
//                edit string.
//  zCALL_ERROR - error in the edit string.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT
fnDetermineDateTimeStrlen( zCPCHAR cpcEditString )
{
   zSHORT   nCounter = 0;
   zCHAR    chDelimiter = 0;

   if ( cpcEditString == 0 || cpcEditString[ 0 ] == 0 )
      return( nCounter );

   while ( *cpcEditString )
   {
      if ( chDelimiter )
      {
         if ( *cpcEditString == chDelimiter )
         {
            chDelimiter = 0;
            cpcEditString++;
         }
         else
         {
            nCounter++;
            cpcEditString++;
         }
      }
      else
      switch ( *cpcEditString )
      {
         case 'A':
         case 'P':
            if ( *(cpcEditString + 1) == 'M' )
            {
               zLONG  n1, n2;
               LPINTERNATIONAL lpInternational = zGETPTR( AnchorBlock->hInternational );

               // use which ever length is greater
               if ( lpInternational->sz1159[ 0 ] == 0 )
                  n1 = 2;
               else
                  n1 = zstrlen( lpInternational->sz1159 );

               if ( lpInternational->sz2359[ 0 ] == 0 )
                  n2 = 2;
               else
                  n2 = zstrlen( lpInternational->sz2359 );

               nCounter += (zSHORT) ((n1 > n2) ? n1 : n2);
               cpcEditString += 2;
            }
            else
               return( zCALL_ERROR );

            break;

         case 'd':
         case 'D':
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "ddd", 3 ) == 0 )
            {
               zLONG   k;
               zLONG   n1, n2;
               // use the greatest length
               for ( n1 = 0, k = 0; k < 7; k++ )
               {
                  n2 = zstrlen( g_pchDOW[ k ] );
                  if ( n2 > n1 )
                     n1 = n2;
               }

               nCounter += (zSHORT) n1;
               cpcEditString += 4;
            }
            else
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "dd", 2 ) == 0 )
            {
               // three for short day name
               nCounter += 3;
               cpcEditString += 3;
            }
            else
            if ( *(cpcEditString + 1) == 'D' ||
                 *(cpcEditString + 1) == 'd' )
            {
               // two for the day of the month (w/leading zero if < 10 )
               nCounter += 2;
               cpcEditString += 2;
            }
            else
            {
               // two for the day of the month ( max possible )
               nCounter += 2;
               cpcEditString++;
            }

            break;

         case 'H':
            // assume max ( 2 )
            nCounter += 2;
            cpcEditString++;
            if ( *cpcEditString == 'H' )
               cpcEditString++;

            break;

         case 'j':
            if ( zstrncmp( (zPCHAR)(cpcEditString + 1), "jj", 2 ) == 0 )
            {
               nCounter += 3;
               cpcEditString += 3;
            }
            else
               return( zCALL_ERROR );

            break;

         case 'M':
            if ( *(cpcEditString + 1) == 'I' )
            {
               nCounter += 2;
               cpcEditString += 2;
               break;
            }
            // break left out intentionally!

         case 'm':
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mmm", 3 ) == 0 )
            {
               zLONG   k;
               zLONG   n1, n2;

               for ( n1 = 0, k = 0; k < 12; k++ )
               {
                  n2 = zstrlen( g_pchMon[ k ] );
                  if ( n2 > n1 )
                     n1 = n2;
               }
               nCounter += (zSHORT) n1;
               cpcEditString += 4;
            }
            else
            if ( zstrncmpi( (zPCHAR)(cpcEditString + 1), "mm", 2 ) == 0 )
            {
               nCounter += 3;
               cpcEditString += 3;
            }
            else
            if ( *(cpcEditString + 1) == 'M' ||
                 *(cpcEditString + 1) == 'm' )
            {
               // two for the month
               nCounter += 2;
               cpcEditString += 2;
            }
            else
            {
               // two for the month
               nCounter += 2;
               cpcEditString++;
            }

            break;

         case 'S':
            if ( *(cpcEditString + 1) == 'S' )
            {
               nCounter += 2;
               cpcEditString += 2;
            }
            else
               return( zCALL_ERROR );

            break;

         case 'Y':
            if ( *(cpcEditString + 1) == 'Y' )
            {
               if ( *(cpcEditString + 2) == 'Y' && *(cpcEditString + 3) == 'Y' )
               {
                  // four for the year;
                  nCounter += 4;
                  cpcEditString += 4;
               }
               else
               {
                  // two for the year
                  nCounter += 2;
                  cpcEditString += 2;
               }
            }
            else
               return( zCALL_ERROR );

            break;

         case '9':
         {
            zSHORT   k;
            for ( k = 0; *cpcEditString == '9' && k < 3; k++ )
            {
               nCounter++;
               cpcEditString++;
            }

            while ( *cpcEditString == '9' )
               cpcEditString++;

            break;
         }

         case '\"':  // quote
         case '\'':  // aposthorpe
            chDelimiter = *cpcEditString++;
            break;

         case '(':   // left paren
         case ')':   // right paren
         case ':':   // colon
         case ',':   // comma
         case '-':   // dash
         case '/':   // slash
         case '.':   // period
         case ' ':   // space
            nCounter++;
            cpcEditString++;
            break;

         default:
            return( zCALL_ERROR );

      }
   }

   return( nCounter );
}

/////////////////////////////////////////////////////////////////////////////
//
// MODULE NAME:   kzoeufaa.c - ZeidonString manipulation routines used by
//                code generated by VML.
// DESCRIPTION:   This is the source file for the following string
//                manipulation routines:
//
//                     ZeidonStringCopy
//                     ZeidonStringConcat
//                     ZeidonStringCompare
//                     ZeidonStringConvertFromNumber
//
//                The purpose is to use these functions in place of the C
//                level string string functions (since they will be generated
//                by VML) so that the handling of strings is more complete
//                and error resistent.  Additionally, strings will be handled
//                the same way regardless of the target language.
//
/////////////////////////////////////////////////////////////////////////////
//

#define     qMAXRECEIVEISNEGATIVE       -2
#define     qMAXCOPYISNEGATIVE          -3
#define     qMAXRECEIVEEXCEEDSTARGETLEN -4
#define     qINVALIDPARAMETER           -5

//./ ADD NAME=ZeidonStringCopy
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringCopy
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringCopy is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.  If this is a -1, we
//                              will move the characters into the target
//                              string, without a null character at end.
//              cpcSrcString  - The source string of the copy.
//              lSrcIdx       - The index into the string at which reading
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ 33 ];
//                              lMaxTgtLth should be 33).  It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target until the end of the target, never exceeding lMaxTgtLth.
//    If lMaxCopy is 0, then copy until the end of the source, target, or
//    lMaxReceive, whichever comes first.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zSHORT OPERATION
ZeidonStringCopy( zPCHAR  pchTgtString,
                  zLONG   lTgtIdx,
                  zLONG   lMaxReceive,
                  zCPCHAR cpcSrcString,
                  zLONG   lSrcIdx,
                  zLONG   lMaxCopy,
                  zLONG   lMaxTgtLth )
{
   zLONG lNbrToCopy;
   zLONG lLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(kzoeufaa) ZeidonStringCopy:    TgtString", pchTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", cpcSrcString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxCopy", lMaxCopy );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   if ( pchTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings
        lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Invalid parameter.", 1 );
      return( qINVALIDPARAMETER );
   }

   lTgtIdx--;  // convert 1-based index to 0-based index for
   lSrcIdx--;

   // Ensure all parms sync up and that lTgtIdx + lMaxReceive is less than lMaxTgtLth.
   if ( lMaxReceive < -1 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Target string has negative length", 1 );
      return( qMAXRECEIVEISNEGATIVE );
   }

   if ( lMaxCopy < 0 )
      return( qMAXCOPYISNEGATIVE );

   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Target string is too small", 1 );
      return( qMAXRECEIVEEXCEEDSTARGETLEN );
   }

   // Ensure the source index does not point beyond the end of the source string.
   if ( lSrcIdx > (zLONG)zstrlen(cpcSrcString) )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Invalid parameter (source index).", 1 );
      return( qINVALIDPARAMETER );
   }

   // If lMaxReceive is -1, move the characters to the target without a null at end.
   if ( lMaxReceive == -1 )
   {
      if ( lMaxCopy == 0 )
         lMaxCopy = lMaxTgtLth - lTgtIdx - 1;

      while ( *(cpcSrcString + lSrcIdx) != 0 && lMaxCopy > 0 )
      {
         *(pchTgtString + lTgtIdx++) = *(cpcSrcString + lSrcIdx++);
         lMaxCopy--;
      }

      return( (zSHORT) zstrlen( pchTgtString ) );
   }

   // If lMaxReceive is the default of 0 then the Max is really lMaxTgtLth - lTgtIdx - 1 (for zero-based index).
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth - lTgtIdx - 1;

   if ( lMaxCopy == 0 )
      lMaxCopy = lMaxReceive;

   // Copy the lesser of lMaxReceive or lMaxCopy.
   lNbrToCopy = (lMaxReceive < lMaxCopy) ? lMaxReceive : lMaxCopy;
   lLth = zstrlen( cpcSrcString + lSrcIdx );
   if ( lLth < lNbrToCopy )
      lNbrToCopy = lLth + 1;

   strncpy_s( pchTgtString + lTgtIdx, lMaxTgtLth - lTgtIdx, cpcSrcString + lSrcIdx, lNbrToCopy );
   pchTgtString[ lTgtIdx + lNbrToCopy ] = 0;

#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( (zSHORT) zstrlen( pchTgtString ) );
}

//./ ADD NAME=ZeidonStringConcat
// Src Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringConcat
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringConcat is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - Ignored in this function
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              cpcSrcString  - The source string of the concatenation.
//              lSrcIdx       - The index into the string at which copying
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ 33 ];
//                              lMaxTgtLth should be 33).  It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target starting at the end of the target, never exceeding
//    lMaxTgtLth. If lMaxConcat is 0, then copy until the end of the
//    source, target, or lMaxReceive, whichever comes first.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zSHORT OPERATION
ZeidonStringConcat( zPCHAR  pchTgtString,
                    zLONG   lTgtIdx,
                    zLONG   lMaxReceive,
                    zCPCHAR cpcSrcString,
                    zLONG   lSrcIdx,
                    zLONG   lMaxConcat,
                    zLONG   lMaxTgtLth )
{
   zLONG lNbrToConcat;
   zLONG lSrcLth;
   zLONG lTgtLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(kzoeufaa) ZeidonStringConcat:  TgtString", pchTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", cpcSrcString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxConcat", lMaxConcat );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   // If the source string is null, simply return.
   if ( *cpcSrcString == 0 )
      return( (zSHORT) zstrlen( pchTgtString ) );

   if ( pchTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings
        lSrcIdx == 0 )                                // 1-based index
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConcat: Invalid parameter.", 1 );
      return( qINVALIDPARAMETER );
   }

   lSrcIdx--;  // convert 1-based index to 0-based index for

   // Ensure all parms sync up and that lTgtIdx + lMaxReceive is less than lMaxTgtLth.
   if ( lMaxReceive < 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConcat: Target string has negative length.", 1 );
      return( qMAXRECEIVEISNEGATIVE );
   }

   if ( lMaxConcat < 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConcat: Source string has negative length.", 1 );
      return( qMAXCOPYISNEGATIVE );
   }

   if ( lMaxReceive > lMaxTgtLth )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConcat: Target string is too small.", 1 );
      return( qMAXRECEIVEEXCEEDSTARGETLEN );
   }

   // Find the current end.
   lTgtIdx = zstrlen( pchTgtString );
   if ( lTgtIdx > lMaxTgtLth )
      lTgtIdx = lMaxTgtLth;

   // If lMaxReceive is the default of 0 then the Max is really
   // lMaxTgtLth - lTgtIdx.
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth - lTgtIdx;

   if ( lMaxConcat == 0 )
      lMaxConcat = lMaxReceive;

   // concat the lesser of lMaxReceive or lMaxCopy.
   lNbrToConcat = (lMaxReceive < lMaxConcat) ? lMaxReceive : lMaxConcat;
   lTgtLth = zstrlen( pchTgtString );           // So many chars still there
   lSrcLth = zstrlen( cpcSrcString + lSrcIdx ); // So many chars should be added
   if ( lSrcLth < lNbrToConcat )                // check number of source chars to add
      lNbrToConcat = lSrcLth + 1;

   if ( (lTgtLth + lNbrToConcat) >= lMaxTgtLth ) // check whole length of new target
      lNbrToConcat = lMaxTgtLth - lTgtLth - 1;

   strncpy_s( pchTgtString + lTgtIdx, lMaxTgtLth - lTgtIdx, cpcSrcString + lSrcIdx, lNbrToConcat );
   pchTgtString[ lTgtIdx + lNbrToConcat ] = 0;

#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( (zSHORT) zstrlen( pchTgtString ) );
}

//./ ADD NAME=ZeidonStringCompare
// Src Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringCompare
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringCompare is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: cpcTgtString  - The resultant string (copied into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              cpcSrcString  - The source string of the copy.
//              lSrcIdx       - The index into the string at which reading
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ 33 ];
//                              lMaxTgtLth should be 33).  It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target until the end of the target, never exceeding lMaxTgtLth.
//    If lMaxCopy is 0, then copy until the end of the source, target, or
//    lMaxReceive, whichever comes first.
//
//  RETURNS:    -1  - Source string < Target string
//               0  - Source string = Target string
//               1  - Source string > Target string
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zSHORT OPERATION
ZeidonStringCompare( zCPCHAR cpcTgtString,
                     zLONG   lTgtIdx,
                     zLONG   lMaxReceive,
                     zCPCHAR cpcSrcString,
                     zLONG   lSrcIdx,
                     zLONG   lMaxCompare,
                     zLONG   lMaxTgtLth )
{
   zLONG lNbrToCompare;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(kzoeufaa) ZeidonStringCompare: TgtString", cpcTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", cpcTgtString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxCompare", lMaxCompare );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   if ( cpcTgtString == 0 || cpcSrcString == 0 ||     // gotta have strings
        lTgtIdx <= 0 || lSrcIdx <= 0 )                // 1-based index
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCompare: Invalid parameter.", 1 );
      return( qINVALIDPARAMETER );
   }

   lTgtIdx--;  // convert 1-based index to 0-based index for
   lSrcIdx--;

   /* ensure all parms sync up and that lTgtIdx + lMaxReceive is less than lMaxTgtLth */
   if ( lMaxReceive < 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCompare: Target string has negative length.", 1 );
      return( qMAXRECEIVEISNEGATIVE );
   }

   if ( lMaxCompare < 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCompare: Source string has negative length.", 1 );
      return( qMAXCOPYISNEGATIVE );
   }

   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCompare: Target string is too short.", 1 );
      return( qMAXRECEIVEEXCEEDSTARGETLEN );
   }

   // If lMaxReceive is the default of 0 then the Max is really lMaxTgtLth - lTgtIdx.
   if ( lMaxReceive == 0 )
   {
      // Max receive is 0, set max receive to the number of characters in the target string EXCLUDING the null terminator
      lMaxReceive = lMaxTgtLth - (lTgtIdx - 1);

      // If MaxCompare is 0 as well, assume the C convention of comparing by including the null terminator in the compare on the target string.
      if ( lMaxCompare == 0 )
         lMaxReceive++;
   }

   if ( lMaxCompare == 0 )
      lMaxCompare = lMaxReceive;

   // Compare the lesser of lMaxReceive or lMaxCompare.
   lNbrToCompare = (lMaxReceive < lMaxCompare) ? lMaxReceive : lMaxCompare;
   return( zstrncmp( cpcSrcString + lSrcIdx,
                     cpcTgtString + lTgtIdx, lNbrToCompare ) );
}

//./ ADD NAME=ZeidonStringFind
// Src Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringFind
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringFind is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: cpcTgtString  - The String to search.
//              nlTgtIdx       - The index into the string at which searching
//                               will begin. Note that Zeidon Strings are
//                               indexed starting at 1 rather than 0.
//              pchSearch     - The String to find in the TargetString
//
//  RETURNS:    -1  - Parameter error
//               0  - Search string not found in the Target string
//              otw - 1-based index at which the search string was found
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 4
zSHORT OPERATION
ZeidonStringFind( zCPCHAR cpcTgtString,
                  zSHORT  nTgtIdx,
                  zCPCHAR cpcSearch )
{
   if ( nTgtIdx > 0 )
   {
      zPCHAR pch = zstrstr( cpcTgtString + nTgtIdx - 1, cpcSearch );

      if ( pch )
         return( pch - cpcTgtString + 1 );
      else
         return( 0 );
   }

   return( -1 );
}

//./ ADD NAME=ZeidonStringConvertFromNumber
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringConvertFromNumber
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringConvertFromNumber is similar to other Zeidon
//             string routines, except that there is only one string variable
//             (the target) and either an integer variable or a decimal
//             variable.  Only one or the other should be supplied and the
//             other parameter should be 0, as indicated by NumberType.
//             Like the other string routines, this routine uses the index and
//             max target length parameters.  If the converted data is greater
//             than the max target length, the target string is filled with
//             "*****".
//
//  PARAMETERS: pchTgtString  - The resultant string (converted into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ 33 ];
//                              lMaxTgtLth should be 33).  It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//              lIntegerValue - The integer value to be converted.
//              dDecimalValue - The decimal value to be converted.
//              cNumberType   - 'I' for integer and 'D' for decimal.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zSHORT OPERATION
ZeidonStringConvertFromNumber( zPCHAR   pchTgtString,
                               zLONG    lTgtIdx,
                               zLONG    lMaxReceive,
                               zLONG    lMaxTgtLth,
                               zLONG    lIntegerValue,
                               zDECIMAL dDecimalValue,
                               zCPCHAR  cpcNumberType )
{
   zCHAR szWorkString[ 64 ];
   zLONG lLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(kzoeufaa) ZeidonStringConvertFromNumber:  TgtString", pchTgtString );
   TraceLineI( "                                           lTgtIdx", lTgtIdx );
   TraceLineI( "                                           lMaxTgtLth", lMaxTgtLth );
   TraceLineI( "                                           lIntegerValue", lIntegerValue );
#endif


   if ( lMaxReceive < 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConvertFromNumber: Target string has negative length.", 1 );
      return( qMAXRECEIVEISNEGATIVE );
   }

//   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
//      return( qMAXRECEIVEEXCEEDSTARGETLEN );


   // if lMaxReceive is the default of 0 then the Max is really lMaxTgtLth - lTgtIdx +1 (as lTgtIdx is 1-based)
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth -lTgtIdx +1;

   if ( pchTgtString == NULL || lTgtIdx <= 0 )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringConvertFromNumber: Invalid parameter.", 1 );
      return( qINVALIDPARAMETER );
   }

   if ( cpcNumberType[ 0 ] != 'I' && cpcNumberType[ 0 ] != 'D' )
      return( qINVALIDPARAMETER );

   lTgtIdx--;  // convert 1-based index to 0-based index

   if ( cpcNumberType[ 0 ] == 'I' )
      zltoa( lIntegerValue, szWorkString, zsizeof( szWorkString ) );
   else
      ConvertDecimalToString( szWorkString, 0, dDecimalValue, 0 );

   // Copy the lesser of lMaxReceive or the length of the converted value.
   lLth = zstrlen( szWorkString );
   if ( lLth > lMaxReceive )
   {
      lLth = lMaxReceive;
      *(pchTgtString + lTgtIdx + lLth) = 0;
      lLth--;
      while ( lLth >= 0 )
      {
         *(pchTgtString + lTgtIdx + lLth) = '*';
         lLth--;
      }
   }
   else
   {
      strncpy_s( pchTgtString + lTgtIdx, lMaxTgtLth - lTgtIdx, szWorkString, lLth );
      pchTgtString[ lTgtIdx + lLth ] = 0;
   }


#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( (zSHORT) zstrlen( pchTgtString ) );
}

//./ ADD NAME=ZeidonCopyWithinString
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonCopyWithinString
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringCopy is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lSrcIdx       - The index into the string at which reading
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ 33 ];
//                              lMaxTgtLth should be 33).  It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 5
zSHORT OPERATION
ZeidonCopyWithinString( zPCHAR  pchTgtString,
                        zLONG   lTgtIdx,
                        zLONG   lSrcIdx,
                        zLONG   lMaxTgtLth )
{
   zLONG lSrcLth;

   if ( pchTgtString == 0 ||                          // gotta have strings
        lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Invalid parameter.", 1 );
      return( qINVALIDPARAMETER );
   }

   lTgtIdx--;  // convert 1-based index to 0-based index
   lSrcIdx--;

   lSrcLth = zstrlen( pchTgtString + lSrcIdx );
   if ( (lTgtIdx + lSrcLth) >= lMaxTgtLth )
   {
      SysMessageBox( 0, szlOE_SystemError, "ZeidonStringCopy: Target string is too small", 1 );
      return( qMAXRECEIVEEXCEEDSTARGETLEN );
   }

   strcpy_s( pchTgtString + lTgtIdx, lMaxTgtLth - lTgtIdx, pchTgtString + lSrcIdx );
   return( (zSHORT) zstrlen( pchTgtString ) );
}

#ifdef DEBUG_STRINGS

int
main( void )
{
   zCHAR szStr1[ 100 ];
   zCHAR szStr2[ 10 ];
   zCHAR szStr3[ 1090 ];  // buffer  to keep from overlaying on error
   zPCHAR szStr4 = "Zeidon_Tools .9a";
   zPCHAR szStr5 = "1234567890abcdefghijklmnopqrstuvwxyz";
   zLONG lRC;

   szStr1[ 0 ] = 0;
   szStr2[ 0 ] = 0;
   szStr3[ 0 ] = 0;
   lRC = ZeidonStringCopy( szStr1, 1, 0, szStr4, 1, 8, 8 );
   TraceLineS( "Zeidon_Tools .9a", szStr1 );
   lRC = ZeidonStringCopy( szStr1, 1, 0, szStr4, 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCopy( szStr1, 1, 0, "A", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCopy( szStr2, 1, 0,
                           "1234567890abcdefghijklmnopqrstuvwxyz",
                           1, 0, zsizeof( szStr2 ) );
   lRC = ZeidonStringCopy( szStr2, 1, 0, szStr5, 1, 0, zsizeof( szStr2 ) );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "A", 1, 0, zsizeof( szStr1 ) );
   TraceLineI( "String Compare Returned (0)", lRC );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "B", 1, 0, zsizeof( szStr1 ) );
   TraceLineI( "String Compare Returned (!0)", lRC );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "AAA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "AxA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "", 1, 0, "AxA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "", 1, 0, "", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "WWWW", 1, 0, "", 1, 0, 100 );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "AABxA", 1, 2, zsizeof( szStr1 ) );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "ABAxA", 1, 2, zsizeof( szStr1 ) );

   return( 0 );
}
#endif

zSHORT LOCALOPER
fnRemoveChars( zPCHAR pchStr,
               zLONG  lShortNameLth,
               zCHAR  cQualifier,
               zPCHAR pchRemoveChars,
               zPCHAR pchPrevChars,
               zCHAR  cReplace )
{
   zLONG  lLth;
   zPCHAR pch;
   zPCHAR pch2;

   if ( pchStr == 0 || pchStr[ 0 ] == 0 )
      return( 0 );

   if ( cQualifier == 0 )
      return( 0 );

   if ( pchRemoveChars == 0 || pchRemoveChars[ 0 ] == 0 )
      return( 0 );

   switch ( cQualifier )
   {
      case 'A':
         break;

      case 'B':
         // Remove starting from back, so reverse string.
         zstrrev( pchStr );
         lLth = zstrlen( pchStr );
         break;

      case 'F':
         lLth = zstrlen( pchStr );
         break;
   }

   for ( pch = pch2 = pchStr; *pch; pch++ )
   {
      // If current char isn't to be removed, then copy char and continue.
      if ( zstrchr( pchRemoveChars, *pch ) == 0 )
      {
         *pch2++ = *pch;
         continue;
      }

      // Check to see if previous char is in pchPrevChars. If pchPrevChars is
      // NULL, then we assume we are removing the char.  If pchPrevChars is
      // not NULL, then we only remove the current char if the previous char
      // exists in the pchPrevChars string.
      if ( pchPrevChars )
      {
         // If we are at the beginning of the string then there is no prev char so don't remove the char.
         if ( pch2 == pchStr )
         {
            *pch2++ = *pch;
            continue;
         }

         // If pchPrevChars contains a '*', then we only remove the current char if it is the same char as the previous char.
         if ( *pchPrevChars == '*' )
         {
            if ( *pch != *(pch2 - 1) )
            {
               // Chars are not the same, so copy char and continue.
               *pch2++ = *pch;
               continue;
            }
         }
         else
         if ( zstrchr( pchPrevChars, *(pch2 - 1) ) == 0 )
         {
            // The previous char is not in the pchPrevChars string, so we don't want to remove the current char.
            *pch2++ = *pch;
            continue;
         }
      }

      // If we are replacing the removed char with something, then do it.  Since this doesn't make the string any shorter, continue.
      if ( cReplace )
      {
         *pch2++ = cReplace;
         continue;
      }

      // By not copying the char we've deleted it. If we are deleting ALL chars, continue loop.
      if ( cQualifier == 'A' )
         continue;

      // We have removed a char.  Check to see if string is now short enough.

      // Take into account deleted char.
      lLth--;

      if ( lLth > lShortNameLth )
         continue;  // Name still isn't short enough.

      // Name is short enough.  Copy the rest of the string and break loop.
      for ( ; *pch; pch++, pch2++ )
         *pch2 = *pch;

      *pch2 = 0;
      break;

   } // for...

   *pch2 = 0;

   if ( cQualifier == 'B' )
      zstrrev( pchStr );

   return( 0 );

} // fnRemoveChars

//./ ADD NAME=UfCompressName
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfCompressName
//
//  PURPOSE:    Removes chars and/or truncates an input string until it is
//              no larger than a specified length.
//
//  PARAMETERS: szLongName         Input Name
//              szShortName        Output Name (shortened)
//              lShortNameLth      max lth of output name
//              szSpaceReplace     replace or delete spaces
//              szUnderscoreMode   how to handle underscore
//              szLowerVowels      how to remove vowels
//              szOtherChars       other chars to remove
//              nPhasesToForce     keep going even if short
//
//  ALGORITHM:
//       Phase 0. remove any leading or trailing white space.
//       Phase 1. if szSpaceReplace is NULL, remove embedded space.
//                otherwise replace the spaces with szSpaceReplace.
//       Phase 2. remove underscores based on the value of szUnderscorMode:
//                   NULL = No removal
//                   Ax = if x is NULL, remove All -- otherwize replace with x
//                   Fx = remove until short enough, starting at Front
//                   Bx = remove until short enough, starting at Back
//                   AL = remove All only after lowercase chars
//                   FL = remove only after lowercase chars, starting at Front
//                   BL = remove only after lowercase chars, starting at Back
//       Phase 3. remove lowercase vowels based on the value of szLowerVowels:
//                   NULL = No removal
//                   Ax = remove All
//                   Fx = remove until short enough, starting at Front
//                   Bx = remove until short enough, starting at Back
//                 if x = 'c', then remove duplicate lowercase consonants
//       Phase 4. remove any chars that match chars in szOtherChars after the
//                'mode'(first) char.  The mode char is A, F, or B as above.
//       Phase 5. truncate the string to lShortNameLth.
//
//            NOTE: the algorith stops at the end of any phase that has a
//            result that is less than or equal to lShortNameLth unless
//            nPhasesToForce indicates to continue.
//
//     RESULTS:   Returns the length of the string that the parameter
//                szSortName is set to.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 9
zSHORT OPERATION
UfCompressName( zPCHAR  pchLongName,
                zPCHAR  pchShortName,
                zLONG   lShortNameLth,
                zPCHAR  pchSpaceReplace,
                zPCHAR  pchUnderscoreMode,
                zPCHAR  pchLowerVowels,
                zPCHAR  pchOtherChars,
                zSHORT  nPhasesToForce )
{
   zPCHAR  pch;
   zPCHAR  pch2;
   zSHORT  nPhasesDone;
   zPCHAR  pchPrevChar;
   zCHAR   sz[ 256 ];
   zCHAR   cReplace;
   zSHORT  k, j;


   //========================================================================
   //
   // 0. remove any leading or trailing white space.
   //
   //========================================================================

   // Remove leading spaces.
   for ( pch = pchLongName; zisspace( *pch ); pch++ )
   {
      // Nothing needs to be done here.
   }
/*
if (lShortNameLth == 30 )
{
      TraceLine( "UfCompressName 1 longname: %s shortname: %s shortnamelth %d ",
                 pchLongName, pchShortName, lShortNameLth );
}
*/
   strcpy_s( sz, zsizeof( sz ), pch );


   // Remove trailing spaces.
   for ( pch = &sz[ zstrlen( sz ) ] - 1; zisspace( *pch ) && pch > sz ; pch-- )
   {
      // Nothing needs to be done here.
   }

   pch++;
   *pch = 0;

   /*
   ** remove any german 'umlaute'  (28.07.1997; RG)
   */
   for ( k = 0; k < (zSHORT) zstrlen( sz ); k++ )
   {
      if ( zisascii( sz[ k ] ) == FALSE )
      {
         for ( j = k; j < (zSHORT) zstrlen( sz ); j++ )
            sz[ j ] = sz[ j + 1 ];
      }
   }

   nPhasesDone = 0;
   if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= (zULONG) lShortNameLth )
      goto EndOfFunction;

   //========================================================================
   //
   // 1. if pchSpaceReplace is NULL, remove embedded space.
   //      otherwise replace the spaces with pchSpaceReplace.
   //
   //========================================================================

   for ( pch = pch2 = sz; *pch; pch++ )
   {
      if ( zisspace( *pch ) )
      {
         if ( pchSpaceReplace && pchSpaceReplace[ 0 ] )
            *pch2++ = pchSpaceReplace[ 0 ];
      }
      else
         *pch2++ = *pch;
   }

   *pch2 = 0;

   nPhasesDone = 1;
   if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= (zULONG) lShortNameLth )
      goto EndOfFunction;

   //========================================================================
   //
   // 2. remove underscores based on the value of pchUnderscorMode:
   //       NULL = No removal
   //       Ax = if x is NULL, remove All -- otherwize replace with x
   //       Fx = remove until short enough, starting at Front
   //       Bx = remove until short enough, starting at Back
   //       AL = remove All only after lowercase chars
   //       FL = remove only after lowercase chars, starting at Front
   //       BL = remove only after lowercase chars, starting at Back
   //
   //========================================================================

   if ( pchUnderscoreMode && pchUnderscoreMode[ 0 ] )
   {
      if ( pchUnderscoreMode[ 1 ] == 'L' )
      {
         pchPrevChar = "aeiou";
         cReplace = 0;
      }
      else
      {
         pchPrevChar = 0;
         cReplace = pchUnderscoreMode[ 1 ];
      }

      fnRemoveChars( sz, lShortNameLth, pchUnderscoreMode[ 0 ], "_", pchPrevChar, cReplace );
   }
//if (lShortNameLth == 30 )
//{
//      TraceLine( "UfCompressName 2 sz:%s ",
//                 sz );
//}

   nPhasesDone = 2;
   if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= (zULONG) lShortNameLth )
      goto EndOfFunction;

   //========================================================================
   //
   // 3. remove lowercase vowels based on the value of pchLowerVowels:
   //       NULL = No removal
   //       Ax = remove All
   //       Fx = remove until short enough, starting at Front
   //       Bx = remove until short enough, starting at Back
   //       if x = 'c', then remove duplicate lowercase consonants
   //
   //========================================================================

   if ( pchLowerVowels && pchLowerVowels[ 0 ] != 0 )
   {
      fnRemoveChars( sz, lShortNameLth, pchLowerVowels[ 0 ], "aeiou", 0, 0 );

      if ( pchLowerVowels[ 1 ] == 'c' )
         fnRemoveChars( sz, lShortNameLth, pchLowerVowels[ 0 ], "bcdfghjklmnpqrstvwxyz", "*", 0 );
   }

   nPhasesDone = 3;
   if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= (zULONG) lShortNameLth )
      goto EndOfFunction;

   //========================================================================
   //
   // 4. remove any chars that match chars in pchOtherChars after the
   //      'mode'(first) char.  The mode char is:
   //      NULL = No removal
   //      A = remove All
   //      F = remove until short enough, starting at Front
   //      B = remove until short enough, starting at Back
   //
   //========================================================================

   if ( pchOtherChars[ 0 ] != 0 )
   {
      fnRemoveChars( sz, lShortNameLth, pchOtherChars[ 0 ], pchOtherChars + 1, 0, 0 );
   }

   nPhasesDone = 4;
   if ( nPhasesDone >= nPhasesToForce && zstrlen( sz ) <= (zULONG) lShortNameLth )
      goto EndOfFunction;

   //========================================================================
   //
   // 5. truncate the string to lShortNameLth.
   //
   //========================================================================

   sz[ lShortNameLth ] = 0;

EndOfFunction:
   // KJS 07/22/16 - our old code did not do the " - 1" and had the line above sz[ lShortNameLth ] = 0
   // and the old code had the zstrcpy, not strcpy_s. If we keep the new code, long names, are short a 
   // character (due to the - 1) but if I don't do the - 1, then strcpy_s fails. So I am for now going
   // back to our old 10c code for this.
   //sz[ lShortNameLth - 1 ] = 0;
//TraceLine( "Ufcompressed before %s", sz);
   //strcpy_s( pchShortName, lShortNameLth, sz );
   zstrcpy( pchShortName, sz );
//TraceLine( "Ufcompressed after");
   return( (zSHORT) zstrlen( pchShortName ) );

}  // UfCompressName

/////////////////////////////////////////////////////////////////////////////
//
//  UfZProbeXX function require non-dynamic declarations to minimize the
//  impact on timing information.
//
/////////////////////////////////////////////////////////////////////////////
#define MAX_ZPROBES    50  // 3 for testing  - should be 50
#define MAX_ZPROBEDESC 31
#define MAX_ZPROBEERRS 5

typedef struct     // ZProbe entry
{
   zBOOL   zp_Active;                   // entry is active or inactive
   zCHAR   zp_Desc[ MAX_ZPROBEDESC ];   // probe descriptor
   zULONG  zp_StartTime;                // start time of activation
   zULONG  zp_TotalTime;                // total time probe activated
   zULONG  zp_CountOn;                  // number of activations for probe
   zULONG  zp_CountOff;                 // number of deactivations for probe
} ZPROBE_ENTRY;

typedef struct zProbeArea
{
   zBOOL  bProbesEnabled;   // True if functions are currently enabled
   zSHORT nErrShown1;
   zSHORT nErrShown2;
   zSHORT nErrShown3;
   zSHORT nErrShown4;
   zSHORT nErrShown5;
   zSHORT nErrShown6;
   zSHORT nProbes;                  // Current number of used probes
   ZPROBE_ENTRY Probes[ MAX_ZPROBES + 1 ]; // allocate storage for probes
   zULONG  ProbSetInitTime;         // start time of ZProbeInit
} ZPROBEAREA;

// probe area is allocated dynamically to a global pointer
ZPROBEAREA *g_pProbeArea = 0;

//./ ADD NAME=UfZProbeEnable
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeEnable
//
//  PURPOSE:    Enable/disable ALL UfZProbeXXX functions.
//              NOTE: You MUST call UfZProbeEnable with TRUE before
//              UfZProbeInit if you want to see output.
//
//  PARAMETERS: bEnable   -- TRUE or FALSE
//
//  OVERVIEW:
//       The probe functionality is used performance timing analysis.
//       There can be up to 50 probes active simultaneously.  The
//       probes are "named" (30 chars max) and can overlap in time.
//
//       The enabled functions are:
//           UfZProbeInit   -- Initializes the array of probes
//           UfZProbeOn     -- Start timing with the next or a
//                             specific probe.
//           UfZProbeOff    -- Stop timing wirh a specific probe
//                             and accumulate the elapsed time.
//           UfZProbeTrace  -- Turn off all active probes and
//                             log results to Zeidon trace window.
//
//       Probes can be left in the the code with no impact since
//       the UfZProbeEnable function allows entire sections of
//       UfZProbeInit...UfZProbeTrace calls to be enabled/disabled
//       quickly.
//
//  Example of using probes.
//
//    UfZProbeEnable( TRUE );       // Enables the probes
//    UfZProbeInit                  // Initialize the array of probes
//    UfZProbeOn( -1, "Pre Loop Stuff", FALSE );
//        .. some code here ..
//    UfZProbeOn( -1, "Loop Total", TRUE );
//    loop 1000
//       p1 = UfZProbeOn( -1, "--Part A", FALSE );
//         .. more code here ..
//       UfZProbeOff( p1 );
//       p2 = UfZProbeOn( -1, "--Part A", FALSE );
//        .. more code here ..
//       UfZProbeOff( p2 );
//    end loop.
//    UfZProbeTrace( );             // Dump probes to trace window
//
//    The trace window will contain the output
//
//       zp..000                 Pre Loop Stuff: nnn.nnn secs.
//       zp..001                     Loop Total: nnn.nnn secs.
//       zp..002                       --Part 1: nnn.nnn secs.
//       zp..003                       --Part 2: nnn.nnn secs.
//
//
//  RESULTS:    Returns the number of probes available for use.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfZProbeEnable( zBOOL   bEnable )
{

   if ( g_pProbeArea == 0 )
   {
      if ( (g_pProbeArea = (ZPROBEAREA *) SysMalloc( sizeof( ZPROBEAREA ) )) == 0 )
         return( -1 );
   }

   g_pProbeArea->bProbesEnabled = bEnable;

   return( MAX_ZPROBES );

}  // UfZProbeEnable


//./ ADD NAME=UfZProbeInit
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeInit
//
//  PURPOSE:    Initializes the array of probes
//
//  PARAMETERS: NONE
//
//  RESULTS:    Returns the number of probes available for use.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfZProbeInit( )
{
   zSHORT k;

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   g_pProbeArea->nProbes = -1;

   for ( k = 0; k < MAX_ZPROBES; k++)
   {
      g_pProbeArea->Probes[ k ].zp_Active = FALSE;
      g_pProbeArea->Probes[ k ].zp_Desc[ 0 ] = 0;
      g_pProbeArea->Probes[ k ].zp_StartTime = 0;
      g_pProbeArea->Probes[ k ].zp_TotalTime = 0;
      g_pProbeArea->Probes[ k ].zp_CountOn = 0;
      g_pProbeArea->Probes[ k ].zp_CountOff = 0;
   }

   g_pProbeArea->nErrShown1 = 0;
   g_pProbeArea->nErrShown2 = 0;
   g_pProbeArea->nErrShown3 = 0;
   g_pProbeArea->nErrShown4 = 0;
   g_pProbeArea->nErrShown5 = 0;
   g_pProbeArea->nErrShown6 = 0;

   g_pProbeArea->ProbSetInitTime = SysGetTickCount( );

   return( MAX_ZPROBES );

}  // UfZProbeInit

//./ ADD NAME=UfZProbeOn
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeOn
//
//  PURPOSE:    Start timing with the next or a specific probe.
//
//  PARAMETERS: nProbeNbr          -- Number of the probe to turn on.
//                                    If it is negative, then the next
//                                    available probe is turned on.
//              szDesc             -- Descriptor used when outputting
//                                    the results.  Max of 30 chars used.
//              bTurnPriorProbeOff -- Indicates that the prior probe to
//                                    the one being turned on is to be
//                                    turned off.  Only used when nProbeNbr
//                                    is negative.
//
//  RESULTS:    Returns the number of probes available for use.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 4
zSHORT OPERATION
UfZProbeOn( zSHORT nProbeNbr,
            zPCHAR pchDesc,
            zBOOL  bTurnPriorProbeOff )
{
   zSHORT nProbeOn;

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   nProbeOn = nProbeNbr;

   // check that input probe is not too large.
   if ( nProbeOn > ( MAX_ZPROBES - 1 ) )
      nProbeOn = -1;  // use the next available.

   // check if the request is for a new probe and get number
   if ( nProbeOn < 0)
   {
      if ( g_pProbeArea->nProbes >= MAX_ZPROBES - 1 )
      {
         if ( g_pProbeArea->nErrShown2 < MAX_ZPROBEERRS )
         {
            TraceLineS( "UfZProbeOn: No more probes available for: ", pchDesc );
            g_pProbeArea->nErrShown2++;
         }

         return( -2 );   // exit if no more probes available
      }

      if ( bTurnPriorProbeOff )
         UfZProbeOff( g_pProbeArea->nProbes, pchDesc );

      nProbeOn = ++g_pProbeArea->nProbes;  // use next available probe
      ZeidonStringCopy( g_pProbeArea->Probes[ nProbeOn ].zp_Desc, 1, 0, pchDesc, 1, 0, MAX_ZPROBEDESC );
   }
   else
   {
      if ( g_pProbeArea->Probes[ nProbeOn ].zp_Desc[ 0 ] != 0 )
      {
         // descriptor must match
         if ( zstrcmpi( g_pProbeArea->Probes[ nProbeOn ].zp_Desc, pchDesc ) != 0 )
         {
            if ( g_pProbeArea->nErrShown3 < MAX_ZPROBEERRS )
            {
               TraceLineI( "UfZProbeOn: Invalid probe descriptor for probe: ", nProbeNbr );
               TraceLineS( "UfZProbeOn: Invalid probe descriptor   (input): ", pchDesc );
               TraceLineS( "UfZProbeOn: Invalid probe descriptor (current): ", g_pProbeArea->Probes[ nProbeOn ].zp_Desc );
               g_pProbeArea->nErrShown3++;
            }

            return( -3 );
         }
      }
   }

   // now actually turn on the probe
   //
   g_pProbeArea->Probes[ nProbeOn ].zp_CountOn++;
   if ( g_pProbeArea->Probes[ nProbeOn ].zp_Active == TRUE )
   {
      // don't reset timer
   }
   else
   {
      g_pProbeArea->Probes[ nProbeOn ].zp_Active = TRUE;
      // Might want to use GetTickCount for better accuracy in tight loops.
      // But, that would have to change to be system independent ;-)
      g_pProbeArea->Probes[ nProbeOn ].zp_StartTime = SysGetTickCount( );
   }

   return( nProbeOn );

}  // UfZProbeOn

//./ ADD NAME=UfZProbeOff
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeOff
//
//  PURPOSE:    Stop timing with a specific probe and accumulate the
//              elapsed time.
//
//  PARAMETERS: nProbeNbr          -- Number of the probe to turn off.
//              pchDesc             -- Descriptor used in error messages.
//
//  OVERVIEW:
//       The probe functionality is used performance timing analysis.
//
//  RESULTS:    0.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 3
zSHORT OPERATION
UfZProbeOff( zSHORT nProbeNbr,
             zPCHAR pchDesc )
{
   zULONG ulTime;
   zULONG ulElapsed;

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   ulTime = SysGetTickCount( );

   if ( nProbeNbr < 0 || nProbeNbr > g_pProbeArea->nProbes )
   {
      if ( g_pProbeArea->nErrShown4 < MAX_ZPROBEERRS )
      {
         TraceLineI( "UfZProbeOff: Invalid probe number: ", nProbeNbr );
         TraceLineS( "UfZProbeOff:           descriptor: ", pchDesc );
         return( -5 );
         g_pProbeArea->nErrShown4++;
      }

      return( -4 );
   }

   if ( g_pProbeArea->Probes[ nProbeNbr ].zp_Active == FALSE )
   {
      if ( g_pProbeArea->nErrShown5 < MAX_ZPROBEERRS )
      {
         TraceLineI( "UfZProbeOff: Probe not on for number: ", nProbeNbr );
         TraceLineS( "UfZProbeOff:              descriptor: ", pchDesc );
         g_pProbeArea->nErrShown5++;
      }

      return( -5 );
   }
   ulElapsed = ulTime - g_pProbeArea->Probes[ nProbeNbr ].zp_StartTime;
   g_pProbeArea->Probes[ nProbeNbr ].zp_TotalTime += ulElapsed;
   g_pProbeArea->Probes[ nProbeNbr ].zp_StartTime = ulTime;
   g_pProbeArea->Probes[ nProbeNbr ].zp_Active = FALSE;
   g_pProbeArea->Probes[ nProbeNbr ].zp_CountOff++;

   return( 0 );

}  // UfZProbeOff

//./ ADD NAME=UfZProbeOnByDesc
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeOnByDesc
//
//  PURPOSE:    Start timing with the next or a specific probe.
//
//  PARAMETERS: pchDesc             -- Descriptor used to find an existing
//                                    probe or start a new probe.
//              bTurnPriorProbeOff -- Indicates that the prior probe to
//                                    the one being turned on is to be
//                                    turned off.  Only used when Descriptor
//                                    not found and a new probe is started.
//
//  RESULTS:    Returns the number of probes available for use.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 3
zSHORT OPERATION
UfZProbeOnByDesc( zPCHAR pchDesc,
                  zBOOL  bTurnPriorProbeOff )
{
   zSHORT k;

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   for ( k = 0; k <= g_pProbeArea->nProbes; k++)
   {
      if ( zstrcmpi( g_pProbeArea->Probes[ k ].zp_Desc, pchDesc ) == 0 )
      {
         return( UfZProbeOn( k, pchDesc, FALSE ) );
      }
   }

   return( UfZProbeOn( -1, pchDesc, bTurnPriorProbeOff ) );

}  // UfZProbeOnByDesc

//./ ADD NAME=UfZProbeOffByDesc
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeOff
//
//  PURPOSE:    Stop timing with a specific probe and accumulate the
//              elapsed time.
//
//  PARAMETERS: pchDesc             -- Descriptor used to find probe number.
//
//  OVERVIEW:
//       The probe functionality is used performance timing analysis.
//
//  RESULTS:    0.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfZProbeOffByDesc( zPCHAR pchDesc )
{
   zSHORT k;

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   for ( k = 0; k <= g_pProbeArea->nProbes; k++)
   {
      if ( zstrcmpi( g_pProbeArea->Probes[ k ].zp_Desc, pchDesc ) == 0 )
      {
         return( UfZProbeOff( k, pchDesc ) );
      }
   }

   if ( g_pProbeArea->nErrShown6 < MAX_ZPROBEERRS )
   {
      TraceLineS( "UfZProbeOffByDesc: Probe not on for descriptor: ", pchDesc );
      g_pProbeArea->nErrShown6++;
   }

   return( -6 );

}  // UfZProbeOffByDesc


//./ ADD NAME=UfZProbeTrace
// Source Module=kzoeufaa.c
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION:  UfZProbeTrace
//
//  PURPOSE:    Turn off all active probes and log results to Zeidon
//              trace window.
//
//  PARAMETERS: NONE
//
//  OVERVIEW:
//       The probe functionality is used performance timing analysis.
//
//  RESULTS:    Returns the number of probes available for use.
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 2
zSHORT OPERATION
UfZProbeTrace( zPCHAR pchDesc )
{
   zSHORT k;
   double fElapsedTime;
   double fElapsedTimeAll;
   zULONG ulCount;
   zCHAR  szMsg[ 201 ];

   if ( g_pProbeArea == 0 || g_pProbeArea->bProbesEnabled == FALSE )
      return( -1 );

   fElapsedTimeAll = (double) ( SysGetTickCount( ) - g_pProbeArea->ProbSetInitTime ) / zTICKS_PER_SECOND;

   for ( k = 0; k <= g_pProbeArea->nProbes; k++)
   {
      if ( g_pProbeArea->Probes[ k ].zp_Active == TRUE )
      {
         UfZProbeOff( k, g_pProbeArea->Probes[ k ].zp_Desc );
      }
   }

   // Print out all used probes. Format is:
   //   zp.nnn. 123456789012345678901234567890:nnnn.nnn secs. (avg.nnnn.nnn for nnnnnnn times)
   sprintf_s( szMsg, zsizeof( szMsg ), "======= Probe Trace - %30s ===START===", pchDesc );
   TraceLineS( szMsg, "" );
   sprintf_s( szMsg, zsizeof( szMsg ), "zp.ALL. -- elapsed for Init to Trace->:%8.3f seconds",
             fElapsedTimeAll );
   TraceLineS( szMsg, "" );
   for ( k = 0; k <= g_pProbeArea->nProbes; k++)
   {
      ulCount = g_pProbeArea->Probes[ k ].zp_CountOff;
      fElapsedTime = (double) ( g_pProbeArea->Probes[ k ].zp_TotalTime ) / zTICKS_PER_SECOND;
      if ( ulCount == g_pProbeArea->Probes[ k ].zp_CountOn )
         sprintf_s( szMsg, zsizeof( szMsg ), "zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times)",
                   k, g_pProbeArea->Probes[ k ].zp_Desc, fElapsedTime, (fElapsedTime / ulCount), ulCount );
      else
         sprintf_s( szMsg, zsizeof( szMsg ), "zp.%03d. %30s:%8.3f secs. (avg.%8.3f for %8d times OFF, but ON is %d times)",
                   k, g_pProbeArea->Probes[ k ].zp_Desc, fElapsedTime, (fElapsedTime / ulCount), ulCount, g_pProbeArea->Probes[ k ].zp_CountOn );

      TraceLineS( szMsg, "" );
   }

   sprintf_s( szMsg, zsizeof( szMsg ), "======= Probe Trace - %30s === END ===", pchDesc );
   TraceLineS( szMsg, "" );

   return( 0 );

}  // UfZProbeTrace
