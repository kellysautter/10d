/////////////////////////////////////////////////////////////////////////////
// Project ZDrApp
//
// This is a part of the Zeidon Dynamic Rendering of GUI applications package.
// Copyright © 1995 - 2016 QuinSoft, Inc.
// All Rights Reserved.
//
// SUBSYSTEM:    zdrapp.dll - ZDr Application
// FILE:         zdrvstr.cpp
// AUTHOR:
//
// OVERVIEW
// ========
// Source file for implementation of Zeidon String manipulation routines
// used by code generated by VML.

//
// CHANGE LOG - most recent first order
//
// 200y.mm.dd    xxx
//    Note ...
//
// 1998.08.13    DKS
//    Prettier.
//

#include "zstdafx.h"

#define ZDRAPP_CLASS AFX_EXT_CLASS
#include "ZDr.h"
#include "zdrgbl.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: SetFlagBit
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    SetFlagBit is used to set a particular bit in a flag variable.
//              A flag variable is defined to be a 32-bit integer.
//              If nFlagPosition is zero,
//
//  PARAMETERS: lFlag    - the flag which is to be modified
//              nFlagPosition - the position in the flag at which to
//                         set the bit (range from 1 to 32 ... zero is
//                         used to set all bits in the flag)
//              bSetOn   - specifies whether to set the bit on (1) or off (0)
//
//  RETURNS:    the updated flag
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zLONG OPERATION
SetFlagBit( zLONG  lFlag,
            zSHORT nFlagPosition,
            zSHORT bSetOn )
{
   if ( nFlagPosition == 0 )  // turn 'em all on or off
   {
      if ( bSetOn )
         return( -1 );
      else
         return( 0 );
   }
   else
   if ( nFlagPosition > 32 )
   {
      return( lFlag );     // return the original value (invalid index)
   }
   else
   {
      nFlagPosition--;
      if ( bSetOn )
         lFlag |= 0x00000001 << nFlagPosition;
      else
         lFlag &= ~(0x00000001 << nFlagPosition);
   }

   return( lFlag );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: GetFlagBit
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    GetFlagBit is used to determine if a particular bit is set
//              in a flag variable.  A flag variable is defined to be a
//              32-bit integer.
//
//  PARAMETERS: lFlag    - the flag which is to be queried
//              nFlagPosition - the position in the flag at which query
//                         the bit (range from 1 to 32)
//
//  RETURNS:    1 - the flag bit is set
//              0 - the flag bit is NOT set
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
GetFlagBit( zLONG  lFlag,
            zSHORT nFlagPosition )
{
   if ( nFlagPosition > 0 && nFlagPosition <= 32 )
   {
      nFlagPosition--;
      return( lFlag & (0x00000001 << nFlagPosition) );
   }

   return( 0 );   // in invalid index ... the flag cannot be set
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: SetFlagSequence
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    SetFlagSequence is used to set a particular bit sequence
//              in a flag variable.  A flag variable is defined to be a
//              32-bit integer.
//
//  PARAMETERS: lFlag     - the flag which is to be queried
//              lSequenceFlag - the bit sequence to apply to the flag
//              bSetOn   - specifies whether to set the bit on (1) or off (0)
//
//  RETURNS:    the updated flag
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zLONG OPERATION
SetFlagSequence( zLONG  lFlag,
                 zLONG  lSequenceFlag,
                 zSHORT bSetOn )
{
   if ( bSetOn )
      return( lFlag | lSequenceFlag );
   else
      return( lFlag & ~lSequenceFlag );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: IsFlagSequenceSet
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    IsFlagSequenceSet is used to determine if a particular bit
//              sequence is set in a flag variable.  A flag variable is
//              defined to be a 32-bit integer.
//
//  PARAMETERS: lFlag     - the flag which is to be queried
//              lTestFlag - the bit sequence for which to test in the flag
//
//  RETURNS:    1 - the flag sequence is set
//              0 - the flag sequence is NOT set
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
IsFlagSequenceSet( zLONG  lFlag,
                   zLONG  lTestFlag )
{
   if ( (lFlag & lTestFlag) == lTestFlag )
   {
      return( 1 );
   }

   return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: AreBitsSetInFlag
//                                            2008.04.04 Modified: 2008.04.04
//
//  PURPOSE:    AreBitsSetInFlag is used to determine if any test bits
//              are set in a flag variable.  A flag variable is
//              defined to be a 32-bit integer.
//
//  PARAMETERS: lFlag     - the flag which is to be queried
//              lTestFlag - the bit sequence for which to test in the flag
//
//  RETURNS:    1 - the flag sequence is set
//              0 - the flag sequence is NOT set
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
AreBitsSetInFlag( zLONG  lFlag,
                  zLONG  lTestFlag )
{
   if ( (lFlag & lTestFlag) != 0 )
   {
      return( 1 );
   }

   return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ActivateWindowPlacement
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    ActivateWindowPlacement is used to cause automatic
//              save/restore processing for a specific window in a dialog
//
//  REQUIREMENTS:  The profile object must contain at least the following
//              entities and attributes:
//
//              Dialog entity
//                - Tag    (32 character text)
//
//              Window entitiy
//                - Tag    (32 character text)
//                - PosX   (integer)
//                - PosY   (integer)
//                - SizeX  (integer)
//                - SizeY  (integer)
//                - MXN    (integer ... Min/Max/Normal)
//                - Flag   (integer)
//                - Place  (blob)
//
//  PARAMETERS: vSubtask  - view to the dialog window for which to
//                          save placement
//              cpcProfileViewName - name of the view to the profile
//                          object in which to save placement
//
//  RETURNS:    -1 - the window could not be found for profiling
//               0 - the window was set for automatic profiling
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
ActivateWindowPlacement( zVIEW vSubtask,
                         zCPCHAR cpcProfileViewName )
{
   ZSubtask *pZSubtask;

   if ( GetWindowAndCtrl( &pZSubtask, 0, vSubtask, 0 ) == 0 )
   {
      pZSubtask->m_pzsProfileViewName = new CString( cpcProfileViewName );
      return( 0 );
   }

   return( -1 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: SaveWindowPlacement
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    SaveWindowPlacement is used to save the placement of a
//              specific window in a dialog.
//
//  REQUIREMENTS:  The profile object must contain at least the following
//              entities and attributes:
//
//              Dialog entity
//                - Tag    (32 character text)
//
//              Window entity
//                - Tag    (32 character text)
//                - PosX   (integer)
//                - PosY   (integer)
//                - SizeX  (integer)
//                - SizeY  (integer)
//                - MXN    (integer ... Min/Max/Normal)
//                - Flag   (integer)
//                - Place  (blob)
//
//  PARAMETERS: vSubtask  - view to the dialog window for which to
//                          save placement
//              vProfile  - view to the profile object in which to save
//                          placement
//              lFlags    - extra flags to be saved in the profile object
//
//  RETURNS:    -1 - the window could not be found for saving the profile
//               0 - the profile was sucessfully saved
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
SaveWindowPlacement( zVIEW vSubtask,
                     zVIEW vProfile,
                     zLONG lFlags )
{
   ZSubtask *pZSubtask;

   if ( GetWindowAndCtrl( &pZSubtask, 0, vSubtask, 0 ) == 0 )
   {
      if ( pZSubtask->m_pZFWnd &&
           pZSubtask->m_pzsDlgTag && pZSubtask->m_pzsWndTag )
      {
         if ( SetCursorFirstEntityByString( vProfile, "Dialog", szlTag,
                                            *(pZSubtask->m_pzsDlgTag),
                                            0 ) > zCURSOR_UNCHANGED )
         {
            if ( SetCursorFirstEntityByString( vProfile, "Window", szlTag,
                                               *(pZSubtask->m_pzsWndTag),
                                               0 ) > zCURSOR_UNCHANGED )
            {
            }
            else
            {
               CreateEntity( vProfile, "Window", zPOS_FIRST );
            }
         }
         else
         {
            CreateEntity( vProfile, "Dialog", zPOS_FIRST );
            CreateEntity( vProfile, "Window", zPOS_FIRST );
         }

         SetAttributeFromVariable( vProfile, "Dialog", szlTag,
                                   *(pZSubtask->m_pzsDlgTag),
                                   zTYPE_STRING, 0, 0, 0 );
         SetAttributeFromVariable( vProfile, "Window", szlTag,
                                   *(pZSubtask->m_pzsWndTag),
                                   zTYPE_STRING, 0, 0, 0 );
         SetAttributeFromVariable( vProfile, "Window", "Flags",
                                   &lFlags, zTYPE_INTEGER, 0, 0, 0 );

         WINDOWPLACEMENT wp;

         wp.length = sizeof( WINDOWPLACEMENT );
         pZSubtask->m_pZFWnd->GetWindowPlacement( &wp );
         if ( wp.showCmd & SW_SHOWMINIMIZED )
         {
            wp.showCmd &= ~SW_SHOWMINIMIZED;
            wp.showCmd |= SW_SHOWNORMAL;
         }

         SetAttributeFromBlob( vProfile, "Window", "Place", &wp,
                               sizeof( WINDOWPLACEMENT ) );
      // TraceLineI( "SaveWindowPlacement ", wp.length );
      // TraceRect( "SavePlacement Rect:", wp.rcNormalPosition );

         return( 0 );
      }
   }

   return( -1 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: SaveWindowProfile
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    SaveWindowProfile is used to save the profile of a
//              specific window in a dialog.
//
//  REQUIREMENTS:  The profile object must contain at least the following
//              entities and attributes:
//
//              Dialog entity
//                - Tag    (32 character text)
//
//              Window entity
//                - Tag    (32 character text)
//                - PosX   (integer)
//                - PosY   (integer)
//                - SizeX  (integer)
//                - SizeY  (integer)
//                - MXN    (integer ... Min/Max/Normal)
//                - Flag   (integer)
//                - Place  (blob)
//
//  PARAMETERS: cpcDialogName - name of dialog for which to save profile
//              cpcWindowName - name of window for which to save profile
//              vProfile  - view to the profile object in which to save
//                          profile
//              lPosX     - x position
//              lPosY     - y position
//              lSizeX    - width
//              lSizeY    - height
//              lMXN      - Min/Max/Normal window restore value
//                            -1 - Min
//                             0 - Normal
//                             1 - Max
//              lFlags    - extra flags to be saved in the profile object
//
//  RETURNS:    0 - the profile was sucessfully saved
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zSHORT OPERATION
SaveWindowProfile( zCPCHAR cpcDialogName,
                   zCPCHAR cpcWindowName,
                   zVIEW vProfile,
                   zLONG lPosX,
                   zLONG lPosY,
                   zLONG lSizeX,
                   zLONG lSizeY,
                   zLONG lMXN,
                   zLONG lFlags )
{
   if ( SetCursorFirstEntityByString( vProfile, "Dialog", szlTag,
                                      cpcDialogName,
                                      0 ) > zCURSOR_UNCHANGED )
   {
      if ( SetCursorFirstEntityByString( vProfile, "Window", szlTag,
                                         cpcWindowName,
                                         0 ) > zCURSOR_UNCHANGED )
      {
      }
      else
      {
         CreateEntity( vProfile, "Window", zPOS_FIRST );
      }
   }
   else
   {
      CreateEntity( vProfile, "Dialog", zPOS_FIRST );
      CreateEntity( vProfile, "Window", zPOS_FIRST );
   }

   SetAttributeFromVariable( vProfile, "Dialog", szlTag,
                             cpcDialogName,
                             zTYPE_STRING, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", szlTag,
                             cpcWindowName,
                             zTYPE_STRING, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "Flags",
                             &lFlags, zTYPE_INTEGER, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "PosX",
                             &lPosX, zTYPE_INTEGER, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "PosY",
                             &lPosY, zTYPE_INTEGER, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "SizeX",
                             &lSizeX, zTYPE_INTEGER, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "SizeY",
                             &lSizeY, zTYPE_INTEGER, 0, 0, 0 );
   SetAttributeFromVariable( vProfile, "Window", "MXN",
                             &lMXN, zTYPE_INTEGER, 0, 0, 0 );

   // null out the blob
   SetAttributeFromBlob( vProfile, "Window", "Place", &lFlags, 0 );

   return( 0 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  LOCALOPER: CheckWindowPos
//                                              12/12/97 Modified: 12/12/97
//
//  PURPOSE:    Check, if window position is within physical screen
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zBOOL OPERATION
CheckWindowPos( LPWINDOWPLACEMENT pwp )
{
   zUSHORT uSquareX = ::GetSystemMetrics( SM_CXICON );
   zUSHORT uSquareY = ::GetSystemMetrics( SM_CYICON );
   zUSHORT uSizeX = ::GetSystemMetrics( SM_CXSCREEN ) - uSquareX;
   zUSHORT uSizeY = ::GetSystemMetrics( SM_CYSCREEN ) - uSquareY;

   // If the restored position is not visible, let default positioning occur.
// TraceRect( "CheckWindowPos Rect:", wp->rcNormalPosition );
// TraceLineI( "uSizeX: ", uSizeX );
// TraceLineI( "uSizeY: ", uSizeY );
   if ( pwp->rcNormalPosition.top > uSizeY ||
        pwp->rcNormalPosition.left > uSizeX ||
        pwp->rcNormalPosition.bottom <= uSquareY ||
        pwp->rcNormalPosition.right <= uSquareX )
   {
      return( FALSE );
   }

   return( TRUE );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: RestoreWindowPlacement
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    RestoreWindowPlacement is used to restore the placement of
//              a specific window in a dialog.
//
//  REQUIREMENTS:  The profile object must contain at least the following
//              entities and attributes:
//
//              Dialog entity
//                - Tag    (32 character text)
//
//              Window entitiy
//                - Tag    (32 character text)
//                - PosX   (integer)
//                - PosY   (integer)
//                - SizeX  (integer)
//                - SizeY  (integer)
//                - MXN    (integer ... Min/Max/Normal)
//                - Flag   (integer)
//                - Place  (blob)
//
//  PARAMETERS: vSubtask  - view to the dialog window for which to
//                          save placement
//              vProfile  - view to the profile object in which to save
//                          placement
//
//  RETURNS:    -1 - error restoring from profile object
//              extra flags saved in the profile object
//
//
// typedef struct tagWINDOWPLACEMENT
// {
//    UINT  length;
//    UINT  flags;
//    UINT  showCmd;
//    POINT ptMinPosition;
//    POINT ptMaxPosition;
//    RECT  rcNormalPosition;
// } WINDOWPLACEMENT;
//
// The WINDOWPLACEMENT structure contains information about the placement
// of a window on the screen.
//
// Member   Description
// ======   =================================================================
// length   Specifies the length, in bytes, of the structure.
// flags    Specifies flags that control the position of the minimized window
//          and the method by which the window is restored.  This member can
//          be one or both of the following flags:
//
//          Value  Meaning
//          =====  ==========================================================
//          WPF_SETMINPOSITION - Specifies that the x- and y-positions of the
//                 minimized window may be specified.  This flag must be
//                 specified if the coordinates are set in the ptMinPosition
//                 member.
//          WPF_RESTORETOMAXIMIZED - Specifies that the restored window will
//                 be maximized, regardless of whether it was maximized
//                 before it was minimized.  This setting is valid only the
//                 next time the window is restored. It does not change the
//                 default restoration behavior.  This flag is valid only
//                 when the SW_SHOWMINIMIZED value is specified for the
//                 showCmd member.
//
// showCmd  Specifies the current show state of the window.  This member may
//          be one of the following values:
//
//          Value  Meaning
//          =====  ==========================================================
//          SW_HIDE - Hides the window and passes activation to another window.
//          SW_MINIMIZE - Minimizes the specified window and activates the
//                 top-level window in the system's list.
//          SW_RESTORE - Activates and displays a window. If the window is
//                 minimized or maximized, Windows restores it to its
//                 original size and position (same as SW_SHOWNORMAL).
//          SW_SHOW - Activates a window and displays it in its current size
//                 and position.
//          SW_SHOWMAXIMIZED - Activates a window and displays it as a
//                 maximized window.
//          SW_SHOWMINIMIZED - Activates a window and displays it as an icon.
//          SW_SHOWMINNOACTIVE - Displays a window as an icon. The window that
//                 is currently active remains active.
//          SW_SHOWNA - Displays a window in its current state. The window
//                 that is currently active remains active.
//          SW_SHOWNOACTIVATE - Displays a window in its most recent size and
//                 position.  The window that is currently active remains
//                 active.
//          SW_SHOWNORMAL - Activates and displays a window. If the window is
//                 minimized or maximized, Windows restores it to its original
//                 size and position (same as SW_RESTORE).
//
// ptMinPosition - Specifies the position of the window's top-left corner
//          when the window is minimized.
// ptMaxPosition - Specifies the position of the window's top-left corner
//          when the window is maximized.
// rcNormalPosition - Specifies the window's coordinates when the window is
//          in the normal (restored) position.
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zLONG OPERATION
RestoreWindowPlacement( zVIEW vSubtask,
                        zVIEW vProfile )
{
   ZSubtask *pZSubtask;

   if ( GetWindowAndCtrl( &pZSubtask, 0, vSubtask, 0 ) == 0 )
   {
      if ( pZSubtask->m_pZFWnd &&
           pZSubtask->m_pzsDlgTag && pZSubtask->m_pzsWndTag )
      {
         mDeleteInitA( pZSubtask->m_pchWindowPlacement );

         if ( SetCursorFirstEntityByString( vProfile, "Dialog", szlTag,
                                            *(pZSubtask->m_pzsDlgTag),
                                            0 ) > zCURSOR_UNCHANGED &&
              SetCursorFirstEntityByString( vProfile, "Window", szlTag,
                                            *(pZSubtask->m_pzsWndTag),
                                            0 ) > zCURSOR_UNCHANGED )
         {
            WINDOWPLACEMENT *wp;
            zLONG  lFlags = 0;
            zULONG ulLth;

            GetIntegerFromAttribute( &lFlags, vProfile, "Window", "Flags" );
            GetAttributeLength( &ulLth, vProfile, "Window", "Place" );
            if ( ulLth == sizeof( WINDOWPLACEMENT ) )
            {
               pZSubtask->m_pchWindowPlacement =
                                         new char[ sizeof( WINDOWPLACEMENT )];
               GetBlobFromAttribute( pZSubtask->m_pchWindowPlacement,
                                     &ulLth, vProfile, "Window", "Place" );
               wp = (WINDOWPLACEMENT *) pZSubtask->m_pchWindowPlacement;
            // TraceLineI( "RestoreWindowPlacement ", wp->length );
            // TraceRect( "RestorePlacement Rect:", wp->rcNormalPosition );
            }
            else
            {
               zLONG lPosX;
               zLONG lPosY;
               zLONG lSizeX;
               zLONG lSizeY;
               zLONG lMXN;    // (integer ... Min/Max/Normal)

               GetIntegerFromAttribute( &lPosX, vProfile, "Window", "PosX" );
               GetIntegerFromAttribute( &lPosY, vProfile, "Window", "PosY" );
               GetIntegerFromAttribute( &lSizeX, vProfile, "Window", "SizeX" );
               GetIntegerFromAttribute( &lSizeY, vProfile, "Window", "SizeY" );
               GetIntegerFromAttribute( &lMXN, vProfile, "Window", "MXN" );

               if ( lPosX || lPosY || lSizeX || lSizeY || lMXN )
               {
                  pZSubtask->m_pchWindowPlacement =
                                         new char[ sizeof( WINDOWPLACEMENT )];
                  wp = (WINDOWPLACEMENT *) pZSubtask->m_pchWindowPlacement;
                  zmemset( wp, 0, sizeof( WINDOWPLACEMENT ) );
                  wp->length = sizeof( WINDOWPLACEMENT );
                  if ( lMXN == -1 )
                     wp->showCmd = SW_SHOWMINIMIZED;
                  else
                  if ( lMXN == 1 )
                     wp->showCmd = SW_SHOWMAXIMIZED;
                  else
                     wp->showCmd = SW_SHOWNORMAL;

                  wp->rcNormalPosition.top = lPosY;
                  wp->rcNormalPosition.left = lPosX;
                  wp->rcNormalPosition.bottom = lPosY + lSizeY;
                  wp->rcNormalPosition.right = lPosX + lSizeX;
               }
               else
                  lFlags = -1;
            }

            if ( lFlags != -1 )
            {
               // if the restored position is not visible, let default
               // (design) positioning occur
               if ( CheckWindowPos( wp ) == FALSE )
               {
                  mDeleteInitA( pZSubtask->m_pchWindowPlacement );
                  lFlags = -1;
               }

               return( lFlags );
            }
         }
      }
   }

   return( -1 );
}

/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: RestoreWindowProfile
//                                              11/01/96 Modified: 11/01/96
//
//  PURPOSE:    RestoreWindowProfile is used to save the profile of a
//              specific window in a dialog.
//
//  REQUIREMENTS:  The profile object must contain at least the following
//              entities and attributes:
//
//              Dialog entity
//                - Tag    (32 character text)
//
//              Window entitiy
//                - Tag    (32 character text)
//                - PosX   (integer)
//                - PosY   (integer)
//                - SizeX  (integer)
//                - SizeY  (integer)
//                - MXN    (integer ... Min/Max/Normal)
//                - Flag   (integer)
//                - Place  (blob)
//
//  PARAMETERS: cpcDialogName - name of dialog for which to restore profile
//              cpcWindowName - name of window for which to restore profile
//              vProfile  - view to the profile object in which to save
//                          profile
//
//  RETURNS:    -1 - error restoring from profile object
//              extra flags saved in the profile object
//
/////////////////////////////////////////////////////////////////////////////
zOPER_EXPORT zLONG OPERATION
RestoreWindowProfile( zCPCHAR cpcDialogName,
                      zCPCHAR cpcWindowName,
                      zVIEW vProfile,
                      HWND  hWnd )
{
   if ( SetCursorFirstEntityByString( vProfile, "Dialog", szlTag,
                                      cpcDialogName,
                                      0 ) > zCURSOR_UNCHANGED &&
        SetCursorFirstEntityByString( vProfile, "Window", szlTag,
                                      cpcWindowName,
                                      0 ) > zCURSOR_UNCHANGED )
   {
      WINDOWPLACEMENT wp;
      zULONG  ulLth;
      zLONG   lFlags;

      GetIntegerFromAttribute( &lFlags, vProfile, "Window", "Flags" );
      GetAttributeLength( &ulLth, vProfile, "Window", "Place" );
      if ( ulLth == sizeof( WINDOWPLACEMENT ) )
      {
         ulLth = sizeof( WINDOWPLACEMENT );
         GetBlobFromAttribute( &wp, &ulLth, vProfile, "Window", "Place" );

         // if the restored position is not visible, let default (design)
         // positioning occur
         if ( CheckWindowPos( &wp ) == FALSE )
         {
            return( -1 );
         }

         CWnd *pWnd = CWnd::FromHandle( hWnd );
         pWnd->SetWindowPlacement( &wp );
         return( lFlags );
      }
      else
      {
         zLONG lPosX;
         zLONG lPosY;
         zLONG lSizeX;
         zLONG lSizeY;
         zLONG lMXN;    // (integer ... Min/Max/Normal)

         GetIntegerFromAttribute( &lPosX, vProfile, "Window", "PosX" );
         GetIntegerFromAttribute( &lPosY, vProfile, "Window", "PosY" );
         GetIntegerFromAttribute( &lSizeX, vProfile, "Window", "SizeX" );
         GetIntegerFromAttribute( &lSizeY, vProfile, "Window", "SizeY" );
         GetIntegerFromAttribute( &lMXN, vProfile, "Window", "MXN" );

         if ( lPosX || lPosY || lSizeX || lSizeY || lMXN )
         {
            int nCmdShow;
            CWnd *pTWnd = CWnd::FromHandle( hWnd );

            if ( lMXN == -1 )
               nCmdShow = SW_SHOWMINIMIZED;
            else
            if ( lMXN == 1 )
               nCmdShow = SW_SHOWMAXIMIZED;
            else
               nCmdShow = SW_SHOWNORMAL;

            // if the restored position is not visible, let default (design)
            // positioning occur
            wp.rcNormalPosition.top = lPosY;
            wp.rcNormalPosition.left = lPosX;
            wp.rcNormalPosition.bottom = lPosY + lSizeY;
            wp.rcNormalPosition.right = lPosX + lSizeX;
            if ( CheckWindowPos( &wp ) == FALSE )
            {
               pTWnd->ShowWindow( nCmdShow );
               return( -1 );
            }

            pTWnd->SetWindowPos( 0, lPosX, lPosY,
                                 lSizeX, lSizeY, SWP_NOZORDER );
            pTWnd->ShowWindow( nCmdShow );
            return( lFlags );
         }
      }
   }

   return( -1 );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/*****************************************************************************
Module :     URLEncode.cpp
Notices:     Written 2002 by ChandraSekar Vuppalapati
Description: CPP URL Encoder
*****************************************************************************/
class ZURLEncode
{
private:
   static CString csUnsafeString;
   CString DecToHex( zCHAR ch, int nRadix );
   zBOOL IsUnsafe( zCHAR chCompare );
   CString Convert( zCHAR chVal );

public:
   ZURLEncode( ) { };
   virtual ~ZURLEncode( ) { };
   CString URLEncode( CString vData );
};

// HEX Values array
char hexVals[ 16 ] = { '0', '1', '2', '3', '4', '5', '6', '7',
                       '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };

// Unsafe characters String
CString ZURLEncode::csUnsafeString= "\"<>%\\^[]`+$,@:;/!#?=&";

// Convert a given zCHAR to URL hex form.
CString ZURLEncode::Convert( zCHAR chVal )
{
   CString csRet;
   csRet += "%";
   csRet += DecToHex( chVal, 16 );
   return( csRet );
}

#include <math.h>

// A helper function to generate a hex representation of given character.
CString ZURLEncode::DecToHex( zCHAR ch, int nRadix )
{
   int     nTmp = 0;
   CString csTmp;
   int     nNumericCharValue = (int) ch;

   // ISO-8859-1
   // If the if loop is commented, the code will fail to generate a proper
   // URL encode for the characters whose range is in 127-255 (decimal).
   if ( nNumericCharValue < 0 )
      nNumericCharValue = 256 + nNumericCharValue;

   while ( nNumericCharValue >= nRadix )
   {
      nTmp = nNumericCharValue % nRadix;
      nNumericCharValue = (int) floor( (double) nNumericCharValue / nRadix );
      csTmp = hexVals[ nTmp ];
   }

   csTmp += hexVals[ nNumericCharValue ];

   if ( csTmp.GetLength( ) < 2 )
   {
      csTmp += '0';
   }

   CString csDecToHex( csTmp );

   // Reverse the String
   csDecToHex.MakeReverse( );

   return( csDecToHex );
}

// Check to see if a zCHAR is URL unsafe ... TRUE = unsafe, FALSE = safe
zBOOL
ZURLEncode::IsUnsafe( zCHAR chCompare )
{
   zBOOL bUnsafeCharFound = FALSE;
   zCHAR  chSafe;
   int   nLth = 0;

   nLth = csUnsafeString.GetLength( );
   for ( int nPos = 0; nPos < nLth ;nPos++ )
   {
      chSafe = csUnsafeString.GetAt( nPos );
      if ( chSafe == chCompare )
      {
         bUnsafeCharFound = TRUE;
         break;
      }
   }

   int char_ascii_value = 0;
   // char_ascii_value = __toascii( chCompare );
   char_ascii_value = (int) chCompare;

   if ( bUnsafeCharFound == FALSE &&
        char_ascii_value > 32 && char_ascii_value < 123 )
   {
      return( FALSE );  // found no unsafe chars, return FALSE
   }
   else
   {
      return( TRUE );
   }

   return( TRUE );
}

// Convert a string to URL encode form.
CString
ZURLEncode::URLEncode( CString pcsEncode )
{
   int     nPos;
   CString csEncode;
   CString csEncoded;
   int     nLth;
// int     nAsciiValue;

   csEncode = pcsEncode;
   nLth = csEncode.GetLength( );

   for ( nPos = 0; nPos < nLth; nPos++ )
   {
      zCHAR ch = csEncode.GetAt( nPos );
      if ( ch < ' ' )
      {
         ch = ch;  // yep, that's what it says ... don't know why
      }

      if ( !IsUnsafe( ch ) )
      {
         // Safe Character
         csEncoded += CString( ch );
      }
      else
      {
         // get Hex Value of the Character
         csEncoded += Convert( ch );
      }
   }

   return( csEncoded );
}

#if 0
Nr Zeichen HTML-Encoding
zTAG_LTH ! !
34 " &quot;
35 # #
36 $ $
37 % %
38 & &amp;
39 ' '
40 ( (
41 ) )
42 * *
43 + +
44 , ,
45 - -
46 . .
47 / /
48 0 0
49 1 1
50 2 2
51 3 3
52 4 4
53 5 5
54 6 6
55 7 7
56 8 8
57 9 9
58 : :
59 ; ;
60 < &lt;
61 = =
62 > &gt;
63 ? ?
64 @ @
65 A A
66 B B
67 C C
68 D D
69 E E
70 F F
71 G G
72 H H
73 I I
74 J J
75 K K
76 L L
77 M M
78 N N
79 O O
80 P P
81 Q Q
82 R R
83 S S
84 T T
85 U U
86 V V
87 W W
88 X X
89 Y Y
90 Z Z
91 [ [
92 \ \
93 ] ]
94 ^ ^
95 _ _
96 ` `
97 a a
98 b b
99 c c
100 d d
101 e e
102 f f
103 g g
104 h h
105 i i
106 j j
107 k k
108 l l
109 m m
110 n n
111 o o
112 p p
113 q q
114 r r
115 s s
116 t t
117 u u
118 v v
119 w w
120 x x
121 y y
122 z z
123 { {
124 | |
125 } }
126 ~ ~
127  
128 Ç &#8364;
129 ü ü
130 é &#8218;
131 â &#402;
132 ä &#8222;
1zTAG_LTH à &#8230;
134 å &#8224;
135 ç &#8225;
136 ê &#710;
137 ë &#8240;
138 è &#352;
139 ï &#8249;
140 î &#zTAG_LTH8;
141 ì ì
142 Ä &#381;
143 Å Å
144 É É
145 æ &#8216;
146 Æ &#8217;
147 ô &#8220;
148 ö &#8221;
149 ò &#8226;
150 û &#8211;
151 ù &#8212;
152 ÿ &#732;
153 Ö &#8482;
154 Ü &#353;
155 ¢ &#8250;
156 £ &#zTAG_LTH9;
157 ¥ ¥
158 P &#382;
159 ƒ &#376;
160   &#160;
161 í &#161;
162 ó &#162;
163 ú &#163;
164 ñ &#164;
165 Ñ &#165;
166 ª &#166;
167 º &#167;
168 ¿ &#168;
169 ¬ &#169;
170  &#170;
171 ½ &#171;
172 ¼ &#172;
173 ¡ &#173;
174 " &#174;
175 " &#175;
176 ¦ &#176;
177 ¦ &#177;
178 ¦ &#178;
179 ¦ &#179;
180 ¦ &#180;
181 ¦ &#181;
182 ¦ &#182;
183 + &#183;
184 + &#184;
185 ¦ &#185;
186 ¦ &#186;
187 + &#187;
188 + &#188;
189 + &#189;
190 + &#190;
191 + &#191;
192 + &#192;
193 - &#193;
194 - &#194;
195 + &#195;
196 - &#196;
197 + &#197;
198 ¦ &#198;
199 ¦ &#199;
200 + &#200;
201 + &#201;
202 - &#202;
203 - &#203;
204 ¦ &#204;
205 - &#205;
206 + &#206;
207 - &#207;
208 - &#208;
209 - &#209;
210 - &#210;
211 + &#211;
212 + &#212;
213 + &#213;
214 + &#214;
215 + &#215;
216 + &#216;
217 + &#217;
218 + &#218;
219 ¦ &#219;
220 _ &#220;
221 ¦ &#221;
222 ¦ &#222;
223 ¯ &#223;
224 a &#224;
225 ß &#225;
226 G &#226;
227 p &#227;
228 S &#228;
229 s &#229;
230 µ &#230;
231 t &#231;
232 F &#232;
2zTAG_LTH T &#2zTAG_LTH;
234 O &#234;
235 d &#235;
236 8 &#236;
237 f &#237;
238 e &#238;
239 n &#239;
240 = &#240;
241 ± &#241;
242 = &#242;
243 = &#243;
244 ( &#244;
245 ) &#245;
246 ÷ &#246;
247 ˜ &#247;
248 ° &#248;
249 · &#249;
250 · &#250;
251 v &#251;
252 n &#252;
253 ² &#253;
254 ¦ &#254;
255   &#255;



character space      &#32; &sp; or &blank;
exclamation mark  !  &#zTAG_LTH; &excl;
quotation mark "  &#34; &quot;
octothorpe (a.k.a Number sign or pound symbol)  #  &#35; &num;
dollar symbol  $  &#36; &dollar;
percentage  %  &#37; &percnt;
ampersand   &  &#38; &amp;
apostrophe  '  &#39; &apos;
left parenthesis  (  &#40; &lpar;
right parenthesis )  &#41; &rpar;
asterisk star symbol *  &#42; &ast;
plus symbol +  &#43; &plus;
comma ,  &#44; &comma;
hyphen, minus symbol or dash  -  &#45; &hyphen; or &minus; or &dash;
period   .  &#46; &period;
solidus back-slash   /  &#47; &sol;
number 0 0  &#48;
number 1 1  &#49;
number 2 2  &#50;
number 3 3  &#51;
number 4 4  &#52;
number 5 5  &#53;
number 6 6  &#54;
number 7 7  &#55;
number 8 8  &#56;
number 9 9  &#57;
colon :  &#58; &colon;
semi-colon  ;  &#59; &semi;
less-than sign <  &#60; &lt;
equals symbol  =  &#61; &equals;
greater-than sign >  &#62; &gt;
question mark  ?  &#63; &quest;
commercial "at" symbol  @  &#64; &commat;
uppercase A A  &#65;
uppercase B B  &#66;
uppercase C C  &#67;
uppercase D D  &#68;
uppercase E E  &#69;
uppercase F F  &#70;
uppercase G G  &#71;
uppercase H H  &#72;
uppercase I I  &#73;
uppercase J J  &#74;
uppercase K K  &#75;
uppercase L L  &#76;
uppercase M M  &#77;
uppercase N N  &#78;
uppercase O O  &#79;
uppercase P P  &#80;
uppercase Q Q  &#81;
uppercase R R  &#82;
uppercase S S  &#83;
uppercase T T  &#84;
uppercase U U  &#85;
uppercase V V  &#86;
uppercase W W  &#87;
uppercase X X  &#88;
uppercase Y Y  &#89;
uppercase Z Z  &#90;
left square bracket  [  &#91; &sqb;
reverse solidus back slash \  &#92; &bsol;
right square bracket ]  &#93; &rsqb;
caret or circumflex accent ^  &#94; &circ; or &caret;
underscore  _  &#95; &lowbar;
grave accent   `  &#96;
lowercase a a  &#97;
lowercase b b  &#98;
lowercase c c  &#99;
lowercase d d  &#100;
lowercase e e  &#101;
lowercase f f  &#102;
lowercase g g  &#103;
lowercase h h  &#104;
lowercase i i  &#105;
lowercase j j  &#106;
lowercase k k  &#107;
lowercase l l  &#108;
lowercase m m  &#109;
lowercase n n  &#110;
lowercase o o  &#111;
lowercase p p  &#112;
lowercase q q  &#113;
lowercase r r  &#114;
lowercase s s  &#115;
lowercase t t  &#116;
lowercase u u  &#117;
lowercase v v  &#118;
lowercase w w  &#119;
lowercase x x  &#120;
lowercase y y  &#121;
lowercase z z  &#122;
left curly brace  {  &#123;   &lcub;
pipe or vertical bar |  &#124;   &verbar;
right curly brace }  &#125;   &rcub;
tilde ~  &#126;   &tilde;
non-breaking space      &#160;   &nbsp;
inverted exclamation point ¡  &#161;   &iexcl;
cent sign   ¢  &#162;   &cent;
pound sterling £  &#163;   &pound;
general currency  ¤  &#164;   &curren;
yen sign ¥  &#165;   &yen;
broken vertical bar  ¦  &#166;   &brvbar; or &brkbar;
section sign   §  &#167 &sect;
dieresis or umlat ¨  &#168;   &uml; or &die;
copyright symbol  ©  &#169;   &copy;
feminine ordinal  ª  &#170;   &ordf;
left guillemot "  &#171;   &laquo;
not sign &#172;   &not;
soft hyphen &#173;   &shy;
registered trademark ®  &#174;   &reg;
macron   ¯  &#175;   &macr; or &hibar;
degree sign °  &#176;   &deg;
plus or minus  ±  &#177;   &plusmn;
superscript 2  ²  &#178;   &sup2;
superscript 3  ³  &#179;   &sup3;
acute accent   ´  &#180;   &acute;
mu µ  &#181;   &micro;
pilcrow (Paragraph symbol) &#182;   &para;
middle dot  ·  &#183;   &middot;
cedilla  ¸  &#184;   &cedil;
superscript 1  ¹  &#185;   &sup1;
masculine ordinal º  &#186;   &ordm;
right guillemot   "  &#187;   &raquo;
fraction one-fourth  ¼  &#188;   &frac14;
fraction one-half ½  &#189;   &frac12; or &half;
fraction three-fourths  ¾  &#190;   &frac34;
inverted question mark  ¿  &#191;   &iquest;
uppercase A, grave accent  À  &#192;   &Agrave;
uppercase A, acute accent  Á  &#193;   &Aacute;
uppercase A, circumflex accent   Â  &#194;   &Acirc;
uppercase A, tilde   Ã  &#195;   &Atilde;
uppercase A, dieresis   Ä  &#196;   &Auml;
uppercase A, ring Å  &#197;   &Aring; or &angst;
uppercase AE diphthong  Æ  &#198;   &AElig;
uppercase C, cedilla Ç  &#199;   &Ccedil;
uppercase E, grave accent  È  &200; &Egrave;
uppercase E, acute accent  É  &#201;   &Eacute;
uppercase E, circumflex accent   Ê  &#202;   &Ecirc;
uppercase E, dieresis   Ë  &#203;   &Euml;
uppercase I, grave accent  Ì  &#204;   &Igrave;
uppercase I, acute accent  Í  &#205;   &Iacute;
uppercase I, circumflex accent   Î  &#206;   &Icirc;
uppercase I, dieresis   Ï  &#207;   &Iuml;
uppercase Eth  Ð  &#208;   &ETH; or &Dstrok;
uppercase N, tilde   Ñ  &#209;   &Ntilde;
uppercase O, grave accent  Ò  &#210;   &Ograve;
uppercase O, acute accent  Ó  &#211;   &Oacute;
uppercase O, circumflex accent   Ô  &#212;   &Ocirc;
uppercase O, tilde   Õ  &#213;   &Otilde;
uppercase O, dieresis   Ö  &#214;   &Ouml;
multiply sign  ×  &#215;   &times;
uppercase O, slash   Ø  &#216;   &Oslash;
uppercase U, grave accent  Ù  &#217;   &Ugrave;
uppercase U, acute accent  Ú  &#218;   &Uacute;
uppercase U, circumflex accent   Û  &#219;   &Ucirc;
uppercase U, dieresis   Ü  &#220;   &Uuml;
uppercase Y, acute accent  Ý  &#221;   &Yacute;
uppercase Thorn   Þ  &#222;   &THORN;
German sz ligature   ß  &#223;   &szlig;
lowercase a, grave accent  à  &#224;   &agrave;
lowercase a, acute accent  á  &#225;   &aacute;
lowercase a, circumflex accent   â  &#226;   &acirc;
lowercase a, tilde   ã  &#227;   &atilde;
lowercase a, dieresis   ä  &#228;   &auml;
lowercase a, ring å  &#229;   &aring;
lowercase ae ligature   æ  &#230;   &aelig;
lowercase c, cedilla ç  &#231;   &ccedil;
lowercase e, grave accent  è  &#232;   &egrave;
lowercase e, acute accent  é  &#2zTAG_LTH; &eacute;
lowercase e, circumflex accent   ê  &#234;   &ecirc;
lowercase e, dieresis   ë  &#235;   &euml;
lowercase i, grave accent  ì  &#236;   &igrave;
lowercase i, acute accent  í  &#237;   &iacute;
lowercase i, circumflex accent   î  &#238;   &icirc;
lowercase i, dieresis   ï  &#239;   &iuml;
lowercase eth  ð  &#240;   &eth;
lowercase n, tilde   ñ  &#241;   &ntilde;
lowercase o, grave accent  ò  &#242;   &ograve;
lowercase o, acute accent  ó  &#243;   &oacute;
lowercase o, circumflex accent   ô  &#244;   &ocirc;
lowercase o, tilde   õ  &#245;   &otilde;
lowercase o, dieresis   ö  &#246;   &ouml;
division sign  ÷  &#247;   &divide;
lowercase o, slash   ø  &#248;   &oslash;
lowercase u, grave accent  ù  &#249;   &ugrave;
lowercase u, acute accent  ú  &#250;   &uacute;
lowercase u, circumflex accent   û  &#251;   &ucirc;
lowercase u, dieresis   ü  &#252;   &uuml;
lowercase y, acute accent  ý  &#253;   &yacute;
lowercase thorn   þ  &#254;   &thorn;
lowercase y, dieresis   ÿ  &#255;   &yuml;


These functions are for *html* quoting. If you need *URL* quoting you
need urllib.quote, urllib.quote_plus or quixote.html.url_quote.

I think the OP is looking for something that will turn 'é' into
'&#2zTAG_LTH;' or '&eacute;', for instance, for use where UTF-8 isn't
supported (and I'd suggest trying UTF-8 first!). Otherwise, something like:


def escape_to_entities(string):
    string = string.replace('&', '&amp;')
    string = string.replace('<', '&lt;')
    string = string.replace('>', '&gt;')
    string = string.replace('"', '&quot;')
    result = []
    for s in string:
        if ord(s) > 0x7f:
            s = '&#%d;'%ord(s)
        result.append(s)
    return ''.join(result)

#endif

#if 0

Nr Zeichen HTML-Encoding
 zTAG_LTH, !
 34, &quot;
 35, #
 36, $
 37, %
 38, &amp;
 39, '
 40, (
 41, )
 42, *
 43, +
 44, ,
 45, -
 46, .
 47, /
 48, 0
 49, 1
 50, 2
 51, 3
 52, 4
 53, 5
 54, 6
 55, 7
 56, 8
 57, 9
 58, :
 59, ;
 60, &lt;
 61, =
 62, &gt;
 63, ?
 64, @
 65, A
 66, B
 67, C
 68, D
 69, E
 70, F
 71, G
 72, H
 73, I
 74, J
 75, K
 76, L
 77, M
 78, N
 79, O
 80, P
 81, Q
 82, R
 83, S
 84, T
 85, U
 86, V
 87, W
 88, X
 89, Y
 90, Z
 91, [
 92, \
 93, ]
 94, ^
 95, _
 96, `
 97, a
 98, b
 99, c
100, d
101, e
102, f
103, g
104, h
105, i
106, j
107, k
108, l
109, m
110, n
111, o
112, p
113, q
114, r
115, s
116, t
117, u
118, v
119, w
120, x
121, y
122, z
123, {
124, |
125, }
126, ~
127, 
128, &#8364;
129, ü
130, &#8218;
131, &#402;
132, &#8222;
1zTAG_LTH, &#8230;
134, &#8224;
135, &#8225;
136, &#710;
137, &#8240;
138, &#352;
139, &#8249;
140, &#zTAG_LTH8;
141, ì
142, &#381;
143, Å
144, É
145, &#8216;
146, &#8217;
147, &#8220;
148, &#8221;
149, &#8226;
150, &#8211;
151, &#8212;
152, &#732;
153, &#8482;
154, &#353;
155, &#8250;
156, &#zTAG_LTH9;
157, ¥
158, &#382;
159, &#376;
160, &#160;
161, &#161;
162, &#162;
163, &#163;
164, &#164;
165, &#165;
166, &#166;
167, &#167;
168, &#168;
169, &#169;
170, &#170;
171, &#171;
172, &#172;
173, &#173;
174, &#174;
175, &#175;
176, &#176;
177, &#177;
178, &#178;
179, &#179;
180, &#180;
181, &#181;
182, &#182;
183, &#183;
184, &#184;
185, &#185;
186, &#186;
187, &#187;
188, &#188;
189, &#189;
190, &#190;
191, &#191;
192, &#192;
193, &#193;
194, &#194;
195, &#195;
196, &#196;
197, &#197;
198, &#198;
199, &#199;
200, &#200;
201, &#201;
202, &#202;
203, &#203;
204, &#204;
205, &#205;
206, &#206;
207, &#207;
208, &#208;
209, &#209;
210, &#210;
211, &#211;
212, &#212;
213, &#213;
214, &#214;
215, &#215;
216, &#216;
217, &#217;
218, &#218;
219, &#219;
220, &#220;
221, &#221;
222, &#222;
223, &#223;
224, &#224;
225, &#225;
226, &#226;
227, &#227;
228, &#228;
229, &#229;
230, &#230;
231, &#231;
232, &#232;
2zTAG_LTH, &#2zTAG_LTH;
234, &#234;
235, &#235;
236, &#236;
237, &#237;
238, &#238;
239, &#239;
240, &#240;
241, &#241;
242, &#242;
243, &#243;
244, &#244;
245, &#245;
246, &#246;
247, &#247;
248, &#248;
249, &#249;
250, &#250;
251, &#251;
252, &#252;
253, &#253;
254, &#254;
255, &#255;

#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#if 0    // moved to kzoeufaa.c   DKS - 11/01/96

/////////////////////////////////////////////////////////////////////////////
//
// MODULE NAME:   zdrvstr.cpp - ZeidonString manipulation routines used by
//                code generated by VML.
// DESCRIPTION:   This is the source file for the following string
//                manipulation routines:
//
//                     ZeidonStringCopy
//                     ZeidonStringConcat
//                     ZeidonStringCompare
//
//                The purpose is to use these functions in place of the C
//                level string string functions (since they will be generated
//                by VML) so that the handling of strings is more complete
//                and error resistent.  Additionally, strings will be handled
//                the same way regardless of the target language.
//
/////////////////////////////////////////////////////////////////////////////
// Copyright (c) 2000-2016 QuinSoft, Inc. All rights reserved.
// Confidential and Proprietary material subject to license - do not
// reproduce or disclose.  This material is an unpublished work and
// is considered a trade secret belonging to the copyright holder.
/////////////////////////////////////////////////////////////////////////////
//
// AUTHOR:        Jeffrey S. Beam
// DATE:          1992/08/18
// API:           MicroSoft foundation classes and Windows 3.1 SDK
// ENVIRONMENT:   Windows 3.1
// REVISION:      0.9a   1995/08/05
//
// HISTORY:
//
//    1995/08/05: Beginning of 0.9a branch
//
/////////////////////////////////////////////////////////////////////////////
//

#define     qMAXRECEIVEISNEGATIVE       -2
#define     qMAXCOPYISNEGATIVE          -3
#define     qMAXRECEIVEEXCEEDSTARGETLEN -4
#define     qINVALIDPARAMETER           -5

// #define DEBUG_STRINGS
// for testing, compile with cl -AL -F 2000 -Zi kzdlzsaa.cpp

#ifdef  DEBUG_STRINGS
#include "kzoeenaa.h"
#undef OPERATION
#define OPERATION
#include "string.h"
#include <ostream.h>
#define TraceLineI( a, b ) cout << (a) << " = " << (b) << endl
#define TraceLineS( a, b ) cout << (a) << " = \"" << (b) << "\"" << endl

#endif

//./ ADD NAME=ZeidonStringCopy
// Source Module=zdrvstr.cpp
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringCopy
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringCopy is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              pchSrcString  - The source string of the copy.
//              lSrcIdx       - The index into the string at which reading
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ zTAG_LTH ];
//                              lMaxTgtLth should be zTAG_LTH). It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target until the end of the target, never exceeding lMaxTgtLth.
//    If lMaxCopy is 0, then copy until the end of the source, target, or
//    lMaxReceive, whichever comes first.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zOPER_EXPORT zSHORT OPERATION
ZeidonStringCopy( zPCHAR pchTgtString,
                  zLONG  lTgtIdx,
                  zLONG  lMaxReceive,
                  zPCHAR pchSrcString,
                  zLONG  lSrcIdx,
                  zLONG  lMaxCopy,
                  zLONG  lMaxTgtLth )
{
   zLONG lNbrToCopy;
   zLONG lLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(zdrvstr) ZeidonStringCopy:    TgtString", pchTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", pchSrcString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxCopy", lMaxCopy );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   if ( pchTgtString == 0 || pchSrcString == 0 ||     // gotta have strings
        lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index
   {
      return( qINVALIDPARAMETER );
   }

   lTgtIdx--;  // convert 1-based index to 0-based index for
   lSrcIdx--;

   /* ensure all parms sync up and that lTgtIdx + lMaxReceive is
      less than lMaxTgtLth */
   if ( lMaxReceive < 0 )
      return( qMAXRECEIVEISNEGATIVE );

   if ( lMaxCopy < 0 )
      return( qMAXCOPYISNEGATIVE );

   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
      return( qMAXRECEIVEEXCEEDSTARGETLEN );


   /* if lMaxReceive is the default of 0 then the Max is really
      lMaxTgtLth - lTgtIdx - 1 (for zero-based index) */
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth - lTgtIdx - 1;

   if ( lMaxCopy == 0 )
      lMaxCopy = lMaxReceive;

   // copy the lesser of lMaxReceive or lMaxCopy.
   lNbrToCopy = (lMaxReceive < lMaxCopy) ? lMaxReceive : lMaxCopy;
   lLth = zstrlen( pchSrcString + lSrcIdx );
   if ( lLth < lNbrToCopy )
      lNbrToCopy = lLth + 1;

   strncpy_s( pchTgtString + lTgtIdx, lMaxReceive - lTgtIdx, pchSrcString + lSrcIdx, lNbrToCopy );
   pchTgtString[ lTgtIdx + lNbrToCopy ] = 0;

#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( zstrlen( pchTgtString ) );
}

//./ ADD NAME=ZeidonStringConcat
// Src Module=zdrvstr.cpp
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringConcat
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringConcat is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - Ignored in this function
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              pchSrcString  - The source string of the concatenation.
//              lSrcIdx       - The index into the string at which copying
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ zTAG_LTH ];
//                              lMaxTgtLth should be zTAG_LTH). It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target starting at the end of the target, never exceeding
//    lMaxTgtLth. If lMaxConcat is 0, then copy until the end of the
//    source, target, or lMaxReceive, whichever comes first.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zOPER_EXPORT zSHORT OPERATION
ZeidonStringConcat( zPCHAR pchTgtString,
                    zLONG lTgtIdx,
                    zLONG lMaxReceive,
                    zPCHAR pchSrcString,
                    zLONG lSrcIdx,
                    zLONG lMaxConcat,
                    zLONG lMaxTgtLth )
{
   zLONG lNbrToConcat;
   zLONG lLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(zdrvstr) ZeidonStringConcat:  TgtString", pchTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", pchSrcString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxConcat", lMaxConcat );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   if ( pchTgtString == 0 || pchSrcString == 0 ||     // gotta have strings
        lSrcIdx == 0 )                                // 1-based index
   {
      return( qINVALIDPARAMETER );
   }

   lSrcIdx--;  // convert 1-based index to 0-based index for

   /* ensure all parms sync up and that lTgtIdx + lMaxReceive is less
      than lMaxTgtLth */
   if ( lMaxReceive < 0 )
      return( qMAXRECEIVEISNEGATIVE );

   if ( lMaxConcat < 0 )
      return( qMAXCOPYISNEGATIVE );

   if ( lMaxReceive > lMaxTgtLth )
      return( qMAXRECEIVEEXCEEDSTARGETLEN );

   /* find the current end */
   lTgtIdx = zstrlen( pchTgtString );
   if ( lTgtIdx > lMaxTgtLth )
      lTgtIdx = lMaxTgtLth;

   /* if lMaxReceive is the default of 0 then the Max is really
      lMaxTgtLth - lTgtIdx */
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth - lTgtIdx;

   if ( lMaxConcat == 0 )
      lMaxConcat = lMaxReceive;

   // concat the lesser of lMaxReceive or lMaxCopy.
   lNbrToConcat = (lMaxReceive < lMaxConcat) ? lMaxReceive : lMaxConcat;
   lLth = zstrlen( pchSrcString + lSrcIdx );
   if ( lLth < lNbrToConcat )
      lNbrToConcat = lLth + 1;

   strncpy_s( pchTgtString + lTgtIdx, lMaxReceive - lTgtIdx, pchSrcString + lSrcIdx, lNbrToConcat );
   pchTgtString[ lTgtIdx + lNbrToConcat ] = 0;

#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( zstrlen( pchTgtString ) );
}

//./ ADD NAME=ZeidonStringCompare
// Src Module=zdrvstr.cpp
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringCompare
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringCompare is a system operation that exists to be
//             used in Zeidon application code. Hopefully, it will be used in
//             place of the C level string functions. The purpose is to use
//             these functions (since they will be generated by VML) so that
//             the handling of strings is more complete and error resistent.
//             Additionally, strings will be handled the same way regardless
//             of the target language.
//
//  PARAMETERS: pchTgtString  - The resultant string (copied into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              pchSrcString  - The source string of the copy.
//              lSrcIdx       - The index into the string at which reading
//                              will begin.  Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxCopy      - The maximum number of characters to copy
//                              from the source string.  If this is 0, then
//                              copy until the end of the source, target, or
//                              lMaxReceive, whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ zTAG_LTH ];
//                              lMaxTgtLth should be zTAG_LTH). It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//    There are a couple defaults. If lMaxReceive is 0, then copy to the
//    target until the end of the target, never exceeding lMaxTgtLth.
//    If lMaxCopy is 0, then copy until the end of the source, target, or
//    lMaxReceive, whichever comes first.
//
//  RETURNS:    -1  - Source string < Target string
//               0  - Source string = Target string
//               1  - Source string > Target string
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zOPER_EXPORT zSHORT OPERATION
ZeidonStringCompare( zPCHAR  pchTgtString,
                     zLONG   lTgtIdx,
                     zLONG   lMaxReceive,
                     zPCHAR  pchSrcString,
                     zLONG   lSrcIdx,
                     zLONG   lMaxCompare,
                     zLONG   lMaxTgtLth )
{
   zLONG lNbrToCompare;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(zdrvstr) ZeidonStringCompare: TgtString", pchTgtString );
   TraceLineI( "                                lTgtIdx", lTgtIdx );
   TraceLineI( "                                lMaxReceive", lMaxReceive );
   TraceLineS( "                                SrcString", pchTgtString );
   TraceLineI( "                                lSrcIndex", lSrcIdx );
   TraceLineI( "                                lMaxCompare", lMaxCompare );
   TraceLineI( "                                lMaxTgtLth", lMaxTgtLth );
#endif

   if ( pchTgtString == 0 || pchSrcString == 0 ||     // gotta have strings
        lTgtIdx == 0 || lSrcIdx == 0 )                // 1-based index
   {
      return( qINVALIDPARAMETER );
   }

   lTgtIdx--;  // convert 1-based index to 0-based index for
   lSrcIdx--;

   /* ensure all parms sync up and that lTgtIdx + lMaxReceive is less
      than lMaxTgtLth */
   if ( lMaxReceive < 0 )
      return( qMAXRECEIVEISNEGATIVE );

   if ( lMaxCompare < 0 )
      return( qMAXCOPYISNEGATIVE );

   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
      return( qMAXRECEIVEEXCEEDSTARGETLEN );

   /* if lMaxReceive is the default of 0 then the Max is really
      lMaxTgtLth - lTgtIdx */
   if ( lMaxReceive == 0 )
   {
      // Max receive is 0, set max receive to the number of characters
      // in the target string EXCLUDING the null terminator
      lMaxReceive = lMaxTgtLth - (lTgtIdx - 1);

      // If MaxCompare is 0 as well, assume the C convention of comparing
      // by including the null terminator in the compare on the target
      // string.
      if ( lMaxCompare == 0 )
         lMaxReceive++;
   }

   if ( lMaxCompare == 0 )
      lMaxCompare = lMaxReceive;

   /* compare the lesser of lMaxReceive or lMaxCompare */
   lNbrToCompare = (lMaxReceive < lMaxCompare) ? lMaxReceive : lMaxCompare;
   return( zstrncmp( pchSrcString + lSrcIdx,
                     pchTgtString + lTgtIdx, lNbrToCompare ) );
}


//./ ADD NAME=ZeidonStringConvertFromNumber
// Source Module=zdrstr.cpp
/////////////////////////////////////////////////////////////////////////////
//
//  OPERATION: ZeidonStringConvertFromNumber
//                                              07/21/93 Modified: 07/21/93
//
//  PURPOSE:   ZeidonStringConvertFromNumber is similar to other Zeidon
//             string routines, except that there is only one string variable
//             (the target) and either an integer variable or a decimal
//             variable.  Only one or the other should be supplied and the
//             other parameter should be 0, as indicated by NumberType.
//             Like the other string routines, this routine uses the index and
//             max target length parameters.  If the converted data is greater
//             than the max target length, the target string is filled with
//             "*****".
//
//  PARAMETERS: pchTgtString  - The resultant string (converted into).
//              lTgtIdx       - The index into the string at which copying
//                              will begin. Note that Zeidon Strings are
//                              indexed starting at 1 rather than 0.
//              lMaxReceive   - The maximum number of characters permitted
//                              in the target string (including the null
//                              terminator).  If this is 0, then copy until
//                              the target is full or the end of the source,
//                              whichever comes first.
//              lMaxTgtLth    - The maximum length of the target string
//                              INCLUDING the null terminator (i.e.  if the
//                              target buffer is defined as:
//                                     zCHAR szTgtBuff[ zTAG_LTH ];
//                              lMaxTgtLth should be zTAG_LTH). It is guaranteed
//                              by this operation that the length of the
//                              result string + 1 (for the null terminator)
//                              will not exceed lMaxTgtLth.
//
//              lIntegerValue - The integer value to be converted.
//              dDecimalValue - The decimal value to be converted.
//              cNumberType   - 'I' for integer and 'D' for decimal.
//
//  RETURNS:   >= 0 - length of resultant TgtString
//              -2  - MaxReceive is negative
//              -3  - MaxCopy is negative
//              -4  - MaxReceive exceeds MaxTgtLth
//              -5  - Invalid parameters (null string pointers or 0 indexes)
//
/////////////////////////////////////////////////////////////////////////////
//./ END + 8
zOPER_EXPORT zSHORT OPERATION
ZeidonStringConvertFromNumber( zPCHAR   pchTgtString,
                               zLONG    lTgtIdx,
                               zLONG    lMaxReceive,
                               zLONG    lMaxTgtLth,
                               zLONG    lIntegerValue,
                               zDECIMAL dDecimalValue,
                               zPCHAR   szNumberType )
{
   zCHAR szWorkString[ 32 ];
   zLONG lLth;

#ifdef  DEBUG_STRINGS
   TraceLineS( "(zdrstr) ZeidonStringConvertFromNumber:    TgtString", pchTgtString );
   TraceLineI( "                                           lTgtIdx", lTgtIdx );
   TraceLineI( "                                           lMaxTgtLth", lMaxTgtLth );
   TraceLineI( "                                           lIntegerValue", lIntegerValue );
#endif


   if ( lMaxReceive < 0 )
      return( qMAXRECEIVEISNEGATIVE );

//   if ( (lTgtIdx + lMaxReceive) > lMaxTgtLth )
//      return( qMAXRECEIVEEXCEEDSTARGETLEN );


   /* if lMaxReceive is the default of 0 then the Max is really
      lMaxTgtLth - lTgtIdx - 1 (for zero-based index) */
   if ( lMaxReceive == 0 )
      lMaxReceive = lMaxTgtLth - lTgtIdx - 1;

   if ( pchTgtString <= 0 || lTgtIdx <= 0 )
      return( qINVALIDPARAMETER );

   if ( szNumberType[0] != 'I' && szNumberType[0] != 'D' )
      return( qINVALIDPARAMETER );

   lTgtIdx--;  // convert 1-based index to 0-based index

   if ( szNumberType[0] == 'I' )
      _ltoa_s( lIntegerValue, szWorkString );
   else
      ConvertDecimalToString( szWorkString, 0, dDecimalValue, 0 );

   // Copy the lesser of lMaxReceive or the length of the converted value.
   lLth = zstrlen( szWorkString );
   if ( lLth > lMaxReceive )
   {
      lLth = lMaxReceive;
      *(pchTgtString + lTgtIdx + lLth) = 0;
      lLth--;
      while ( lLth >= 0 )
      {
         *(pchTgtString + lTgtIdx + lLth) = '*';
         lLth--;
      }
   }
   else
   {
      strncpy_s( pchTgtString + lTgtIdx, lMaxReceive - lTgtIdx, szWorkString, lLth );
      pchTgtString[ lTgtIdx + lLth ] = 0;
   }


#ifdef  DEBUG_STRINGS
   TraceLineI( "                                RESULT",
               zstrlen( pchTgtString ) );
   TraceLineS( "                                String", pchTgtString );
   TraceLineS( "-----------------------------------------------------------",
               "" );
#endif

   return( zstrlen( pchTgtString ) );
}


#ifdef DEBUG_STRINGS

int
main( )
{
   zCHAR szStr1[ 100 ];
   zCHAR szStr2[ 10 ];
   zCHAR szStr3[ 1090 ];  // buffer  to keep from overlaying on error
   zPCHAR szStr4 = "Zeidon_Tools .9a";
   zPCHAR szStr5 = "1234567890abcdefghijklmnopqrstuvwxyz";
   zLONG lRC;

   szStr1[ 0 ] = 0;
   szStr2[ 0 ] = 0;
   szStr3[ 0 ] = 0;
   lRC = ZeidonStringCopy( szStr1, 1, 0, szStr4, 1, 8, 8 );
   TraceLineS( "Zeidon_Tools .9a", szStr1 );
   lRC = ZeidonStringCopy( szStr1, 1, 0, szStr4, 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCopy( szStr1, 1, 0, "A", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCopy( szStr2, 1, 0,
                           "1234567890abcdefghijklmnopqrstuvwxyz",
                           1, 0, zsizeof( szStr2 ) );
   lRC = ZeidonStringCopy( szStr2, 1, 0, szStr5, 1, 0, zsizeof( szStr2 ) );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "A", 1, 0, zsizeof( szStr1 ) );
   TraceLineI( "String Compare Returned (0)", lRC );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "B", 1, 0, zsizeof( szStr1 ) );
   TraceLineI( "String Compare Returned (!0)", lRC );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "AAA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "AxA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "", 1, 0, "AxA", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "", 1, 0, "", 1, 0, zsizeof( szStr1 ) );
   lRC = ZeidonStringCompare( "WWWW", 1, 0, "", 1, 0, 100 );
   lRC = ZeidonStringCompare( szStr1, 1, 0, "AABxA", 1, 2, zsizeof( szStr1 ) );

   lRC = ZeidonStringCompare( szStr1, 1, 0, "ABAxA", 1, 2, zsizeof( szStr1 ) );

   return( 0 );
}
#endif

#endif   // moved to kzoeufaa.c   DKS - 11/01/96
