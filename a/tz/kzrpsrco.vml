// 2005.12.15    DKS
//    Fixed multi-root reset page numbering for "starting on page 2" setting.
// 2005.09.05    DKS
//    Added multi-root reset page numbering.
// 2002.06.24    DonC
//    Modified fnFormatGroupOnPage to call operation fnComputeQueryValue to support
//    the Query Report function.
// 2002.01.30    DKS
//    When in a FooterDidNotFit condition, check for ForcePageBreak condition
//    to determine if a RETURN should be done.
// 2002.01.29    PAS
//    Allow multiple Overlay Groups within a GroupSet.  Generally,
//    exit code will suppress the one(s) that are not to be printed.
// 2002.01.29    FH
//    Initialize vFooterDidNotFit
// 2002.01.23    DKS/FH    Z10
//    correction of bugs in report (entitybreak and tabstop support).
// 2001.12.01    PAS
//    Eliminate duplicate Group Headers when a mltiline text field is
//    continued to the next page.  Fix can be nullified by the using the
//    new Zeidon.ini entry [Debug] IgnoreReportFix011201(ExtraDtlHdr)=Y
// 2001.11.27    PAS
//    Fix to handle problem created by previous fixes.  First Root Entity was
//    being skipped.  Caused many different symptoms, depending on the report.
// 2001.11.26    PAS
//    Changed the handling of continuations and the use of the PageState
//    entity.  This was done to fix a bug with printing groups that contained
//    multiline text that was continued.  All fields woud be reprinted on the
//    continuation.  Also, fixed problem where a continued multiline would
//    would not print on the next page (usually noticed on the last entity
//    printed for the report).
// 2001.10.18    PAS DGC
//    ProcessFooters changed to set bValidView (it was commented out by
//    accident).  This resores the proper generation of Group Footers.
// 2001.09.26    PAS
//    Fixed bug (existing for a long time) when a multiline text field was in
//    the PAGE Header and a multiline text field in a detail Group splits to
//    a new page.  There are now trace lines that say that a multiline field
//    was truncated since it cannot be continued to another page because it
//    is part of a header or footer.
// 2001.09.23    PAS
//    Implemented report Group exits. Report Exits are invoked by the report
//    engine with the following 6 parameters:
//      VIEW       vSubtask,    (same view passed into FormatSubobjectOnDoc)
//      VIEW       DrivingOI,   (positioned at current entity being processed)
//      STRING(32) GrpSetName,  (tag for the GroupSet )
//      STRING(32) GroupName,   (tag for the Group within the GroupSet)
//      SHORT      nEvent,      (one of four possible events - see below)
//      SHORT      nCurrentPage (guess)
//
//    The event points are:
//      1. PREPRINT        - prior to the Group starting to print
//                           valid return values are:
//          0 - continue
//          1 - don't print (zRGE_RETURN_SUPPRESS)
//          2 - go to new page before printing (zRGE_RETURN_NEWPAGE)
//      2. GROUP_CONTINUE  - a split Group is continuing to print on a
//                           new page.
//                           valid return values are:
//          0 - continue
//          1 - don't print (zRGE_RETURN_SUPPRESS) (maybe all remaining
//              fields are blank)
//      3. GROUP_SPLITTING - the Group has partially printed and is about to
//                           cause a page break.
//                           only valid return is 0 - continue
//      4. POSTPRINT       - after Group has completed printing.
//                           valid return values are:
//          0 - continue
//          2 - go to new page before continuing
//
// 2001.05.25    PAS
//    Changed calculation of lRemainingSpaceOnPageY to prevent multi-line text
//    from page breaking at wrong time when in Groups with many controls.
//
// 2001.03.30    PAS  R54301
//    Header/Footer Group subtype of FirstPageOnly or StartAtSecondPage were
//    implemented to clear bug R54301.  LastPageOnly is not supported.
//
// 2001.03.19    DKS
//    Print page count as 3/10
//
// 2001.02.21    DC
//    Deleted code to create a Footer during page one initialization as it was
//    erroneously copied earlier and was generating an erroneous footer at
//    start of report when the first entity in the report had a footer.
//    Also for page one, I eliminated the processing of the first Group prior
//    to the normal processing Group because it would not handle the Group
//    header correctly and wasn't needed for page one.
//
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

// Note: Globally change //UNDEF to /*DEF*/ and vice versa to enable/disable
//       debugging code.
//                  Also //UNDCC to /*DCC*/ for All Control detail.
//                  Also //UNDVV to /*DVV*/ for View Issues.
//
// >>>>>>>>>>>>>>> Development Notes  <<<<<<<<<<<<<<
// Several improvements and inhancements and fixes are
// needed in the report area. What follows is a brief
// list of what is needed as of May, '97. The documentation
// for this routine follows.
// 1. We need to add the ability to change the page size for
// a report. Currently, the page size defaults to 8 1/2 by 11.
//
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//
// Using the SubobjectEntityName passed to identify the top of the subobject
// to process, navigate the subobject from vSourceOI hierarchically and
// format a Group on the document for each entity that has a corresponding
// GroupSet in vReportDef.
// When an entity under its parent is processed for the first time, see if
// there is a Header Group in vReportDef, and format that if there is.  When
// an entity under its parent is processed for the last time, see if there is
// a Footer Group in vReportDef, and format that if there is.
//
/////////////////////////////////////////////////////////////////////////////

// #define CreateViewFromViewForTask( pvReturn, vSrc, vTask ) CreateViewTrace( __FILE__ " #" mSTR2( __LINE__ ), pvReturn, vSrc, vTask )
// #define DropView( v ) DropViewTrace( __FILE__ " #" mSTR2( __LINE__ ), v )
// #define GetViewFromAttribute( pv, v, e, a ) { char sz[ 64 ];  GetIntegerFromAttribute( pv, v, e, a ); MiGetObjectNameForView( sz, *pv ); TraceLine( "GetView %s  %s.%s 0x%08x LOD: %s", __FILE__ " #" mSTR2( __LINE__ ), e, a, *pv, sz ); }
// #define SetAttributeFromView( v, e, a, vValue ) { char sz[ 64 ]; SfLockView( vValue ); SetAttributeFromInteger( v, e, a, vValue ); MiGetObjectNameForView( sz, vValue ); TraceLine( "SetView %s  %s.%s 0x%08x LOD: %s", __FILE__ " #" mSTR2( __LINE__ ), e, a, vValue, sz ); }

TRANSFORMATION OPERATION
FormatSubobjectForDef( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                       VIEW    vSubtask,
                       VIEW    vSourceOI,
                       STRING ( 32 ) szReportDefName,
                       STRING ( 32 ) szSubobjectEntityName,
                       INTEGER lPrintPreviewFlag,
                       INTEGER lPrintDialogFlag,
                       INTEGER lPrintFlags ) //  0 - Print to printer.
                                             // +1 - Print Preview.
                                             // +2 - Print Dialog.
                                             // +4 - Force 0, 1, or 2 ... do not
                                             //      use OE settings.
                                             // +8 - Print multiple entities at
                                             //      top level.
                                             // +16 - Close subtask when closing
                                             //       the print preview window.
                                             // +32 - Count the number of pages
                                             //       prior to printing
                                             // +64 - After printing is complete,
                                             //       drop vSourceOI.
                                             // +128 - Create CSV file.
                                             // +256 - Create HTML file.
                                             // +512 - Fit To Page (not implemented)
                                             // +1024 - Reset Paging
                                             // +2048 - Print PageFooter using PageHeader view
                                             // +8192 - Trace OI
                                             // +16384 - Cause MessageBox
                                             // +32768 - Drive by ReportDef instead of SourceOI

   INTEGER bValidView
   INTEGER nRC

   NAME VIEW vSourceOI  "TZ_SourceOrigOI"
   NAME VIEW vReportDef "TZ_ReportDef"
   nRC = IsFlagSequenceSet( lPrintFlags, 8192 )  // Trace OI
   IF nRC != 0
      DisplayObjectInstance( vSourceOI, "", "" )
   END

   nRC = IsFlagSequenceSet( lPrintFlags, 16384 ) // Cause MessageBox
   IF nRC != 0
      SysMessageBox( vSubtask, "TZ_SourceOrigOI Entity", szSubobjectEntityName, TRUE )
   END

   // These values are stored for future reference ... the only place
   // they are set.
   vReportDef.Report.WK_SubobjectEntityName = szSubobjectEntityName
   vReportDef.Report.PrintFlags = lPrintFlags

// bValidView = bValidView / bValidView
// SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View -1", TRUE )

   // Call the OpenReport routine which will process all pages for the report,
   // calling routine, FormatDocOnPage, to format each page of the report.
   // We will determine if we need to force Preview based on a flag in the
   // Profile object, set in the Object Browser dialog.  If it is not set on
   // or if the Profile object doesn't exist, we will go with the Preview
   // flag value passed to this routine.
   //
// lPrintFlags = SetFlagSequence( lPrintFlags,
//                                65535,  // 0x0000ffff  turn off high bits
//                                0 )
   lPrintFlags = lPrintFlags + lPrintPreviewFlag

   // zREPORT_PRINT2CSV             0x00000080   (128)
   // zREPORT_PRINT2HTML            0x00000100   (256)
   nRC = IsFlagSequenceSet( lPrintFlags, 128 ) // zREPORT_PRINT2CSV
   IF nRC != 0
      PrintReportToCSV( vSubtask, vSourceOI, szSubobjectEntityName,
                        szReportDefName, szReportDefName, lPrintFlags )
   ELSE
      nRC = IsFlagSequenceSet( lPrintFlags, 256 ) // zREPORT_PRINT2HTML
      IF nRC != 0
         PrintReportToHTML( vSubtask, vSourceOI, szSubobjectEntityName,
                            "", szReportDefName, lPrintFlags )

      ELSE
         OpenReport( vSubtask, "KZRPSRCO", "oTZRPSRCO_FormatDocPage",
                     lPrintFlags, TRUE, TRUE, lPrintDialogFlag,
                     szReportDefName, szSubobjectEntityName )
      END
   END
END

/////////////////////////////////////////////////////////////////////////////
//
// This routine actually gets control through the OpenReport subroutine
// from the framework to print a page.  This means that the framework
// drives the process, rather than the FormatSubobjectOnDoc routine.
// The FormatSubobjectOnDoc has set up all the necessary parameters in
// the ReportDef.  What we will do here is print a "single page" report
// by continuing to loop through the report.  We will use the named view,
// TZ_ReportDef, for report definition information.
//
// NOTE ON POSITIONS: The report def contains information on both size
// and position of GroupSets. In particular, the Y positions are given
// relative to the beginning of the page. These Y positions are not used
// now, at print time. This is because a GroupSet may contain a Group
// that contains a multi-line edit control. Since we have no possible
// foreknowledge about the length of multi-line text, there is no way
// to know before print time how much space in the Y direction is needed
// for the multi-line control and hence for the Group and the GroupSet.
// For this reason, GroupSet positions are ignored and lCurrentPosY will
// indicate where on a page to put the next GroupSet to be processed.
//
// We enter this routine to print all pages for the report.
//
/////////////////////////////////////////////////////////////////////////////

TRANSFORMATION OPERATION
FormatReportGroupSets( VIEW    vSubtask,
                       INTEGER lPageNbr,
                       INTEGER lPageWidth,
                       INTEGER lPageHeight )


   STRING ( 256 ) szViewName
   STRING ( 32 )  szSubobjectEntityName
   VIEW     vSourceOI
   VIEW     vReportDef
   INTEGER  lPrintFlags
   INTEGER  lCurrentPosX
   INTEGER  lCurrentPosY
   INTEGER  lNewPosX
   INTEGER  lNewPosY
   INTEGER  lRemainingSpaceOnPageY
   INTEGER  lBottomOfPage
   SHORT    nPrintMultiple
   SHORT    nRC

   IF lPageNbr <= 0  // we only care about page 1
      RETURN 0
   END

   lRemainingSpaceOnPageY = 2147483647  // BIG Number!!!

   szViewName = "TZ_ReportDef"
   GetViewByName( vReportDef, szViewName, vSubtask, zLEVEL_ANY )
   CreateViewFromViewForTask( vReportDef, vReportDef, vSubtask )
   ResetView( vReportDef )

   szSubobjectEntityName = vReportDef.Report.WK_SubobjectEntityName
   lPrintFlags = vReportDef.Report.PrintFlags

   // The state for page number zero will never change.
   fnPageStateAdd( vReportDef, 0 )

   szViewName = "TZ_SourceOrigOI"
   GetViewByName( vSourceOI, szViewName, vSubtask, zLEVEL_ANY )
   CreateViewFromViewForTask( vSourceOI, vSourceOI, vSubtask )

   nRC = IsFlagSequenceSet( lPrintFlags, 8 ) // print multiple entities
   IF nRC > 0
      nPrintMultiple = 1
      nRC = SetCursorFirstEntity( vSourceOI, szSubobjectEntityName, 0 )
   ELSE
      nRC = 1
   END

   LOOP WHILE nRC >= 0

      // Process each Page entity.
      SET CURSOR FIRST vReportDef.Page
      LOOP WHILE RESULT >= 0

         // Process each GroupSet entity.
         SET CURSOR FIRST vReportDef.GroupSet
         LOOP WHILE RESULT >= 0

            // Process each Group entity.
            SET CURSOR FIRST vReportDef.Group
            LOOP WHILE RESULT >= 0

               FormatGroupOnPage( vReportDef, vSourceOI, vSubtask,
                                  lNewPosX, lNewPosY,
                                  lCurrentPosX, lCurrentPosY, lRemainingSpaceOnPageY,
                                  32768, // continued Group flag 0x8000 = 32768 ==> WebPageReport
                                  lPageWidth, lPageHeight, lRemainingSpaceOnPageY,
                                  lBottomOfPage )
               SET CURSOR NEXT vReportDef.Group
            END

            SET CURSOR NEXT vReportDef.GroupSet
         END

         SET CURSOR NEXT vReportDef.Page
      END

      IF nPrintMultiple = 1
         nRC = SetCursorNextEntity( vSourceOI, szSubobjectEntityName, 0 )
      ELSE
         nRC = -1
      END
   END

   DropView( vSourceOI )
   DropView( vReportDef )
   RETURN 0

END

/////////////////////////////////////////////////////////////////////////////
//
// This routine actually gets control through the OpenReport subroutine
// from the framework to print a page.  This means that the framework
// drives the process, rather than the FormatSubobjectOnDoc routine.
// The FormatSubobjectOnDoc has set up all the necessary parameters in
// the ReportDef.  What we will do here is fill a page full of information.
// We do that by continuing to loop hierarchically through the source OI,
// which is the named view, TZ_SourceHierOI.  We will use the named view,
// TZ_ReportDef, for report definition information.
//
// NOTE ON POSITIONS: The report def contains information on both size
// and position of GroupSets. In particular, the Y positions are given
// relative to the beginning of the page. These Y positions are not used
// now, at print time. This is because a GroupSet may contain a Group
// that contains a multi-line edit control. Since we have no possible
// foreknowledge about the length of multi-line text, there is no way
// to know before print time how much space in the Y direction is needed
// for the multi-line control and hence for the Group and the GroupSet.
// For this reason, GroupSet positions are ignored and lCurrentPosY will
// indicate where on a page to put the next GroupSet to be processed.
//
// We enter this routine under 3 circumstances.
// 1. We enter this routine normally multiple times starting with page 1 for
//    a report and print all pages for the report.
// 2. We enter the routine to count the number of pages that will be on the
//    report.  We determine this by nPageNbr being 0, instead of a valid
//    page number.
// 3. We enter the routine in the middle of the report (some page other than
//    1).  We determine this by the value of nPageNbr being greater than that
//    specified in the ReportDef root.
//
// In either of the last two cases, we use a technique called Phantom Print
// where we loop through each page without printing it.
//
/////////////////////////////////////////////////////////////////////////////

TRANSFORMATION OPERATION
FormatDocPage( VIEW    vSubtask,
               INTEGER lPageNbr,
               INTEGER lPageWidth,
               INTEGER lPageHeight )

   VIEW         vReportDef         BASED ON LOD TZRPSRCO
   VIEW         vReportDef2        BASED ON LOD TZRPSRCO
   VIEW         vSourceOI
// VIEW         vDeferredOI
   INTEGER      bForcePageBreak
   VIEW         vFooterDidNotFit
   VIEW         vSourceHierOI
   VIEW         vSourceCurrentHierOI
   VIEW         vSourcePreviousHierOI
// VIEW         vFooterHierOI
   VIEW         vTempOI
   VIEW         vTemp
   INTEGER      lTempView
   STRING (32)  szCurrentEntityName
   STRING (32)  szSubobjectEntityName
   STRING (32)  szFaceName      // LF_FACENAME is 32
   STRING (256) szViewName
   INTEGER      lReturnLevel
   SHORT        nPageCnt
   SHORT        nRC
   SHORT        nCase
   SHORT        nPreviousPageNbr
   INTEGER      lStartLevel
   INTEGER      lPrintFlags
   INTEGER      lWork
   INTEGER      lDefaultFontSize
   INTEGER      lFontSize
   INTEGER      lEntityKey
   INTEGER      lNextPagePrinted
   INTEGER      lCurrentPagePrinted
   INTEGER      lPreviousPagePrinted
   STRING (32)  szHierEntityName
   STRING (32)  szRptEntityName
   STRING (32)  szRptGroupSetTag
   STRING (32)  szRptGroupTag
   STRING (32)  szRptContinuedControlTag
   INTEGER      lMultiLineTextPos
   INTEGER      lContinuedGroupFlag
   INTEGER      lHierRC
   INTEGER      lLastLevel
   INTEGER      bValidView
   INTEGER      lRptPos

//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineI( "FormatDocPage Nbr: ", lPageNbr )
//UNDEF END

   IF lPageNbr < 0  // here on BeginPrint (-1) or EndPrint (-3) or
                    //  BeginPrintPreview (-2) or EndPrintPreview (-4)

   // IF ( lPageNbr = -1 AND
   //      vReportDef.Report.TotalPageCnt != 0 )
   //
   //    vReportDef.Report.TotalPageCnt = 0
   //    lPageNbr = 0
   // ELSE
         RETURN 0
   // END
   END

   // Get the named views of the report definition and of the OI to be
   // printed.  If these do not exist, we don't belong here ... so get out
// GET VIEW vReportDef NAMED "TZ_ReportDef"
// GET VIEW vSourceOI NAMED "TZ_SourceOrigOI"
// GET VIEW vSourceHierOI NAMED "TZ_SourceHierOI"
   szViewName = "TZ_ReportDef"
   nRC = GetViewByName( vReportDef, szViewName, vSubtask, zLEVEL_ANY )
   szViewName = "TZ_SourceOrigOI"
   nRC = GetViewByName( vSourceOI, szViewName, vSubtask, zLEVEL_ANY )
   szViewName = "TZ_SourceHierOI"
   nRC = GetViewByName( vSourceHierOI, szViewName, vSubtask, zLEVEL_ANY )

   IF vSourceHierOI != 0
      bValidView = IsValidView( vSourceHierOI )
      IF bValidView = 0
         bValidView = bValidView / bValidView
      END
   END

// IF nRC <= 0
//    vSourceHierOI = 0  <<=== this is done by GetViewByName
// END

// GET VIEW vSourceCurrentHierOI NAMED "TZ_SourceCurrentHierOI"
// GET VIEW vSourcePreviousHierOI NAMED "TZ_SourcePreviousHierOI"
   szViewName = "TZ_SourceCurrentHierOI"
   nRC = GetViewByName( vSourceCurrentHierOI, szViewName, vSubtask, zLEVEL_ANY )
   szViewName = "TZ_SourcePreviousHierOI"
   nRC = GetViewByName( vSourcePreviousHierOI, szViewName, vSubtask, zLEVEL_ANY )

   //IF (vReportDef = 0 OR vSourceOI = 0 OR
   //    (lPageNbr > 1 AND vSourceHierOI = 0))
   IF ( vReportDef = 0 OR vSourceOI = 0 )

      TraceLineS( "PrintPage views dropped!", "" )
      RETURN -1   // get out of Dodge pronto!!!

   END

   // Initialize variables.
   szSubobjectEntityName = vReportDef.Report.WK_SubobjectEntityName
   lPrintFlags           = vReportDef.Report.PrintFlags
   lCurrentPagePrinted   = vReportDef.Report.CurrentPageNbr
   lNextPagePrinted      = lCurrentPagePrinted + 1
   lPreviousPagePrinted  = lCurrentPagePrinted - 1
   nPreviousPageNbr      = lPageNbr - 1

   lEntityKey = -1
   lHierRC = zCURSOR_NULL
   lStartLevel = 0
   lLastLevel = 0
   lMultiLineTextPos = 0
   lContinuedGroupFlag = 0
   szCurrentEntityName = szSubobjectEntityName
   szRptGroupSetTag = ""
   szRptGroupTag = ""
   szRptContinuedControlTag = ""
   szHierEntityName = ""
   szRptEntityName = "Report"
   lRptPos = 0
   nRC = zCURSOR_NULL
   vFooterDidNotFit = 0
   vReportDef.Report.FooterDidNotFit = 0

   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //
   // Keep track of levels and entity names in case we come back to a
   // page (print preview).  Note that the initial state of the current
   // page comes from the final state of the previous page.  Level
   // information for a given page is maintained at that page.
   //
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////

   // Force at least one PageNbr entity to exist (page number zero).
   IF vReportDef.PageState DOES NOT EXIST

      // The state for page number zero will never change.
      fnPageStateAdd( vReportDef, 0 )

      // If it's the first time on page 1, create the default font.
      lDefaultFontSize = vReportDef.Report.ReportTextSize
      szViewName = "ReportFont"
      GetWorkstationApplicationValues( vSubtask, szViewName,
                                       szFaceName, 32, lFontSize,
                                       lWork, lWork, lWork, lWork,
                                       lWork, lWork, lWork, lWork, lWork )
      IF lDefaultFontSize = 0
         lDefaultFontSize = lFontSize
      END

      CreateFontForReport( vSubtask, "default", lDefaultFontSize,
                           FALSE, FALSE, FALSE, FALSE,
                           -16777216, -16777216, 0, szFaceName )
   END

   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   // There are five possible cases:
   // 1. We are starting report at page 1.
   // 2. We are starting report at later than page 1.
   // 3. We are going to a next page.
   // 4. We are staying on the same page (for example zoom).
   // 5. We are going to the previous page and we have a view to previous
   //    page position.
   // 6. We are going to the previous page and we DON'T have a view to
   //    previous page position.
   // 7. We are only counting pages.

   // For case 1, we will go to INITIALIZE PAGE ONE. In this case we are
   // simply starting with the first page.  vSourceOI is pointing to
   // beginning of data for report.

   // For case 2, we will first go to INITIALIZE PAGE ONE and then begin
   // Phantom Print to skip pages until we get to the first page to be
   // printed. vSourceOI is pointing to beginning of data for report.

   // For case 3, we will use vSourceHierOI and go to INITIALIZE PAGE
   // INFORMATION FOR NEXT PAGE, CURRENT PAGE OR SINGLE PREVIOUS PAGE to
   // initialize information to next page. vSourceHierOI is pointing to
   // beginning of data for next page.

   // For case 4, we will use vSourceCurrentHierOI and go to INITIALIZE PAGE
   // INFORMATION FOR NEXT PAGE, CURRENT PAGE OR SINGLE PREVIOUS PAGE.
   // vSourceCurrentHierOI is pointing to the beginning of data for current
   // page.

   // For case 5, we will allow stepping back one page using view
   // vSourcePreviousHierOI by going to INITIALIZE PAGE INFORMATION FOR
   // NEXT PAGE, CURRENT PAGE OR SINGLE PREVIOUS PAGE.

   // For case 6, we did not have a view to the previous page so we must use
   // Phantom Print to start on page one and skip from page one to the
   // previous page. We will thus go to INITIALIZE PAGE ONE to start the
   // process.

   // For case 7, we will first go to INITIALIZE PAGE ONE and then begin
   // Phantom Print to skip all pages.
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////

   // Determine cases.
   IF lPageNbr = 1

      // 1. We are starting report at page 1.
      nCase = 1
   END

   IF lPageNbr > 1 AND lNextPagePrinted = 1

      // 2. We are starting report at later than page 1.
      nCase = 2
   END

   IF lPageNbr > 1 AND lNextPagePrinted = lPageNbr

      // 3. We are going to a next page.
      //    Reset Previous and Current views.
      //    Only drop Previous view if it is different from Current view.
      //    If it is the same, we must have paged back and then forward.
      //    The page back eliminated a separate Previous view.
      nCase = 3
      IF vSourcePreviousHierOI != vSourceCurrentHierOI
//UNDVV  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV     TraceLineV( "(nCase=3) DropView( vSourcePreviousHierOI ): ",
//UNDVV                 vSourcePreviousHierOI )
//UNDVV  END
      // DropViewTrace( "Dropping view (1): ", vSourcePreviousHierOI )
         DropView( vSourcePreviousHierOI )
         vSourcePreviousHierOI = 0
      END

      vSourcePreviousHierOI = vSourceCurrentHierOI
      NAME VIEW vSourcePreviousHierOI "TZ_SourcePreviousHierOI"
   // CreateViewTrace( "Creating view (1): ", vSourceCurrentHierOI, vSourceHierOI, 0 )
      CreateViewFromViewForTask( vSourceCurrentHierOI, vSourceHierOI, 0 )
      NAME VIEW vSourceCurrentHierOI "TZ_SourceCurrentHierOI"
   END

   IF lPageNbr > 1 AND lCurrentPagePrinted = lPageNbr

      // 4. We are staying on the same page (for example zoom).
      //    Reset Next view to Current.
      nCase = 4

//UNDVV  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV     TraceLineV( "(nCase=4) DropView( vSourceHierOI ): ",
//UNDVV                 vSourceHierOI )
//UNDVV  END
   // DropViewTrace( "Dropping view (2): ", vSourceHierOI )
      DropView( vSourceHierOI )
   // CreateViewTrace( "Creating view (2): ", vSourceHierOI, vSourceCurrentHierOI, 0 )
      CreateViewFromViewForTask( vSourceHierOI, vSourceCurrentHierOI, 0 )
      NAME VIEW vSourceHierOI "TZ_SourceHierOI"
      SET CURSOR FIRST vReportDef.PageState WHERE
                       vReportDef.PageState.PageNbr = nPreviousPageNbr
      szCurrentEntityName = vReportDef.PageState.CurrentEntityName
      DefineHierarchicalCursor( vSourceHierOI, szCurrentEntityName )
      SET CURSOR FIRST vReportDef.GroupSet WHERE
                       vReportDef.GroupSet.Tag = szCurrentEntityName
   END

   IF lPageNbr > 1 AND
      lPageNbr < lCurrentPagePrinted

      IF vSourceCurrentHierOI != vSourcePreviousHierOI

         // 5. We are going to the previous page and we have a view to
         //    previous page position.  Reset Current and Next views.
         //    Previous view remains the same.
         nCase = 5

//UNDVV  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV     lTempView = MakeIntegerFromView( vSourceHierOI )
//UNDVV     TraceLineV( "(nCase=5) DropView( vSourceHierOI ): ",
//UNDVV                 vSourceHierOI )
//UNDVV  END
      // DropViewTrace( "Dropping view (3): ", vSourceHierOI )
         DropView( vSourceHierOI )
      // CreateViewTrace( "Creating view (3): ", vSourceHierOI, vSourcePreviousHierOI, 0 )
         CreateViewFromViewForTask( vSourceHierOI, vSourcePreviousHierOI, 0 )
         NAME VIEW vSourceHierOI "TZ_SourceHierOI"
         nPreviousPageNbr = nPreviousPageNbr
         SET CURSOR FIRST vReportDef.PageState WHERE
                          vReportDef.PageState.PageNbr = nPreviousPageNbr
         szCurrentEntityName = vReportDef.PageState.CurrentEntityName
         DefineHierarchicalCursor( vSourceHierOI, szCurrentEntityName )
         SET CURSOR FIRST vReportDef.GroupSet WHERE
                          vReportDef.GroupSet.Tag = szCurrentEntityName
//UNDVV  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV     TraceLineV( "(nCase=5) DropView( vSourceCurrentHierOI ): ",
//UNDVV                 vSourceCurrentHierOI )
//UNDVV  END
      // DropViewTrace( "Dropping view (4): ", vSourceCurrentHierOI )
         DropView( vSourceCurrentHierOI )
         vSourceCurrentHierOI = vSourcePreviousHierOI
         NAME VIEW vSourceCurrentHierOI "TZ_SourceCurrentHierOI"

      ELSE

         // 6. We are going to the previous page and we DON'T have a view to
         //    previous page position.
         nCase = 6

      END
   END

   IF lPageNbr = 0

      // 7. We are only counting pages.
      nCase = 7
   END

   IF vSourceHierOI != 0
      bValidView = IsValidView( vSourceHierOI )
      IF bValidView = 0
         bValidView = bValidView / bValidView
      END
   END

   IF nCase = 3 OR
      nCase = 4 OR
      nCase = 5

      // Cases 3, 4 and 5

      // INITIALIZE PAGE INFORMATION FOR NEXT PAGE, CURRENT PAGE, OR
      // SINGLE PREVIOUS PAGE

      // Delete all state entities for this page and beyond.
      fnPageStateRemove( vReportDef, lPageNbr )

      // Retrieve state information from the report definition for the
      // current page (from the final state of the previous page).
      SET CURSOR FIRST vReportDef.PageState WHERE
                       vReportDef.PageState.PageNbr = nPreviousPageNbr
      IF RESULT >= zCURSOR_SET
         lEntityKey = vReportDef.PageState.AbsolutePos
         bForcePageBreak = vReportDef.PageState.ForcePageBreak
         vFooterDidNotFit = vReportDef.PageState.FooterDidNotFit

      // IF vFooterDidNotFit != 0
      //    bValidView = IsValidView( vFooterDidNotFit )
      //    IF bValidView = FALSE
      //       NAME VIEW vReportDef "DKS_PageState.FooterDidNotFit"
      //    // bValidView = bValidView / bValidView
      //       TraceLineV( "FooterDidNotFit View is Invalid (0): ", vFooterDidNotFit )
      //    // SysMessageBox( vSubtask, "PageState.FooterDidNotFit", "Invalid View 0", TRUE )
      //    ELSE
      //       TraceLineV( "FooterDidNotFit View is Valid (0): ", vFooterDidNotFit )
      //    END
      // END

         lHierRC = vReportDef.PageState.HierReturnCode
         lStartLevel = vReportDef.PageState.StartLevel
         lLastLevel = vReportDef.PageState.LastLevel
         lMultiLineTextPos = vReportDef.PageState.MultiLineTextPosEndPage
         lContinuedGroupFlag = vReportDef.PageState.ContinuedGroupFlagEndPage
         szRptContinuedControlTag = vReportDef.PageState.ContinuedControlTagEndPage
         szCurrentEntityName = vReportDef.PageState.CurrentEntityName
         szRptGroupSetTag = vReportDef.PageState.GroupSetTag
         szRptGroupTag = vReportDef.PageState.GroupTag
         nRC = zCURSOR_SET
      END

      // Initialize state for this page.
      fnPageStateAdd( vReportDef, lPageNbr )
      vReportDef.Report.CurrentPageNbr = lPageNbr

      // Restore current page state information to the report definition.
      vReportDef.Report.AbsolutePos = lEntityKey
      vReportDef.Report.ForcePageBreak = bForcePageBreak

      vTemp = vReportDef.Report.FooterDidNotFit
      IF vTemp != 0
      // DropViewTrace( "Dropping view (4a): ", vTemp )
         DropView( vTemp )
         vTemp = 0
      END

      IF vFooterDidNotFit != 0
      // bValidView = IsValidView( vFooterDidNotFit )
      // IF bValidView = FALSE
      // // bValidView = bValidView / bValidView
      //    TraceLineV( "FooterDidNotFit View is Invalid (1): ", vFooterDidNotFit )
      // // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 1", TRUE )
      // ELSE
      //    TraceLineV( "FooterDidNotFit View is Valid (1): ", vFooterDidNotFit )
      // END

      // CreateViewTrace( "Creating view (4a): ", vTemp, vFooterDidNotFit, 0 )
         CreateViewFromViewForTask( vTemp, vFooterDidNotFit, 0 )
         lTempView = MakeIntegerFromView( vTemp )

      ELSE

         lTempView = 0

      END

      vReportDef.Report.FooterDidNotFit = lTempView
      vReportDef.Report.HierReturnCode = lHierRC
      vReportDef.Report.StartLevel = lStartLevel
      vReportDef.Report.LastLevel = lLastLevel
      vReportDef.Report.CurrentEntityName = szCurrentEntityName
      vReportDef.Report.GroupSetTag = szRptGroupSetTag
      vReportDef.Report.GroupTag = szRptGroupTag

   ELSE

      // Cases 1, 2, 6 and 7

      // INITIALIZE PAGE ONE

      // We get here for every case except for paging to the next page.
      // Note: this includes when skipping to a particular page to print.
      // On page one, we don't want any existing vSourceHierOI view, so if
      // it exists from prior report, delete it.
      // If vSourceHierOI = 0, we have no data for the report but will have
      // gotton here anyway.
      IF vSourceHierOI != 0
         DropHierarchicalCursor( vSourceHierOI )
//UNDVV  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV     TraceLineV( "(Cases 1, 2, 6 and 7) DropView( vSourceHierOI ): ",
//UNDVV                 vSourceHierOI )
//UNDVV  END

      // DropViewTrace( "Dropping view (5): ", vSourceHierOI )
         DropView( vSourceHierOI )
         vSourceHierOI = 0
      END

      // Create a special view for hierarchical processing.
      nRC = CheckExistenceOfEntity( vSourceOI, szSubobjectEntityName )
      IF nRC = 0
      // CreateViewTrace( "Creating view (4): ", vSourceHierOI, vSourceOI, 0 )
         CreateViewFromViewForTask( vSourceHierOI, vSourceOI, 0 )
         DefineHierarchicalCursor( vSourceHierOI, szSubobjectEntityName )
         NAME VIEW vSourceHierOI "TZ_SourceHierOI"

         // Drop Previous and Current views, if they exist.
      // GET VIEW vSourceCurrentHierOI NAMED "TZ_SourceCurrentHierOI"
         szViewName = "TZ_SourceCurrentHierOI"
         nRC = GetViewByName( vSourceCurrentHierOI, szViewName,
                              vSubtask, zLEVEL_ANY )
         IF nRC > 0
//UNDVV     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV        TraceLineV( "(NAMED TZ_SourceCurrentHierOI) "
//UNDVV                      "DropView( vSourceCurrentHierOI ): ",
//UNDVV                    vSourceCurrentHierOI )
//UNDVV     END
         // DropViewTrace( "Dropping view (6): ", vSourceCurrentHierOI )
            DropView( vSourceCurrentHierOI )
            vSourceCurrentHierOI = 0
         END

      // GET VIEW vSourcePreviousHierOI NAMED "TZ_SourcePreviousHierOI"
         szViewName = "TZ_SourcePreviousHierOI"
         nRC = GetViewByName( vSourcePreviousHierOI, szViewName,
                              vSubtask, zLEVEL_ANY )
         IF nRC > 0
//UNDVV     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV        TraceLineV( "(NAMED TZ_SourcePreviousHierOI) "
//UNDVV                      "DropView( vSourcePreviousHierOI ): ",
//UNDVV                    vSourcePreviousHierOI )
//UNDVV     END
         // DropViewTrace( "Dropping view (7): ", vSourcePreviousHierOI )
            DropView( vSourcePreviousHierOI )
            vSourcePreviousHierOI = 0
         END

         // Initialize Previous and Current views.
      // CreateViewTrace( "Creating view (6): ", vSourceCurrentHierOI, vSourceHierOI, 0 )
         CreateViewFromViewForTask( vSourceCurrentHierOI, vSourceHierOI, 0 )
         NAME VIEW vSourceCurrentHierOI "TZ_SourceCurrentHierOI"
      // CreateViewTrace( "Creating view (7): ", vSourcePreviousHierOI, vSourceHierOI, 0 )
         CreateViewFromViewForTask( vSourcePreviousHierOI, vSourceHierOI, 0 )
         NAME VIEW vSourcePreviousHierOI "TZ_SourcePreviousHierOI"
      ELSE
         // If we get here, we didn't have any data and we want to print a
         // page with no details.  Our trigger for this will be a zero value
         // for vSourceHierOI.
         TraceLineS( "Report Entity not found: ", szSubobjectEntityName )
         vSourceHierOI = 0
      END

      // Initialize lNextPagePrinted to be page one.
      lNextPagePrinted = 1

      lMultiLineTextPos = 0
      lContinuedGroupFlag = 0

      // Before going to format the first page on the report, position on the
      // first entity in vSourceHierOI that is to be formatted on the report
      // and on the corresponding ReportDef entry.
      ResetView( vReportDef )
      szCurrentEntityName = szSubobjectEntityName
      SET CURSOR FIRST vReportDef.GroupSet WHERE
                       vReportDef.GroupSet.Tag = szSubobjectEntityName
      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST vReportDef.Group WHERE
                          vReportDef.Group.Type = "ga"
      ELSE
      // TraceLineS( "FormatDocPage unable to locate GroupSet: ",
      //             szCurrentEntityName )
      END

      // Delete all state entities except for page 0.
      fnPageStateRemove( vReportDef, 1 )

      // Set up initial information, particularly for the hierarchical entity
      // on which we are positioned at the beginning of page one.
      // vSourceHierOI was set to zero if we were printing an empty page
      // (meaning there was no data to print).
      IF vSourceHierOI != 0
         GetEntityKeyForHierarchicalCsr( lStartLevel, szCurrentEntityName,
                                         lEntityKey, vSourceHierOI )
      ELSE
         lReturnLevel = 1
         lStartLevel  = 1
         lEntityKey = -1
         szHierEntityName = ""
      END

      vReportDef.Report.AbsolutePos = lEntityKey
      vReportDef.Report.ForcePageBreak = bForcePageBreak

      vTemp = vReportDef.Report.FooterDidNotFit
      IF vTemp != 0
      // DropViewTrace( "Dropping view (4b): ", vTemp )
         DropView( vTemp )
         vTemp = 0
      END

      IF vFooterDidNotFit != 0
      // bValidView = IsValidView( vFooterDidNotFit )
      // IF bValidView = FALSE
      // // bValidView = bValidView / bValidView
      //    TraceLineV( "FooterDidNotFit View is Invalid (2): ", vFooterDidNotFit )
      // // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 2", TRUE )
      // ELSE
      //    TraceLineV( "FooterDidNotFit View is Valid (2): ", vFooterDidNotFit )
      // END

      // CreateViewTrace( "Creating view (4b): ", vTemp, vFooterDidNotFit, 0 )
         CreateViewFromViewForTask( vTemp, vFooterDidNotFit, 0 )
         lTempView = MakeIntegerFromView( vTemp )

      ELSE

         lTempView = 0

      END

      vReportDef.Report.FooterDidNotFit = lTempView
      vReportDef.Report.HierReturnCode = lStartLevel
      vReportDef.Report.CurrentEntityName = szCurrentEntityName
      vReportDef.Report.StartLevel = lStartLevel
      vReportDef.Report.LastLevel = lStartLevel
      vReportDef.Report.CurrentPageNbr = 1
      vReportDef.Report.GroupSetTag = szRptGroupSetTag
      vReportDef.Report.GroupTag = szRptGroupTag
      SetMatchingAttributesByName( vReportDef, "PageState",
                                   vReportDef, "Report", zSET_ALL )

//UNDEF IF szHierEntityName != szCurrentEntityName
//UNDEF    TraceLineS( "Reset Position entity names differ: ",
//UNDEF                szHierEntityName )
//UNDEF    TraceLineS( "                  CurrentEntityName ",
//UNDEF                szCurrentEntityName )
//UNDEF END

      // The code to create a Footer was deleted here by DC on 21.02.01.

   END

   nPageCnt = 0  // count pages for Phantom mode
   nRC = 1       // Initialize nRC to indicate there are pages to print.

   //////////////////////////////////////////////////////////////////////////
   //
   // PHANTOM PRINT
   //
   //////////////////////////////////////////////////////////////////////////

   IF nCase = 2 OR
      nCase = 6 OR
      nCase = 7

      // Cases 2, 6 and 7

      // For case 2 and 6, we need to skip pages until we get to lPageNbr.
      // For case 7, we need to go through all pages

      IF nCase = 7
         lNextPagePrinted = -1
      END

      SetPhantomMode( vSubtask, 1 )  // print phantom pages as necessary
      LOOP WHILE lNextPagePrinted < lPageNbr AND nRC > 0

         nPageCnt = nPageCnt + 1

         IF lNextPagePrinted > 0
            lWork = lNextPagePrinted
         ELSE
            lWork = nPageCnt
         END

         SET CURSOR FIRST vReportDef.PageState WHERE
                          vReportDef.PageState.PageNbr = lWork
         IF RESULT < zCURSOR_SET
            fnPageStateAdd( vReportDef, lWork )
         END

         ////////////////////////////////////////////////////////////////////
         //
         // Print the page.
         //
         ////////////////////////////////////////////////////////////////////
         // Use the page number as specified in the call to this function.
   //UNDEF TraceLineI( "Phantom mode for page: ", lWork )
         vReportDef.Report.CurrentPageNbr = lWork
         nRC = PrintPage( vSubtask, vSourceHierOI, vReportDef,
                          lWork, lPageWidth, lPageHeight,
                          szRptGroupSetTag, szRptGroupTag,
                          -2147483648 )  // 0x80000000  phantom print page counting

         // Reset Previous and Current views.
//UNDVV     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV        TraceLineV( "(Reset Previous) DropView( vSourcePreviousHierOI ): ",
//UNDVV                    vSourcePreviousHierOI )
//UNDVV     END
      // DropViewTrace( "Dropping view (7a): ", vSourcePreviousHierOI )
         DropView( vSourcePreviousHierOI )
         vSourcePreviousHierOI = vSourceCurrentHierOI
      // CreateViewTrace( "Creating view (8): ", vSourceCurrentHierOI, vSourceHierOI, 0 )
         CreateViewFromViewForTask( vSourceCurrentHierOI, vSourceHierOI, 0 )

         // Set up cursor information for the next page.
         IF ( nRC > 0 )

            GetEntityKeyForHierarchicalCsr( lReturnLevel, szHierEntityName,
                                            lEntityKey, vSourceHierOI )
   //UNDEF  TraceLineS( "          Entity Name: ", szHierEntityName )
   //UNDEF  TraceLineI( "          Entity Key: ", lEntityKey )

            // Retrieve initialization information from the report definition.
         // lEntityKey = vReportDef.Report.AbsolutePos
            bForcePageBreak = vReportDef.Report.ForcePageBreak
            vFooterDidNotFit = vReportDef.Report.FooterDidNotFit

         // IF vFooterDidNotFit != 0
         //    bValidView = IsValidView( vFooterDidNotFit )
         //    IF bValidView = FALSE
         //       NAME VIEW vReportDef "DKS_PageState.FooterDidNotFit"
         //    // bValidView = bValidView / bValidView
         //       TraceLineV( "FooterDidNotFit View is Invalid (3): ", vFooterDidNotFit )
         //    // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 3", TRUE )
         //    ELSE
         //       TraceLineV( "FooterDidNotFit View is Valid (3): ", vFooterDidNotFit )
         //    END
         // END

            lHierRC = vReportDef.Report.HierReturnCode
            lStartLevel = vReportDef.Report.StartLevel
            lLastLevel = vReportDef.Report.LastLevel
            lMultiLineTextPos = vReportDef.PageState.MultiLineTextPosEndPage
            lContinuedGroupFlag =
                              vReportDef.PageState.ContinuedGroupFlagEndPage
            szRptContinuedControlTag =
                             vReportDef.PageState.ContinuedControlTagEndPage
         // szCurrentEntityName = vReportDef.Report.CurrentEntityName

         // IF lPageNbr = 4 OR lPageNbr = 5
         //    TraceLineI( "FormatDocPage Standard PageNbr: ", lPageNbr )
         // END

            // Initialize state for next page
            vReportDef.PageState.AbsolutePos = lEntityKey
            vReportDef.PageState.ForcePageBreak = bForcePageBreak

            vTemp = vReportDef.PageState.FooterDidNotFit
            IF vTemp != 0
            // DropViewTrace( "Dropping view (4c): ", vTemp )
               DropView( vTemp )
               vTemp = 0
            END

            IF vFooterDidNotFit != 0
            // bValidView = IsValidView( vFooterDidNotFit )
            // IF bValidView = FALSE
            // // bValidView = bValidView / bValidView
            //    TraceLineV( "FooterDidNotFit View is Invalid (4): ", vFooterDidNotFit )
            // // SysMessageBox( vSubtask, "PageState.FooterDidNotFit", "Invalid View 4", TRUE )
            // ELSE
            //    TraceLineV( "FooterDidNotFit View is Valid (4): ", vFooterDidNotFit )
            // END

            // CreateViewTrace( "Creating view (4c): ", vTemp, vFooterDidNotFit, 0 )
               CreateViewFromViewForTask( vTemp, vFooterDidNotFit, 0 )
               lTempView = MakeIntegerFromView( vTemp )

            ELSE

               lTempView = 0

            END

            vReportDef.PageState.FooterDidNotFit = lTempView
            vReportDef.PageState.HierReturnCode = lHierRC
            vReportDef.PageState.StartLevel = lStartLevel
            vReportDef.PageState.LastLevel = lLastLevel
            vReportDef.PageState.CurrentEntityName = szHierEntityName
            vReportDef.PageState.GroupSetTag = szRptGroupSetTag
            vReportDef.PageState.GroupTag = szRptGroupTag

         END

   //UNDEF TraceLineI( "Phantom mode ======= RC: ", nRC )

         IF lPageNbr > 0
            lNextPagePrinted = lNextPagePrinted + 1
         END
      END

      SetPhantomMode( vSubtask, 0 ) // Reset from Phantom mode to Real mode.

      // Name Previous and Current views.
      NAME VIEW vSourcePreviousHierOI "TZ_SourcePreviousHierOI"
      NAME VIEW vSourceCurrentHierOI  "TZ_SourceCurrentHierOI"

   END

   // Return with the page count when only counting pages.
   IF nCase = 7

      nRC = IsFlagSequenceSet( lPrintFlags, 8 )
      IF nRC != 0
         SetCursorFirstEntity( vSourceOI, szSubobjectEntityName, 0 )
      END

//UNDVV     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV        TraceLineV( "(nCase=7) DropView( vSourcePreviousHierOI ): ",
//UNDVV                    vSourcePreviousHierOI )
//UNDVV     END
   // DropViewTrace( "Dropping view (8): ", vSourcePreviousHierOI )
      DropView( vSourcePreviousHierOI )
      vSourcePreviousHierOI = 0

//UNDVV     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV        TraceLineV( "(nCase=7) DropView( vSourceCurrentHierOI ): ",
//UNDVV                    vSourceCurrentHierOI )
//UNDVV     END

   // DropViewTrace( "Dropping view (9): ", vSourceCurrentHierOI )
      DropView( vSourceCurrentHierOI )
      vSourceCurrentHierOI = 0

      vReportDef.Report.TotalPageCnt = nPageCnt
      RETURN 0
   END

   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //
   // PRINT REAL PAGES
   //
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////

   // nRC is greater than zero when there are pages to print.

   IF vSourceHierOI != 0
      bValidView = IsValidView( vSourceHierOI )
      IF bValidView = 0
         bValidView = bValidView / bValidView
      END
   END

   IF nRC > 0

//UNDEF  TraceLineI( "Standard mode for page: ", lPageNbr )

      SET CURSOR FIRST vReportDef.PageState WHERE
                       vReportDef.PageState.PageNbr = lPageNbr
      IF RESULT < zCURSOR_SET
         fnPageStateAdd( vReportDef, lPageNbr )
      END

      ///////////////////////////////////////////////////////////////////////
      //
      // Print the page.
      //
      ///////////////////////////////////////////////////////////////////////
      vReportDef.Report.CurrentPageNbr = lPageNbr
      nRC = PrintPage( vSubtask, vSourceHierOI, vReportDef,
                       lPageNbr, lPageWidth, lPageHeight,
                       szRptGroupSetTag, szRptGroupTag,
                       0 )  // PRINT REAL PAGES

      lPrintFlags = vReportDef.Report.PrintFlags
      lWork = IsFlagSequenceSet( lPrintFlags, 256 )    // HTML
      IF lWork = 0
         lWork = IsFlagSequenceSet( lPrintFlags, 128 ) // CSV
      END

      IF lWork != 0
         lPrintFlags = SetFlagSequence( lPrintFlags,
                                        384,  // turn off HTML and CSV
                                        0 )
         vReportDef.Report.PrintFlags = lPrintFlags

         CloseReport( vSubtask, 3 )
         RETURN 0   // we are all done
      END

      // Set up cursor information for the next page, if there is one.
      IF ( nRC > 0 )

         GetEntityKeyForHierarchicalCsr( lReturnLevel, szHierEntityName,
                                         lEntityKey, vSourceHierOI )

         // Retrieve initialization information from the report definition.
      // lEntityKey = vReportDef.Report.AbsolutePos
         bForcePageBreak = vReportDef.Report.ForcePageBreak
         vFooterDidNotFit = vReportDef.Report.FooterDidNotFit

      // IF vFooterDidNotFit != 0
      //    bValidView = IsValidView( vFooterDidNotFit )
      //    IF bValidView = FALSE
      //       NAME VIEW vReportDef "DKS_PageState.FooterDidNotFit"
      //    // bValidView = bValidView / bValidView
      //       TraceLineV( "FooterDidNotFit View is Invalid (5): ", vFooterDidNotFit )
      //    // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 5", TRUE )
      //    ELSE
      //       TraceLineV( "FooterDidNotFit View is Valid (5): ", vFooterDidNotFit )
      //    END
      // END

         lHierRC = vReportDef.Report.HierReturnCode
         lStartLevel = vReportDef.Report.StartLevel
         lLastLevel = vReportDef.Report.LastLevel
      // szCurrentEntityName = vReportDef.Report.CurrentEntityName

//UNDEF  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF     TraceLineS( "FormatDocPage **END**: ",
//UNDEF                 "After PrintPage indicates more pages." )
//UNDEF     TraceLineI( "                 Page #: ", lPageNbr )
//UNDEF     TraceLineS( "       Hier Entity Name: ", szHierEntityName )
//UNDEF     TraceLineS( "       Curr Entity Name: ", szCurrentEntityName )
//UNDEF     TraceLineI( "            EntityKey: ", lEntityKey )
//UNDEF     TraceLineI( "    MultiLineTextPosEnd: ",
//UNDEF                 vReportDef.PageState.MultiLineTextPosEndPage )
//UNDEF     TraceLineI( "  ContinuedGroupFlagEnd: ",
//UNDEF                 vReportDef.PageState.ContinuedGroupFlagEndPage )
//UNDEF  // DisplayEntityInstance( vSourceHierOI, szHierEntityName )
//UNDEF  END

         // Initialize state for next page
         vReportDef.PageState.AbsolutePos = lEntityKey
         vReportDef.PageState.ForcePageBreak = bForcePageBreak

         vTemp = vReportDef.PageState.FooterDidNotFit
         IF vTemp != 0
         // DropViewTrace( "Dropping view (4a): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

         IF vFooterDidNotFit != 0
         // bValidView = IsValidView( vFooterDidNotFit )
         // IF bValidView = FALSE
         // // bValidView = bValidView / bValidView
         //    TraceLineV( "FooterDidNotFit View is Invalid (6): ", vFooterDidNotFit )
         // // SysMessageBox( vSubtask, "PageState.FooterDidNotFit", "Invalid View 6", TRUE )
         // ELSE
         //    TraceLineV( "FooterDidNotFit View is Valid (6): ", vFooterDidNotFit )
         // END

         // CreateViewTrace( "Creating view (4d): ", vTemp, vFooterDidNotFit, 0 )
            CreateViewFromViewForTask( vTemp, vFooterDidNotFit, 0 )
            lTempView = MakeIntegerFromView( vTemp )

         ELSE

            lTempView = 0

         END

         vReportDef.PageState.FooterDidNotFit = lTempView
         vReportDef.PageState.HierReturnCode = lHierRC
         vReportDef.PageState.StartLevel = lStartLevel
         vReportDef.PageState.LastLevel = lLastLevel
         vReportDef.PageState.CurrentEntityName = szHierEntityName
         vReportDef.PageState.GroupSetTag = szRptGroupSetTag
         vReportDef.PageState.GroupTag = szRptGroupTag

      END

//UNDEF TraceLineI( "FormatDocPage End PageNbr: ", lPageNbr )
//UNDEF TraceLineI( " Standard mode ******* RC: ", nRC )

   END

   RETURN nRC
END

//DKS  LOCAL OPERATION
//DKS  DisplayFooterInfo( VIEW vReportDef, STRING( 128 ) szMsg, INTEGER lPageNbr )
//DKS
//DKS  VIEW vFooterHierOI
//DKS  STRING (32) szCurrentEntityName
//DKS
//DKS     TraceLineS( "==============================================", "" )
//DKS     SET CURSOR FIRST vReportDef.FooterAtLevel
//DKS     TraceLineI( szMsg, lPageNbr )
//DKS     LOOP WHILE RESULT >= zCURSOR_SET
//DKS        DisplayEntityInstance( vReportDef, "FooterAtLevel" )
//DKS        TraceLineS( "", "" )
//DKS        GetViewFromAttribute( vFooterHierOI, vReportDef,
//DKS                              "FooterAtLevel", "vSourceOI_Hier" )
//DKS        GetStringFromAttribute( szCurrentEntityName, vReportDef,
//DKS                                "FooterAtLevel", "EntityName" )
//DKS        DisplayEntityInstance( vFooterHierOI, szCurrentEntityName )
//DKS        SET CURSOR NEXT vReportDef.FooterAtLevel WHERE
//DKS            vReportDef.FooterAtLevel.EntityName = szCurrentEntityName
//DKS     END
//DKS
//DKS     TraceLineS( "", "" )
//DKS     TraceLineS( "@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@", "" )
//DKS     TraceLineS( "", "" )
//DKS  END

LOCAL OPERATION
PrintPage( VIEW    vSubtask,
           VIEW    vSourceHierOI,
           VIEW    vReportDef BASED ON LOD TZRPSRCO,
           INTEGER lPageNbr,
           INTEGER lPageWidth,
           INTEGER lPageHeight,
           STRING (32) szRptGroupSetTag,
           STRING (32) szRptGroupTag,
           INTEGER lFlags )

   VIEW        vFooterHierOI
   INTEGER     bForcePageBreak
   VIEW        vFooterDidNotFit
   VIEW        vTempOI
   VIEW        vTemp
   INTEGER     lCurrentPosX
   INTEGER     lCurrentPosY
   VIEW        vHeaderDef         BASED ON LOD TZRPSRCO
   VIEW        vPageHeaderDef     BASED ON LOD TZRPSRCO
   VIEW        vFooterDef         BASED ON LOD TZRPSRCO
   STRING (32) szCurrentEntityName
   STRING (32) szHoldEntityName
   STRING (32) szSubobjectEntityName
   STRING (32) szLastHeaderEntityNameAtLevel
   SHORT       nReturnLevel      // parameter for function
                                 // SetCursorNextEntityHierarchical
                                 // lReturnLevel will be set to this value
   STRING (32) szRepeatHorizontalEntityName
   INTEGER     lTotalPages
   INTEGER     lEntityKey
   INTEGER     lPosYHold
   INTEGER     lRepeatHorizontalHold
   INTEGER     lRepeatHorizontal
   INTEGER     lRepeatHorizontalTemp
   INTEGER     lRepeatHorizontalFlags
   INTEGER     lRepeatHorizontalColumn
   INTEGER     lRepeatHorizontalIndent
   INTEGER     lRepeatHorizontalMargin
   INTEGER     lRepeatHorizontalExtent
   INTEGER     lRepeatHorizontalNewspaper
   INTEGER     lViewPortBottomPrev
   INTEGER     lViewPortTop
   INTEGER     lViewPortBottom
   INTEGER     lViewPortLeft
   INTEGER     lViewPortRight
   INTEGER     lReturnLevel
   INTEGER     lAbsolutePosition
   INTEGER     lHierRC
   INTEGER     lLastLevel
   INTEGER     lTempLevel
   INTEGER     lIncrPosX
   INTEGER     lNewPosX
   INTEGER     lNewPosY
   INTEGER     lBottomOfPage
   INTEGER     lFooterPosY
   INTEGER     lRemainingSpaceOnPageX
   INTEGER     lRemainingSpaceOnPageY
   INTEGER     lOrigRemainingSpaceOnPageX
   INTEGER     lOrigRemainingSpaceOnPageY
   INTEGER     lGroupTotal
   INTEGER     lFooterHeight
   INTEGER     lContinuedGroupFlag
   INTEGER     lTempView
   INTEGER     lTemp
   INTEGER     lDksLevel
   INTEGER     lDksKey
   INTEGER     lResetPageNbr
   INTEGER     lResetTotalPageCnt
   STRING (32) szPageNumber
   INTEGER     lStartLevel
   INTEGER     lPrintFlags
   INTEGER     lPrintHTML
   INTEGER     lMultiRootFlag
   INTEGER     lPrintFooterUsingHeaderView
   INTEGER     lFirstEntityOnReportFlag
   INTEGER     bValidView
   STRING (32) szHierEntityName
   INTEGER     nGroupSuppressedForPage
   INTEGER     nRC_GP
   STRING (32) szINI
   SHORT       nRC
//UNDEF INTEGER       lFirstTime
//UNDEF INTEGER       lTempValue

//UNDEF lFirstTime = 0
   NAME VIEW vReportDef "CurrentReportDef"
   lRepeatHorizontal = 0
   lRepeatHorizontalIndent = 0
   lCurrentPosX = 0
   lCurrentPosY = 0
   lStartLevel = vReportDef.Report.StartLevel
   lPrintFlags = vReportDef.Report.PrintFlags

   nRC = IsFlagSequenceSet( lPrintFlags, 256 )
   IF nRC != 0
      lPrintHTML = 1
      lPageHeight = 2147483647  // BIG Number!!!
   ELSE
      lPrintHTML = 0
   END

   nRC = IsFlagSequenceSet( lPrintFlags, 2048 ) // print PageFooter using PageHeader view
   IF nRC != 0
      lPrintFooterUsingHeaderView = 1
   ELSE
      lPrintFooterUsingHeaderView = 0
   END

   IF vSourceHierOI != 0
      bValidView = IsValidView( vSourceHierOI )
      IF bValidView = 0
         SysMessageBox( vSubtask, "Report Writer", "Invalid Hierarchical View", TRUE )
         bValidView = bValidView / bValidView
      END
   END

   szSubobjectEntityName = vReportDef.Report.WK_SubobjectEntityName
   lHierRC = vReportDef.Report.HierReturnCode
   bForcePageBreak = vReportDef.Report.ForcePageBreak
   vFooterDidNotFit = vReportDef.Report.FooterDidNotFit

// IF vFooterDidNotFit != 0
//    bValidView = IsValidView( vFooterDidNotFit )
//    IF bValidView = FALSE
//    // bValidView = bValidView / bValidView
//       TraceLineV( "FooterDidNotFit View is Invalid (7): ", vFooterDidNotFit )
//    // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 7", TRUE )
//    ELSE
//       TraceLineV( "FooterDidNotFit View is Valid (7): ", vFooterDidNotFit )
//    END
// END

// IF lPageNbr = 1 OR vReportDef.Report.ForcePageBreak = "Y"
   IF vSourceHierOI != 0
      CreateViewFromViewForTask( vTemp, vSourceHierOI, 0 )
      GetEntityKeyForHierarchicalCsr( lReturnLevel, szCurrentEntityName,
                                      lEntityKey,  vSourceHierOI )

      SetEntityCursor( vTemp, szCurrentEntityName, 0,
                       zQUAL_ENTITYKEY + zPOS_FIRST,
                       lEntityKey, 0, 0, 0, 0, 0 )
      lEntityKey = GetEntityKey( vTemp, szSubobjectEntityName )
      DropView( vTemp )

   ELSE
      lEntityKey = 0
   END

   lTemp = lFlags + 1073741824  // + 0x40000000 ==> set up page numbering
   lResetTotalPageCnt = lTotalPages
   lResetPageNbr = HandlePageNumbering( vSubtask, szPageNumber, lEntityKey,
                                        lPageNbr, lResetTotalPageCnt, lTemp )

   lLastLevel = vReportDef.Report.LastLevel
   lReturnLevel = lLastLevel

// szCurrentEntityName = ""
   szCurrentEntityName = vReportDef.Report.CurrentEntityName

   IF lPageNbr = 1
      lFirstEntityOnReportFlag = 1
   ELSE
      lFirstEntityOnReportFlag = 0

//DKS  DisplayFooterInfo( vReportDef,
//DKS                     "PrintPage FooterAtLevel @PageNbr: ",
//DKS                     lPageNbr )

      // We want to delete any FooterAtLevel that has not been set to
      // Complete = 'Y', since the entity is created as a place holder.
      // Once Complete has been turned to 'Y', the  FooterAtLevel is
      // "good", or if Complete is blank, the FooterAtLevel entity was
      // created at a point where it is known the footer is required
      // at an appropriate future condition.
   // CreateViewTrace( "Creating view (9): ", vFooterDef, vReportDef, 0 )
      CreateViewFromViewForTask( vFooterDef, vReportDef, 0 )
      SET CURSOR FIRST vFooterDef.FooterAtLevel WHERE
          vFooterDef.FooterAtLevel.Complete = "N"
      LOOP WHILE RESULT >= zCURSOR_SET

         vTemp = vFooterDef.FooterAtLevel.SourceOI_Hier
         IF vTemp != 0
         // DropViewTrace( "Dropping view (10a): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

         DELETE ENTITY vFooterDef.FooterAtLevel
         SET CURSOR FIRST vFooterDef.FooterAtLevel WHERE
             vFooterDef.FooterAtLevel.Complete = "N"
      END

      // Set up a Footer entity if one is defined for this entity.
      SET CURSOR FIRST vFooterDef.GroupSet WHERE
                       vFooterDef.GroupSet.Tag = szCurrentEntityName
      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST vFooterDef.Group WHERE
                          vFooterDef.Group.Type = "gf"
      END

      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST vFooterDef.FooterAtLevel WHERE
             vFooterDef.FooterAtLevel.EntityName = szCurrentEntityName
         IF RESULT < zCURSOR_SET
            CREATE ENTITY vFooterDef.FooterAtLevel FIRST
            vFooterDef.FooterAtLevel.Level = lReturnLevel
            vFooterDef.FooterAtLevel.EntityName = szCurrentEntityName
         // CreateViewTrace( "Creating view (10): ", vFooterHierOI, vSourceHierOI, 0 )
            CreateViewFromViewForTask( vFooterHierOI, vSourceHierOI, 0 )

            bValidView = IsValidView( vFooterHierOI )
            IF bValidView = FALSE
               bValidView = bValidView / bValidView
            END

            SetAttributeFromView( vFooterDef, "FooterAtLevel",
                                  "SourceOI_Hier", vFooterHierOI )
            vFooterDef.FooterAtLevel.Complete = "N"  // this used to say vReportDef... dks 2005.06.22
         END
      END
   // DropViewTrace( "Dropping view (10): ", vFooterDef )
      DropView( vFooterDef )
      vFooterDef = 0
   END

//UNDEF TraceLineI( "PrintPage Nbr: ", lPageNbr )
//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineI( "   StartLevel: ", lStartLevel )
//UNDEF    TraceLineI( "   PrintFlags: ", lPrintFlags )
//UNDEF    TraceLineI( "   LastLevel : ", lLastLevel )
//UNDEF    TraceLineS( "   SubobjectEntityName: ", szSubobjectEntityName )
//UNDEF END

   lTotalPages = vReportDef.Report.TotalPageCnt
   lTemp = 1073741824  // 0x40000000 ==> set up page numbering
   lResetTotalPageCnt = lTotalPages
   lResetPageNbr = HandlePageNumbering( vSubtask, szPageNumber, 0,
                                        lPageNbr, lResetTotalPageCnt, lTemp )

   // Set up the height of the page.  If there is to be a Page Footer,
   // subtract that size from the page height.
   // Also set the PosY value for the Footer, since it will not depend on
   // the prior Group.
// CreateViewTrace( "Creating view (11): ", vFooterDef, vReportDef, 0 )
   CreateViewFromViewForTask( vFooterDef, vReportDef, 0 )
   lBottomOfPage = lPageHeight
   SET CURSOR FIRST vFooterDef.GroupSet
              WHERE vFooterDef.GroupSet.Type = "PF"
   IF RESULT >= zCURSOR_SET
      // Check each footer Group and use it if it is not suppressed.
      FOR EACH vFooterDef.Group
            WHERE vFooterDef.Group.Type = "ga"
               OR vFooterDef.Group.Type = "pf"
         nGroupSuppressedForPage = GroupSuppressReason( vFooterDef, lResetPageNbr,
                                                        lResetTotalPageCnt )
         IF nGroupSuppressedForPage <= 0  // Group with no controls reserves space
            lFooterHeight = vFooterDef.Group.SZDLG_Y
            lBottomOfPage = lPageHeight - lFooterHeight

            IF lPrintHTML = 1
               lFooterPosY = lFooterHeight
            ELSE
               lFooterPosY = lBottomOfPage
            END
         END
      END
   END

   lRemainingSpaceOnPageX = lPageWidth
   lRemainingSpaceOnPageY = lBottomOfPage
// DropViewTrace( "Dropping view (11): ", vFooterDef )
   DropView( vFooterDef )
   vFooterDef = 0

   // When starting a page, the first thing to do is process a Page Header,
   // if there is one.  Also set the Page Number control, if there is one.
// CreateViewTrace( "Creating view (12): ", vPageHeaderDef, vReportDef, 0 )
   CreateViewFromViewForTask( vPageHeaderDef, vReportDef, 0 )
   IF lPrintFooterUsingHeaderView > 0
      CreateViewFromViewForTask( vTempOI, vSourceHierOI, 0 )
      NAME VIEW vTempOI "-->HeaderViewForFooter"
   END

   SET CURSOR FIRST vPageHeaderDef.GroupSet WHERE
                    vPageHeaderDef.GroupSet.Type = "PH"
   LOOP WHILE RESULT >= zCURSOR_SET
      // Check if subtype specified for page header.
      nGroupSuppressedForPage = GroupSuppressReason( vPageHeaderDef, lResetPageNbr,
                                                     lResetTotalPageCnt )

      // Only print header stuff if not suppressed.
      IF nGroupSuppressedForPage = 0 //Note: empty Group does NOT reserve space.
         SET CURSOR FIRST vPageHeaderDef.Control WHERE
                          vPageHeaderDef.Control.Tag = "PageNumber"
         IF RESULT >= zCURSOR_SET
            vPageHeaderDef.Control.Text = szPageNumber
         END

//UNDEF  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF     TraceLineS( "FormatGroupOnPage 1: ",
//UNDEF                 vPageHeaderDef.Group.Tag )
//UNDEF  END

         vTempOI = vSourceHierOI
         IF lPageNbr > 1
            vTemp = vReportDef.Report.FooterDidNotFit
            IF vTemp != 0

               vTempOI = vTemp
            // bValidView = IsValidView( vTempOI )
            // IF bValidView = FALSE
            // // bValidView = bValidView / bValidView
            //    TraceLineV( "FooterDidNotFit View is Invalid (8): ", vTempOI )
            // // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 8", TRUE )
            // ELSE
            //    TraceLineV( "FooterDidNotFit View is Valid (8): ", vTempOI )
            // END
            END
         END

         FormatGroupOnPage( vPageHeaderDef, vTempOI, vSubtask,
                            lNewPosX, lNewPosY,
                            lCurrentPosX, lCurrentPosY, lRemainingSpaceOnPageY,
                            0, // continued Group flag 0 ==> not continued
                            lPageWidth, lPageHeight, lRemainingSpaceOnPageY,
                            lBottomOfPage )
         lNewPosX = 0
         lCurrentPosY = lNewPosY
         lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
      END

      SET CURSOR NEXT vPageHeaderDef.Group
   END

   vTempOI = vReportDef.Report.FooterDidNotFit

// IF vTempOI != 0
//    bValidView = IsValidView( vTempOI )
//    IF bValidView = FALSE
//    // bValidView = bValidView / bValidView
//       TraceLineV( "FooterDidNotFit View is Invalid (9): ", vTempOI )
//    // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 9", TRUE )
//    ELSE
//       TraceLineV( "FooterDidNotFit View is Valid (9): ", vTempOI )
//    END
// END

   lPosYHold = lCurrentPosY
   IF lPageNbr > 1 AND vTempOI != 0 AND vReportDef.FooterAtLevel EXISTS

      // Go to reusable routine to process any necessary footers.
      lReturnLevel = vReportDef.Report.LastLevel
      ProcessFooters( vReportDef, vSubtask, szCurrentEntityName,
                      lReturnLevel, lRemainingSpaceOnPageY,
                      lBottomOfPage, lCurrentPosX, lCurrentPosY,
                      lRepeatHorizontalHold,
                      lPageWidth, lPageHeight, 0 )

      IF vReportDef.Report.ForcePageBreak = 0

         vTemp = vReportDef.Report.FooterDidNotFit
         IF vTemp != 0
         // DropViewTrace( "Dropping view (4d): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

         vReportDef.Report.FooterDidNotFit = 0

      ELSE

         // Process a Page Footer if necessary before returning.
         IF lPrintHTML = 1
            lPageHeight = lCurrentPosY + lFooterPosY
            lFooterPosY = lCurrentPosY
         END

         ProcessPageFooter( vReportDef, vTempOI, vSubtask,
                            lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                            lPageWidth, lPageHeight, lFlags )

         vTemp = vReportDef.Report.FooterDidNotFit
         IF vTemp != 0
         // DropViewTrace( "Dropping view (4e): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

         vReportDef.Report.FooterDidNotFit = 0
         vReportDef.Report.ForcePageBreak = 0

         RETURN 1 // return indicating that there are MORE pages

      END
   ELSE
      lRepeatHorizontalHold = 0
   END

   szLastHeaderEntityNameAtLevel = szCurrentEntityName
   IF szCurrentEntityName != ""
      ProcessPgDetailHeadrs( vPageHeaderDef, vSourceHierOI,
                             szCurrentEntityName,
                             vSubtask, lNewPosX, lNewPosY,
                             lCurrentPosX, lCurrentPosY,
                             lRemainingSpaceOnPageY, lBottomOfPage,
                             lPageWidth, lPageHeight )
      lNewPosX = 0

      // If headers were formatted, update current values and indicate that
      // a header was formatted.
      IF lCurrentPosY != lNewPosY
         lCurrentPosY = lNewPosY
         lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
      END
   END

   szLastHeaderEntityNameAtLevel = vReportDef.Report.CurrentEntityName
// DropViewTrace( "Dropping view (12): ", vPageHeaderDef )
   DropView( vPageHeaderDef )
   vPageHeaderDef = 0

//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineI( "FormatGroupOnPage 1 RemainingSpaceOnPage: ",
//UNDEF                lRemainingSpaceOnPageY )
//UNDEF END

   lOrigRemainingSpaceOnPageY = lRemainingSpaceOnPageY

   // MULTI EDIT
   // Complete the formatting of a Group that was only partially
   // completed on the last page.  If such a Group exists, the
   // vReportDef.Report.ContinuedGroupFlag value will be > 0.
   nRC_GP = -2  // Indicates that FormatGroupOnPage not yet called
   IF vReportDef.PageState.ContinuedGroupFlagStartPage > 0

      // First, for a continued group, we may need to print group headers.
      // 01Dec01 - NO - Is done properly above after November fixes
      // BUT JUST IN CASE allow an INI to continue to use this code
      SysReadZeidonIni( -1, "[Debug]",
                        "IgnoreReportFix011201(ExtraDtlHdr)", szINI )
      IF szINI = "Y"
      // szCurrentEntityName = vReportDef.Report.CurrentEntityName
      // CreateViewTrace( "Creating view (13): ", vHeaderDef, vReportDef, 0 )
         CreateViewFromViewForTask( vHeaderDef, vReportDef, 0 )
         SET CURSOR FIRST vHeaderDef.GroupSet WHERE
                          vHeaderDef.GroupSet.Tag = szCurrentEntityName
         IF RESULT >= zCURSOR_SET
            SET CURSOR FIRST vHeaderDef.Group WHERE
                             vHeaderDef.Group.Type = "gh"
         ELSE
            TraceLineS( "PrintPage unable to locate GroupSet: ",
                        szCurrentEntityName )
         END

         IF RESULT >= zCURSOR_SET
//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineS( "FormatGroupOnPage MULTI EDIT header 2: ",
//UNDEF                    vHeaderDef.Group.Tag )
//UNDEF     END

            FormatGroupOnPage( vHeaderDef, vSourceHierOI, vSubtask,
                               lNewPosX, lNewPosY,
                               lCurrentPosX, lCurrentPosY,
                               lRemainingSpaceOnPageY,
                               0, // continued Group flag 0 ==> not continued
                               lPageWidth, lPageHeight,
                               lOrigRemainingSpaceOnPageY,
                               lBottomOfPage )
            lNewPosX = 0
            lCurrentPosY = lNewPosY
            lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
         END

      // DropViewTrace( "Dropping view (13): ", vHeaderDef )
         DropView( vHeaderDef )
         vHeaderDef = 0
      END

      // ==============================================
      // At this point we can print the continued group

      szRptGroupSetTag = vReportDef.GroupSet.Tag
      szRptGroupTag = vReportDef.Group.Tag
//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineS( "FormatGroupOnPage MULTI EDIT 3: ",
//UNDEF                vReportDef.Group.Tag )
//UNDEF END
      nRC_GP = FormatGroupOnPage( vReportDef, vSourceHierOI, vSubtask,
                                  lNewPosX, lNewPosY,
                                  lCurrentPosX, lCurrentPosY,
                                  lRemainingSpaceOnPageY,
                                  1, // continued Group flag 1 ==> continued
                                  lPageWidth, lPageHeight,
                                  lOrigRemainingSpaceOnPageY,
                                  lBottomOfPage )
      lNewPosX = 0
   ELSE
      //====================
      // Group was not continued to this page
      //====================
      // When we start a page, we assume that the Entity in vSourceHierOI is
      // to be formatted on the Page and that vReportDef is positioned on the
      // correct Group.  This was determined by the FormatSubobjectOnDoc
      // routine at the beginning or by the FormatDocPage routine for the
      // last page.  A FooterAtLevel entity exists only if a Footer could
      // not fit on the last page.
      IF vReportDef.FooterAtLevel EXISTS

         // Go to reusable routine to process any necessary footers.
         lReturnLevel = vReportDef.Report.LastLevel
         ProcessFooters( vReportDef, vSubtask, szCurrentEntityName,
                         lReturnLevel, lRemainingSpaceOnPageY,
                         lBottomOfPage, lCurrentPosX, lCurrentPosY,
                         lTemp,
                         lPageWidth, lPageHeight, 0 )

      END

      // If we are not on page one, format the last Group from the prior
      // page, if the return code was ok.
      // Now format the last Group, if return code was ok, including a Header.
      IF lHierRC >= zCURSOR_SET AND lPageNbr != 1
         // Only process the entity if there is a GroupSet by the same name
         // as the Entity.
         SET CURSOR FIRST vReportDef.Group WHERE
                          vReportDef.Group.Type = "ga"
         IF RESULT >= zCURSOR_SET

            szRptGroupSetTag = vReportDef.GroupSet.Tag
            szRptGroupTag = vReportDef.Group.Tag

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineS( "Format the last GroupSet: ", szRptGroupSetTag )
//UNDEF        TraceLineS( "                   Group: ", szRptGroupTag )
//UNDEF        IF vReportDef.PageState.ContinuedGroupFlagStartPage > 0
//UNDEF           TraceLineI( "     Continued: ",
//UNDEF                       vReportDef.PageState.ContinuedGroupFlagStartPage )
//UNDEF        ELSE
//UNDEF           TraceLineI( " Not Continued: ",
//UNDEF                       vReportDef.PageState.ContinuedGroupFlagStartPage )
//UNDEF        END
//UNDEF
//UNDEF        TraceLineV( " vSourceHierOI: ", vSourceHierOI )
//UNDEF     END

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineS( "FormatGroupOnPage 5: ",
//UNDEF                    vReportDef.Group.Tag )
//UNDEF     END

            vTemp = vReportDef.Report.FooterDidNotFit
            IF vTemp = 0
               vTempOI = vSourceHierOI
               lRepeatHorizontal = vReportDef.GroupSet.RepeatHorizontal
            ELSE
               vTempOI = vTemp

            // IF vTempOI != 0
            //    bValidView = IsValidView( vTempOI )
            //    IF bValidView = FALSE
            //    // bValidView = bValidView / bValidView
            //       TraceLineV( "FooterDidNotFit View is Invalid (10): ", vTempOI )
            //    // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 10", TRUE )
            //    ELSE
            //       TraceLineV( "FooterDidNotFit View is Valid (10): ", vTempOI )
            //    END
            // END

               lRepeatHorizontal = 0
            END

            IF lRepeatHorizontal = 0
               nRC_GP = FormatGroupOnPage( vReportDef, vTempOI, vSubtask,
                                           lNewPosX, lNewPosY,
                                           lCurrentPosX, lCurrentPosY,
                                           lRemainingSpaceOnPageY,
                                           0, // continued Group flag 0 ==> not continued
                                           lPageWidth, lPageHeight,
                                           lOrigRemainingSpaceOnPageY,
                                           lBottomOfPage )
               lNewPosX = 0
            END
         END
      END
   END

   // Check the return code from the FormatGroupOnPage for the Detail
   // Group to see if it was split to a new page or we need to get the
   // next data entity.
   IF nRC_GP = -2
      // FormatGroupOnPage was not called above in the start of page
      // processing (usually Page 1).  So do nothing.
   ELSE
   IF nRC_GP = -1
      //*****  MULTI EDIT
      // If the return code from FormatGroupOnPage is -1, then the Group
      // could not fit on the page due to a multi-line text field. For
      // this case process any page footers and return. FormatGroupOnPage
      // has already set up things for continuing on the next page.

      // Process a Page Footer if necessary before returning.
      IF lPrintHTML = 1
         lPageHeight = lCurrentPosY + lFooterPosY
         lFooterPosY = lCurrentPosY
      END

      ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                         lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                         lPageWidth, lPageHeight, lFlags )

      // Return with an indication that there are more Pages and save
      // the CurrentEntityName, last HierReturnCode and ReturnLevel.
      vReportDef.Report.CurrentEntityName = szCurrentEntityName
      vReportDef.Report.HierReturnCode = lHierRC
      vReportDef.Report.LastLevel = lReturnLevel

      RETURN 1 // return indicating that there are MORE pages

   ELSE
//UNDEF  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF     TraceLineI( "Setting ReturnLevel: ", lLastLevel )
//UNDEF     TraceLineS( "   szLastHeaderEntityNameAtLevel? ",
//UNDEF                 szLastHeaderEntityNameAtLevel )
//UNDEF     TraceLineS( "szCurrentEntityName? ", szCurrentEntityName )
//UNDEF  END

   // szLastHeaderEntityNameAtLevel = szCurrentEntityName
      lCurrentPosY = lNewPosY
      lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY

   // IF vSourceHierOI != 0
   //    lHierRC = SetCursorNextEntityHierarchical( nReturnLevel,
   //                                               szCurrentEntityName,
   //                                               vSourceHierOI )
   //    lReturnLevel = nReturnLevel

      IF vSourceHierOI != 0
         // We want to save the level of the last entity on which we have
         // position anytime we read a new entity.  In the past, we saved
         // the level (above) only when we processed a detail Group.
/*dks*/  lLastLevel = lReturnLevel  // save Level of the last entity
                                    // on which we had position.

//>      IF lHierRC >= zCURSOR_SET

         // dks/pas 2005.11.17 - start
         // This code is added to cause a detail footer to be processed
         // when necessary.  If there are sub-entities to the entity
         // being processed, but none of them are "report entities", ignore
         // them and get to the next "reportable" entity.
         szHoldEntityName = szCurrentEntityName
         lHierRC = zCURSOR_SET
         lTempLevel = lLastLevel + 1
         LOOP WHILE lHierRC >= zCURSOR_SET AND lTempLevel > lLastLevel

            lHierRC = SetCursorNextEntityHierarchical( nReturnLevel,
                                                       szCurrentEntityName,
                                                       vSourceHierOI )
            IF lHierRC >= zCURSOR_SET

               // For recursive subentity, step down a level.
               IF lHierRC = zCURSOR_SET_RECURSIVECHILD
                  SetViewToSubobject( vSourceHierOI, szCurrentEntityName )
                  GetEntityNameForHierarchicalCsr( nReturnLevel, szCurrentEntityName, lAbsolutePosition, vSourceHierOI )
               END

               GetEntityKeyForHierarchicalCsr( lDksLevel, szCurrentEntityName,
                                               lDksKey,  vSourceHierOI )
               //TraceLine( "Processing Entity: %s   Key: %d", szCurrentEntityName, lDksKey )

               lTempLevel = nReturnLevel
               IF lTempLevel > lLastLevel

                  // Only process the entity if there is a GroupSet whose Tag matches
                  // the name of the Entity.
                  SET CURSOR FIRST vReportDef.GroupSet WHERE
                                   vReportDef.GroupSet.Tag = szCurrentEntityName
                  IF RESULT >= zCURSOR_SET

                     lReturnLevel = nReturnLevel
                     lTempLevel = lLastLevel
                     SET CURSOR FIRST vReportDef.GroupSet WHERE
                                      vReportDef.GroupSet.Tag = szHoldEntityName
                  END
               END
            END
         END
         // dks/pas 2005.11.17 - end

         // dks/dgc 2007.2.28 - start
         // Process a Group Footer if necessary before continuing.
         IF szHoldEntityName != szCurrentEntityName AND lTempLevel < lLastLevel

            // Note that we are using lTempLevel in the call below instead of the normal lReturnLevel as we're
            // concerned that we not step on lReturnLevel, which seems to be used quite a bit at the beginning of a page.
            ProcessFooters( vReportDef, vSubtask, szHoldEntityName,
                            lTempLevel, lRemainingSpaceOnPageY,
                            lBottomOfPage, lCurrentPosX, lCurrentPosY,
                            lRepeatHorizontalHold, lPageWidth, lPageHeight, 0 )
         END
         // dks/dgc 2007.2.28 - end

//>      END

//UNDEF  IF lHierRC >= zCURSOR_SET
//UNDEF     TraceLineS( "DisplayEI SetCursorNextEntityHierarchical 3", "" )
//UNDEF     DisplayEntityInstance( vSourceHierOI, szCurrentEntityName )
//UNDEF  END
      ELSE
         lHierRC = zCURSOR_NULL
      END

//    TraceLineI( "PrintPage b============== PageNbr: ", lPageNbr )
//    TraceLineS( "   Processing hierarchical entity: ",
//                szCurrentEntityName )
// // TraceLineI( "          Hierarchical ReturnCode: ",
// //             lHierRC )
//    GetEntityKeyForHierarchicalCsr( lReturnLevel, szHierEntityName,
//                                    lEntityKey,  vSourceHierOI )
//    TraceLineS( "              AbsHier  EntityName: ", szHierEntityName )
// // TraceLineI( "              AbsHier  Position: ", lEntityKey )

//UNDEF  TraceLineS( "Processing hierarchical entity: ",
//UNDEF              szCurrentEntityName )

   END END

   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //
   // Now continue to loop hierarchically through the entities in the
   // subobject and process headers, main Groups and footers for each
   // entity, as defined in the Report Def.
   // 1. Process an entity only if there is a GroupSet whose Tag matches the
   //    name of the Entity.
   // 2. A main Group is processed if there is a Group of subtype "ga" in
   //    the ReportDef.
   // 3. A header Group is processed for the first instance of an entity
   //    under its parent if there is a Group of Type "gh".  This is
   //    determined by the changing of the CurrentEntityName at a particular
   //    level or by going down a level.
   // 4. A footer Group is processed for the last instance of an entity under
   //    its parent if there is a Group of Type "gf".  A problem here is that
   //    multiple Footers might need to be processed when we position on a
   //    new entity.  To handle this, an instance of FooterAtLevel was
   //    created on the first instance of each entity that would later
   //    require a Footer.  They were created in reverse order by Level.
   //    Thus our logic for processing a Footer is to see if an instance of
   //    FooterAtLevel exists for a Level higher than the level of the
   //    current entity.
   //
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////
   //////////////////////////////////////////////////////////////////////////

// TraceLineX( "PrintPage lPrintFlags: ", lPrintFlags )
   lMultiRootFlag = SetFlagSequence( lPrintFlags,
                                     1048576, // 0x00100000  check this bit
                                     0 )      // Nonzero ==> multiple
                                              // roots were requested.

//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineS( "LOOP WHILE GroupSet Tag: ", szRptGroupSetTag )
//UNDEF    TraceLineS( "              Group Tag: ", szRptGroupTag )
//UNDEF    TraceLineI( "         HierReturnCode: ", lHierRC )
//UNDEF    TraceLineI( "            ReturnLevel: ", lReturnLevel )
//UNDEF    TraceLineI( "             StartLevel: ", lStartLevel )
//UNDEF    TraceLineI( "              TestFlags: ", lMultiRootFlag )
//UNDEF    TraceLineS( "    szCurrentEntityName: ", szCurrentEntityName )
//UNDEF    TraceLineS( "  szSubobjectEntityName: ", szSubobjectEntityName )
//UNDEF END

   // For any group that is repeating horizontally, we assume all setup
   // of the "view port" is done for each page.
   // Clear the "view port" stack.
   nRC = 1
   LOOP WHILE nRC > 0
      nRC = PopReportViewPort( vSubtask, szRepeatHorizontalEntityName,
                               lRepeatHorizontal, lRepeatHorizontalColumn,
                               lRepeatHorizontalIndent, lRepeatHorizontalMargin,
                               lRepeatHorizontalExtent, lRepeatHorizontalFlags,
                               lViewPortBottomPrev, lViewPortTop, lViewPortLeft,
                               lViewPortBottom, lViewPortRight )
   END

   // Now (continue to) loop hierarchically through the entities.
   LOOP WHILE lHierRC >= zCURSOR_SET AND
              lReturnLevel >= lStartLevel AND
              (lMultiRootFlag != 0 OR
               lFirstEntityOnReportFlag = 1 OR
               szCurrentEntityName != szSubobjectEntityName)

      lFirstEntityOnReportFlag = 0

      // Only process the entity if there is a GroupSet whose Tag matches
      // the name of the Entity.
      SET CURSOR FIRST vReportDef.GroupSet WHERE
                       vReportDef.GroupSet.Tag = szCurrentEntityName
      IF RESULT >= zCURSOR_SET

         // Added 2006.10.30 by DonC, because we were not always positioned on the detail group.
         SET CURSOR FIRST vReportDef.Group WHERE vReportDef.Group.Type = "ga"

         // Added 2005.04.03 by DKS
         // The following code was added because Group Headers were not being
         // generated for an entity that was printed on a previous page, even
         // when a "higher level" entity was printed.
         // Null any LastHeaderEntityAtLevel entries for entities that exist
         // at a lower level than the current entity. This will cause the
         // trigger of headers for those entities.
         IF lReturnLevel < lLastLevel

         // CreateViewTrace( "Creating view (14): ", vHeaderDef, vReportDef, 0 )
            CreateViewFromViewForTask( vHeaderDef, vReportDef, 0 )
            FOR EACH vHeaderDef.LastHeaderEntityAtLevel
               IF vHeaderDef.LastHeaderEntityAtLevel.Level > lReturnLevel
                  vHeaderDef.LastHeaderEntityAtLevel.EntityName = ""
               END
            END

         // DropViewTrace( "Dropping view (14): ", vHeaderDef )
            DropView( vHeaderDef )
            vHeaderDef = 0
         END

         // If the RepeatHorizontal value is not the same as the previous
         // value, then we are entering a new GroupSet and need to
         // reinitialize the "repeat" settings.
         PopReportViewPort( vSubtask, szRepeatHorizontalEntityName,
                            lRepeatHorizontal, lRepeatHorizontalColumn,
                            lRepeatHorizontalIndent, lRepeatHorizontalMargin,
                            lRepeatHorizontalExtent, lRepeatHorizontalFlags,
                            lViewPortBottomPrev, lViewPortTop, lViewPortLeft,
                            lViewPortBottom, lViewPortRight )

         lRepeatHorizontalTemp = vReportDef.GroupSet.RepeatHorizontal
         IF lRepeatHorizontalTemp != lRepeatHorizontal

            // Clear the "view port" stack.
            nRC = 1
            LOOP WHILE nRC > 0
               nRC = PopReportViewPort( vSubtask, szRepeatHorizontalEntityName,
                                        lRepeatHorizontal, lRepeatHorizontalColumn,
                                        lRepeatHorizontalIndent, lRepeatHorizontalMargin,
                                        lRepeatHorizontalExtent, lRepeatHorizontalFlags,
                                        lViewPortBottomPrev, lViewPortTop, lViewPortLeft,
                                        lViewPortBottom, lViewPortRight )
            END

            lRepeatHorizontal = lRepeatHorizontalTemp
            lRepeatHorizontalIndent = vReportDef.GroupSet.RepeatIndent
            lCurrentPosX = lRepeatHorizontalIndent
            lViewPortLeft = 0
            lViewPortBottomPrev = lCurrentPosY
            lViewPortTop = lCurrentPosY
            lViewPortRight = lPageWidth
            lViewPortBottom = lBottomOfPage

            IF lRepeatHorizontalHold != 0 AND lRepeatHorizontalHold = lRepeatHorizontalTemp
               lViewPortTop = lPosYHold
               lRepeatHorizontalHold = 0
            END

            IF lRepeatHorizontal = 0

               lRepeatHorizontalFlags = 0
               lRepeatHorizontalColumn = 0
               lRepeatHorizontalIndent = 0
               lRepeatHorizontalMargin = 0
               lRepeatHorizontalExtent = 0
               szRepeatHorizontalEntityName = ""

            ELSE

            // SysReadZeidonIni( -1, "[Workstation]",
            //                   "RepeatHorizontalIndent", szINI )
            // lRepeatHorizontalIndent = zatol( szINI )
               lRepeatHorizontalMargin = vReportDef.GroupSet.RepeatMargin
               lRepeatHorizontalFlags = vReportDef.GroupSet.Flags
               lRepeatHorizontalExtent = 0
               lRepeatHorizontalColumn = 1
               lRepeatHorizontalNewspaper =
                              IsFlagSequenceSet( lRepeatHorizontalFlags, 1 )
               IF lRepeatHorizontalNewspaper != 0
                  IF szRepeatHorizontalEntityName != szCurrentEntityName
                  END
               END

               lNewPosX = lViewPortLeft + lRepeatHorizontalIndent

            END

            szRepeatHorizontalEntityName = szCurrentEntityName

         ELSE

         // lRepeatHorizontal = lRepeatHorizontalTemp

            IF lRepeatHorizontal = 0

               lViewPortLeft = lCurrentPosX
               lViewPortBottomPrev = lCurrentPosY
               lViewPortTop = lCurrentPosY
               lViewPortRight = lPageWidth
               lViewPortBottom = lBottomOfPage
               lRepeatHorizontalFlags = 0
               lRepeatHorizontalColumn = 0
               lRepeatHorizontalIndent = 0
               lRepeatHorizontalMargin = 0
               lRepeatHorizontalExtent = 0
               szRepeatHorizontalEntityName = ""

            ELSE

               IF lRepeatHorizontalColumn > 1

                  lNewPosX = lRepeatHorizontalExtent + lRepeatHorizontalMargin
                  lNewPosX = lNewPosX * (lRepeatHorizontalColumn - 1)
                  lNewPosX = lNewPosX + lRepeatHorizontalIndent
                  lTemp = lNewPosX + lRepeatHorizontalExtent
                  IF lTemp > lPageWidth AND lRepeatHorizontalColumn < lRepeatHorizontal
                     lNewPosX = lViewPortLeft + lRepeatHorizontalIndent
                     lViewPortTop = lCurrentPosY
                     lRepeatHorizontalColumn = 1
                  ELSE
                     IF lRepeatHorizontalNewspaper = 0
                        lNewPosY = lViewPortBottomPrev
                     END

                     lCurrentPosY = lNewPosY
                     lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
                  END

               ELSE
                  lNewPosX = lViewPortLeft + lRepeatHorizontalIndent
               END

               lCurrentPosX = lNewPosX
               lCurrentPosY = lNewPosY

            END
         END

         // Force a page break if this entity requests ForcePageBreak.
         IF vReportDef.Group.ForcePageBreak = "Y" AND
            lOrigRemainingSpaceOnPageY != lRemainingSpaceOnPageY

            // This entity requests a page break for each entity instance.
            // Thus process any page footers and return.

            // Go to process Group Footers.
            ProcessFooters( vReportDef, vSubtask, szCurrentEntityName,
                            lReturnLevel, lRemainingSpaceOnPageY,
                            lBottomOfPage, lCurrentPosX, lCurrentPosY,
                            lTemp,
                            lPageWidth, lPageHeight, 1 )

            // Process a Page Footer if necessary before returning.
            IF lPrintHTML = 1
               lPageHeight = lCurrentPosY + lFooterPosY
               lFooterPosY = lCurrentPosY
            END

            ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                               lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                               lPageWidth, lPageHeight, lFlags )

            // Return with an indication that there are more Pages and
            // save the CurrentEntityName, last HierReturnCode and
            // ReturnLevel.
            vReportDef.Report.CurrentEntityName = szCurrentEntityName
            vReportDef.Report.HierReturnCode = lHierRC
            vReportDef.Report.LastLevel = lReturnLevel

            RETURN 1 // return indicating that there are MORE pages
         END

         // *** PROCESS FOOTER ***

         // Go to reusable routine to process any necessary footers.  A
         // return code of 1 indicates that not all of the necessary
         // Footers could fit on the page.
         nRC = 1
         LOOP WHILE nRC = 1

            lViewPortBottomPrev = lCurrentPosY
            nRC = ProcessFooters( vReportDef, vSubtask, szCurrentEntityName,
                                  lReturnLevel, lRemainingSpaceOnPageY,
                                  lBottomOfPage, lCurrentPosX, lCurrentPosY,
                                  lTemp,
                                  lPageWidth, lPageHeight, 0 )
            IF nRC = 1

               IF lRepeatHorizontal = 0 OR lRepeatHorizontalColumn >= lRepeatHorizontal

                  // Process a Page Footer if necessary before returning.
                  IF lPrintHTML = 1
                     lPageHeight = lCurrentPosY + lFooterPosY
                     lFooterPosY = lCurrentPosY
                  END

                  ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                                     lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                                     lPageWidth, lPageHeight, lFlags )

                  // Return with an indication that there are more Pages and save
                  // the CurrentEntityName, last HierReturnCode and ReturnLevel.
                  vReportDef.Report.CurrentEntityName = szCurrentEntityName
                  vReportDef.Report.HierReturnCode = lHierRC
                  vReportDef.Report.LastLevel = lReturnLevel

                  RETURN 1 // return indicating that there are MORE pages

               ELSE

                  lRepeatHorizontalColumn = lRepeatHorizontalColumn + 1
                  lNewPosX = lRepeatHorizontalExtent + lRepeatHorizontalMargin
                  lNewPosX = lNewPosX * (lRepeatHorizontalColumn - 1)
                  lNewPosX = lNewPosX + lRepeatHorizontalIndent
                  lCurrentPosX = lNewPosX
                  lNewPosY = lViewPortTop
                  lCurrentPosY = lNewPosY

                  // We don't want to say that the footer did not fit in
                  // this case since we are going to the next column.
                  vTemp = vReportDef.Report.FooterDidNotFit
                  IF vTemp != 0
                     DropView( vTemp )
                     vReportDef.Report.FooterDidNotFit = 0
                  END
               END
            END
         END

         // If the current entity is going to require a Footer later, set
         // up the necessary information to process it, if it does not
         // already exist.
         SET CURSOR FIRST vReportDef.Group WHERE
                          vReportDef.Group.Type = "gf"
         IF RESULT >= zCURSOR_SET

            SET CURSOR FIRST vReportDef.FooterAtLevel WHERE
                vReportDef.FooterAtLevel.EntityName = szCurrentEntityName
            IF RESULT < zCURSOR_SET

               CREATE ENTITY vReportDef.FooterAtLevel FIRST
               vReportDef.FooterAtLevel.Level = lReturnLevel
               vReportDef.FooterAtLevel.EntityName = szCurrentEntityName
            // CreateViewTrace( "Creating view (15): ", vFooterHierOI, vSourceHierOI, 0 )
               CreateViewFromViewForTask( vFooterHierOI, vSourceHierOI, 0 )
               SetAttributeFromView( vReportDef, "FooterAtLevel",
                                     "SourceOI_Hier", vFooterHierOI )
//UNDVV        TraceLineV( "Creating FooterAtLevel with view: ", vFooterHierOI )
//UNDVV        DisplayEntityInstance( vReportDef, "PageState" )
//UNDVV        DisplayEntityInstance( vReportDef, "FooterAtLevel" )
            END
         END

         // Get set up for Header check.  We're keeping track of the last
         // entity processed at each LOD level.
         SET CURSOR FIRST vReportDef.LastHeaderEntityAtLevel WHERE
                vReportDef.LastHeaderEntityAtLevel.Level = lReturnLevel

//xNDEF  // This can cause a skip of a detail Group when defined
//xNDEF  IF lPageNbr <= 2 AND lFirstTime < 2
//xNDEF     TraceLineI( "Looking for ReturnLevel: ", lReturnLevel )
//xNDEF     TraceLineI( "                     RC: ", RESULT )
//xNDEF     IF lFirstTime < 1
//xNDEF        SET CURSOR FIRST vReportDef.Report
//xNDEF        LOOP WHILE RESULT >= 0
//xNDEF           DisplayEntityInstance( vReportDef, "Report" )
//xNDEF           SET CURSOR FIRST vReportDef.LastHeaderEntityAtLevel
//xNDEF           LOOP WHILE RESULT >= 0
//xNDEF              DisplayEntityInstance( vReportDef,
//xNDEF                                     "LastHeaderEntityAtLevel" )
//xNDEF              SET CURSOR NEXT vReportDef.LastHeaderEntityAtLevel
//xNDEF           END
//xNDEF        SET CURSOR NEXT vReportDef.Report
//xNDEF        END
//xNDEF     END
//xNDEF
//xNDEF     lFirstTime = lFirstTime + 1
//xNDEF
//xNDEF     SET CURSOR FIRST vReportDef.LastHeaderEntityAtLevel WHERE
//xNDEF           vReportDef.LastHeaderEntityAtLevel.Level = lReturnLevel
//xNDEF
//xNDEF  END

         IF RESULT < zCURSOR_SET

            CREATE ENTITY vReportDef.LastHeaderEntityAtLevel
            vReportDef.LastHeaderEntityAtLevel.Level = lReturnLevel
            vReportDef.LastHeaderEntityAtLevel.EntityName = ""
            szLastHeaderEntityNameAtLevel = ""

         ELSE
/*dks*/     szLastHeaderEntityNameAtLevel =
/*dks*/                       vReportDef.LastHeaderEntityAtLevel.EntityName
         END

         // Added 11/15/03 by DonC
         // The following code was added because Group Headers were not being
         // generated except for the first set of twins on a page. You would
         // get a parent group printed, followed by children without a header.
         // Null any LastHeaderEntityAtLevel entries for entities that exist
         // at a lower level than the current entity. This will cause the
         // trigger of headers for those entities.
      // CreateViewTrace( "Creating view (16): ", vHeaderDef, vReportDef, 0 )
         CreateViewFromViewForTask( vHeaderDef, vReportDef, 0 )
         FOR EACH vHeaderDef.LastHeaderEntityAtLevel
            IF vHeaderDef.LastHeaderEntityAtLevel.Level > lReturnLevel
               vHeaderDef.LastHeaderEntityAtLevel.EntityName = ""
            END
         END

      // FOR EACH vHeaderDef.PageState
      //    DisplayObjectInstance( vHeaderDef, "PageState", 0 )
      // END

      // DropViewTrace( "Dropping view (15): ", vHeaderDef )
         DropView( vHeaderDef )
         vHeaderDef = 0

//xNDEF  IF lPageNbr <= 2 AND lFirstTime < 2
//xNDEF     TraceLineS( "===>>> szLastHeaderEntityNameAtLevel? ",
//xNDEF                 szLastHeaderEntityNameAtLevel )
//xNDEF  END

         // *** PROCESS HEADER ***

         // See if we need to put a Header in front of this Group.  The logic
         // here is to put a Header only before the first entity instance of
         // a set of twins, unless the ForceHeaderPerEntity flag is set.  In
         // that case, put a Header before every entity instance.
      // CreateViewTrace( "Creating view (17): ", vHeaderDef, vReportDef, 0 )
         CreateViewFromViewForTask( vHeaderDef, vReportDef, 0 )
         SET CURSOR FIRST vHeaderDef.Group WHERE
                          vHeaderDef.Group.Type = "gh"
         IF RESULT >= zCURSOR_SET

            IF lLastLevel < lReturnLevel OR
               szLastHeaderEntityNameAtLevel != szCurrentEntityName OR  // ******
               vHeaderDef.Group.ForceHeaderPerEntity = "Y"

            // IF lLastLevel < lReturnLevel OR
               IF vHeaderDef.Group.ForceHeaderPerEntity = "Y"

                  SET CURSOR FIRST vReportDef.FooterAtLevel WHERE
                     vReportDef.FooterAtLevel.EntityName = szCurrentEntityName
                  IF RESULT >= zCURSOR_SET
                     vReportDef.FooterAtLevel.Complete = "Y"
                  END
               END

            // lLastLevel = lReturnLevel
               szLastHeaderEntityNameAtLevel = szCurrentEntityName
/*dks*/        vReportDef.LastHeaderEntityAtLevel.EntityName = szCurrentEntityName

               // Make sure there is enough space on the Page for both
               // the Header and the Attribute Group.  If not, we will
               // simply return here.  A return code of 1 means there
               // is more data to put on the next page.
               lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
//UNDEF        TraceLineI( "RemainingSpaceOnPage ===> ", lRemainingSpaceOnPageY )
//UNDEF        lGroupTotal = vHeaderDef.Group.MinimumExtent +
//UNDEF                                     vReportDef.Group.MinimumExtent
//UNDEF        TraceLineI( "     GroupTotal MinExtent ", lGroupTotal )
               lGroupTotal = vHeaderDef.Group.SZDLG_Y + vReportDef.Group.SZDLG_Y
//UNDEF        TraceLineI( "     GroupTotal SZDLG_Y=> ", lGroupTotal )
               IF lRemainingSpaceOnPageY < lGroupTotal

                  IF lRepeatHorizontal = 0 OR lRepeatHorizontalColumn >= lRepeatHorizontal

                     // Process a Page Footer if necessary before returning.
                     IF lPrintHTML = 1
                        lPageHeight = lCurrentPosY + lFooterPosY
                        lFooterPosY = lCurrentPosY
                     END

                     ProcessPageFooter( vReportDef, vSourceHierOI,
                                        vSubtask, lNewPosX, lNewPosY,
                                        lCurrentPosX, lFooterPosY,
                                        lPageWidth, lPageHeight, lFlags )

                     // Return with an indication that there are more
                     // Pages and save the CurrentEntityName, last
                     // HierReturnCode and ReturnLevel.
                     vReportDef.Report.CurrentEntityName = szCurrentEntityName
                     vReportDef.Report.HierReturnCode = lHierRC
                     vReportDef.Report.LastLevel = lReturnLevel

                     RETURN 1 // return indicating there are MORE pages

               // ELSE  this was removed so when splitting a group, the  // dks 2005.07.04
               //       RepeatHorizontalColumn was not incremented until needed!
               //    lRepeatHorizontalColumn = lRepeatHorizontalColumn + 1
               //    lNewPosY = lViewPortTop

                  END
               END

//UNDEF        IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF           TraceLineI( "Page 2 GroupHeader RC: ", RESULT )
//UNDEF           TraceLineI( "            LastLevel: ", lLastLevel )
//UNDEF           TraceLineI( "          ReturnLevel: ", lReturnLevel )
//UNDEF           TraceLineS( "     szLastHeaderEntityNameAtLevel: ",
//UNDEF                       szLastHeaderEntityNameAtLevel )
//UNDEF           TraceLineS( "  szCurrentEntityName: ", szCurrentEntityName )
//UNDEF        END

               // Put Header on Page.
//UNDEF        IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF           TraceLineS( "FormatGroupOnPage 6: ",
//UNDEF                       vHeaderDef.Group.Tag )
//UNDEF        END

               // If this is not the first Group Header on the page, format
               // it.  If it is the first Group Header on the page, it was
               // formatted earlier.
               FormatGroupOnPage( vHeaderDef, vSourceHierOI, vSubtask,
                                  lNewPosX, lNewPosY, lCurrentPosX, lCurrentPosY,
                                  lRemainingSpaceOnPageY,
                                  0, // continued Group flag 0 = not continued
                                  lPageWidth, lPageHeight,
                                  lOrigRemainingSpaceOnPageY,
                                  lBottomOfPage )

               IF lRepeatHorizontalColumn = 1
                  lTemp = lNewPosX - lRepeatHorizontalIndent
                  IF lRepeatHorizontalExtent < lTemp
                     lRepeatHorizontalExtent = lTemp
                  END
               END

            // lNewPosX = 0  // this should depend on the "horizontal repeat" settings ???
               lNewPosX = lRepeatHorizontalIndent
               lCurrentPosY = lNewPosY
               lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
            END
         END

      // DropViewTrace( "Dropping view (16): ", vHeaderDef )
         DropView( vHeaderDef )
         vHeaderDef = 0

         // Format the Attribute information for the entity, if it is
         // defined in the Report Def.
         SET CURSOR FIRST vReportDef.Group WHERE
                          vReportDef.Group.Type = "ga"

         IF RESULT >= zCURSOR_SET

            // *** PROCESS REGULAR GROUP ***

            // Put Attribute data on Page, if there is enough room.
            lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)     /*TracePages*/
//UNDEF        TraceLineS( "FormatGroupOnPage REGULAR GROUP GroupSet: ",
//UNDEF                    szRptGroupSetTag )
//UNDEF        TraceLineS( "                                   Group: ",
//UNDEF                    szRptGroupTag )
//UNDEF        lTempValue = vReportDef.Group.Extent
//UNDEF        TraceLineI( "                    RemainingSpaceOnPage: ",
//UNDEF                    lRemainingSpaceOnPageY )
//UNDEF        TraceLineI( "                            Group.Extent: ",
//UNDEF                    lTempValue )
//UNDEF     END

            szRptGroupSetTag = vReportDef.GroupSet.Tag
            szRptGroupTag = vReportDef.Group.Tag

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)  /*TracePages*/
//UNDEF        TraceLineS( "FormatGroupOnPage 7: ",
//UNDEF                    vReportDef.Group.Tag )
//UNDEF     END

            lContinuedGroupFlag = 0 //  0 ==> not continued
            nRC = 0
            LOOP WHILE nRC = 0

               IF lRemainingSpaceOnPageY > vReportDef.Group.SZDLG_Y OR
                  vReportDef.Group.AllowPageBreak = "Y" OR
                  lPrintHTML = 1 OR
                  lRemainingSpaceOnPageY = lOrigRemainingSpaceOnPageY

                  lViewPortBottomPrev = lNewPosY
                  nRC_GP = FormatGroupOnPage( vReportDef, vSourceHierOI,
                                              vSubtask, lNewPosX, lNewPosY,
                                              lCurrentPosX, lCurrentPosY,
                                              lRemainingSpaceOnPageY,
                                              lContinuedGroupFlag,
                                              lPageWidth, lPageHeight,
                                              lOrigRemainingSpaceOnPageY,
                                              lBottomOfPage )
               ELSE
                  nRC_GP = -2
               END


               vReportDef.PageState.MultiLineTextPosStartPage = 0
               vReportDef.PageState.ContinuedControlTagStartPage = ""
               vReportDef.PageState.ContinuedGroupFlagStartPage = 0
               vReportDef.PageState.ContinuedControlTagStartPage = ""
               lContinuedGroupFlag = 0

               nRC = 1
               IF lRepeatHorizontal != 0

                  IF lRepeatHorizontalColumn = 1

                     lTemp = lNewPosX - lRepeatHorizontalIndent
                     IF lRepeatHorizontalExtent < lTemp

                        lRepeatHorizontalExtent = lTemp

                     END

                  END

                  IF lRepeatHorizontalNewspaper = 0  // ==> horizontal first

                     lNewPosX = lRepeatHorizontalExtent + lRepeatHorizontalMargin
                     lNewPosX = lNewPosX * lRepeatHorizontalColumn
                     lNewPosX = lNewPosX + lRepeatHorizontalIndent
                     lTemp = lNewPosX + lRepeatHorizontalExtent
                     lRepeatHorizontalColumn = lRepeatHorizontalColumn + 1

                     nRC = 1
                     szHoldEntityName = szCurrentEntityName
                     LOOP WHILE vSourceHierOI != 0 AND nRC = 1 AND
                                lHierRC >= zCURSOR_SET

                        lHierRC = SetCursorNextEntityHierarchical( nReturnLevel,
                                                                   szCurrentEntityName,
                                                                   vSourceHierOI )
                        IF lHierRC >= zCURSOR_SET

                           // For recursive subentity, step down a level.
                           IF lHierRC = zCURSOR_SET_RECURSIVECHILD
                              SetViewToSubobject( vSourceHierOI, szCurrentEntityName )
                              GetEntityNameForHierarchicalCsr( nReturnLevel, szCurrentEntityName, lAbsolutePosition, vSourceHierOI )
                           END

                           GetEntityKeyForHierarchicalCsr( lDksLevel, szCurrentEntityName,
                                                           lDksKey,  vSourceHierOI )
                           //TraceLine( "Processing Entity: %s   Key: %d", szCurrentEntityName, lDksKey )
                        END

                        IF szCurrentEntityName = szHoldEntityName
                           nRC = 0
                        END

                     END

                     IF nRC = 0   // we located another "repeat" entity

                        IF lTemp < lPageWidth  // this one fits on current "line"

                           lNewPosY = lViewPortBottomPrev
                           lCurrentPosY = lNewPosY
                           lRemainingSpaceOnPageY = lBottomOfPage - lNewPosY
                        // lRemainingSpaceOnPageY = lOrigRemainingSpaceOnPageY
                           lCurrentPosX = lNewPosX

                        ELSE

                           lRemainingSpaceOnPageY = lBottomOfPage - lNewPosY
                           IF lRemainingSpaceOnPageY > vReportDef.Group.SZDLG_Y

                              // We need to move to next "line".
                              lNewPosX = lRepeatHorizontalIndent
                              lCurrentPosX = lRepeatHorizontalIndent
                              lRepeatHorizontalColumn = 1
                              lCurrentPosY = lNewPosY
                              lOrigRemainingSpaceOnPageY = lRemainingSpaceOnPageY

                           ELSE

                              nRC = 1  // does not fit on this page
                              nRC_GP = -1

                           END
                        END
                     ELSE

                        // We didn't locate any more "repeat" entities.
                        nRC_GP = 0

                     END

                  ELSE

                     // This is the Newspaper case.
                     IF nRC_GP = -1 OR  //*****  MULTI EDIT
                        nRC_GP = -2     // Did not fit

                        lNewPosX = lRepeatHorizontalExtent + lRepeatHorizontalMargin
                        lNewPosX = lNewPosX * lRepeatHorizontalColumn
                        lNewPosX = lNewPosX + lRepeatHorizontalIndent
                        lTemp = lNewPosX + lRepeatHorizontalExtent
                        lRepeatHorizontalColumn = lRepeatHorizontalColumn + 1
                        IF (lTemp < lPageWidth AND
                            lRepeatHorizontalColumn <= lRepeatHorizontal) OR
                           lRepeatHorizontalColumn = lRepeatHorizontal

                           IF nRC_GP = -1

                              vReportDef.PageState.MultiLineTextPosStartPage =
                                         vReportDef.PageState.MultiLineTextPosEndPage
                              vReportDef.PageState.ContinuedControlTagStartPage =
                                         vReportDef.PageState.ContinuedControlTagEndPage
                              vReportDef.PageState.ContinuedGroupFlagStartPage =
                                         vReportDef.PageState.ContinuedGroupFlagEndPage
                              vReportDef.PageState.ContinuedControlTagStartPage =
                                         vReportDef.PageState.ContinuedControlTagEndPage
                              lContinuedGroupFlag = 1

                           END

                           lNewPosY = lViewPortTop
                           lRemainingSpaceOnPageY = lOrigRemainingSpaceOnPageY
                           lCurrentPosX = lNewPosX
                           lCurrentPosY = lNewPosY
                           nRC = 0
                           nRC_GP = 0

                        ELSE

                           lNewPosX = lViewPortLeft
                           lRepeatHorizontalColumn = 1
                           nRC = 1

                        END

                     END
                  END
               END

               IF nRC = 1

               // lNewPosX = 0   // reset for next group
                  lNewPosX = lRepeatHorizontalIndent   // reset for next group

                  // This code is executed when we are processing a detail
                  // Group.  We want to save the level any time we read a new
                  // entity, not only when we format a Group detail.  So we
                  // now save the level below (see IF vSourceHierOI != 0).
               // lLastLevel = lReturnLevel  // save Level of the last entity
                                             // on which we had position.
                  IF nRC_GP = -1 OR //*****  MULTI EDIT
                     nRC_GP = -2    // did not fit ... AND lRepeatHorizontal != 0)

                     // If the return code from FormatGroupOnPage is -1, then
                     // the Group could not fit on the page due to a multi-line
                     // text field.  For this case process any page footers and
                     // return.  FormatGroupOnPage has already set up things for
                     // continuing on the next page.

                     // Process a Page Footer if necessary before returning.
                     IF lPrintHTML = 1
                        lPageHeight = lCurrentPosY + lFooterPosY
                        lFooterPosY = lCurrentPosY
                     END

                     ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                                        lNewPosX, lNewPosY, lCurrentPosX,
                                        lFooterPosY, lPageWidth, lPageHeight,
                                        lFlags )

                     // Return with an indication that there are more Pages and
                     // save the CurrentEntityName, last HierReturnCode and
                     // ReturnLevel.
                     vReportDef.Report.CurrentEntityName = szCurrentEntityName
                     vReportDef.Report.HierReturnCode = lHierRC
                     vReportDef.Report.LastLevel = lReturnLevel

                     RETURN 1 // return indicating that there are MORE pages

                  ELSE
                     lCurrentPosY = lNewPosY
                     lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY
                  END
               END
            END
         END

         PushReportViewPort( vSubtask, szRepeatHorizontalEntityName,
                             lRepeatHorizontal, lRepeatHorizontalColumn,
                             lRepeatHorizontalIndent, lRepeatHorizontalMargin,
                             lRepeatHorizontalExtent, lRepeatHorizontalFlags,
                             lViewPortBottomPrev, lViewPortTop, lViewPortLeft,
                             lViewPortBottom, lViewPortRight )

      ELSE

      // TraceLineS( "PrintPage3 unable to locate GroupSet: ",
      //             szCurrentEntityName )

      END

      IF vSourceHierOI != 0
         // We want to save the level of the last entity on which we have
         // position anytime we read a new entity.  In the past, we saved
         // the level (above) only when we processed a detail Group.
/*dks*/  lLastLevel = lReturnLevel  // save Level of the last entity
                                    // on which we had position.

//>      IF lHierRC >= zCURSOR_SET

         // dks/pas 2005.11.17 - start
         // This code is added to cause a detail footer to be processed
         // when necessary.  If there are sub-entities to the entity
         // being processed, but none of them are "report entities", ignore
         // them and get to the next "reportable" entity.
         szHoldEntityName = szCurrentEntityName
         lHierRC = zCURSOR_SET
         lTempLevel = lLastLevel + 1
         LOOP WHILE lHierRC >= zCURSOR_SET AND lTempLevel > lLastLevel

            lHierRC = SetCursorNextEntityHierarchical( nReturnLevel,
                                                       szCurrentEntityName,
                                                       vSourceHierOI )
            IF lHierRC >= zCURSOR_SET

               // For recursive subentity, step down a level.
               IF lHierRC = zCURSOR_SET_RECURSIVECHILD
                  SetViewToSubobject( vSourceHierOI, szCurrentEntityName )
                  GetEntityNameForHierarchicalCsr( nReturnLevel, szCurrentEntityName, lAbsolutePosition, vSourceHierOI )
               END

               GetEntityKeyForHierarchicalCsr( lDksLevel, szCurrentEntityName,
                                               lDksKey,  vSourceHierOI )
               //TraceLine( "Processing Entity: %s   Key: %d", szCurrentEntityName, lDksKey )

               lTempLevel = nReturnLevel
               IF lTempLevel > lLastLevel

                  // Only process the entity if there is a GroupSet whose Tag matches
                  // the name of the Entity.
                  SET CURSOR FIRST vReportDef.GroupSet WHERE
                                   vReportDef.GroupSet.Tag = szCurrentEntityName
                  IF RESULT >= zCURSOR_SET

                     lTempLevel = lLastLevel
                     SET CURSOR FIRST vReportDef.GroupSet WHERE
                                      vReportDef.GroupSet.Tag = szHoldEntityName
                  END
               END
            END
         END
         // dks/pas 2005.11.17 - end

//>      END

      // IF lHierRC < zCURSOR_SET OR
      //    (nReturnLevel = lReturnLevel AND
      //     szCurrentEntityName = vReportDef.Report.CurrentEntityName)
      //
      //    IF vDeferredOI != 0
      //       DropView( vDeferredOI )
      //       vDeferredOI = 0
      //    END
      //
      //    vReportDef.Report.DeferredOI = 0
      //
      // END

         lReturnLevel = nReturnLevel

         // dks/pas 2005.11.17 - start
         // Process a Group Footer if necessary before returning.
         IF szHoldEntityName != szCurrentEntityName

            ProcessFooters( vReportDef, vSubtask, szHoldEntityName,
                            lReturnLevel, lRemainingSpaceOnPageY,
                            lBottomOfPage, lCurrentPosX, lCurrentPosY,
                            lRepeatHorizontalHold, lPageWidth, lPageHeight, 0 )
         END
         // dks/pas 2005.11.17 - end

//UNDEF  IF lHierRC >= zCURSOR_SET
//UNDEF     TraceLineS( "DisplayEI SetCursorNextEntityHierarchical 5", "" )
//UNDEF     DisplayEntityInstance( vSourceHierOI, szCurrentEntityName )
//UNDEF  END

      ELSE
         lHierRC = zCURSOR_NULL
      END

      IF lHierRC < zCURSOR_SET

         szCurrentEntityName = ""
         szHierEntityName = ""
         lReturnLevel = 0

      ELSE

         // I think this is the correct place to store state information???
         vReportDef.Report.CurrentEntityName = szCurrentEntityName
         vReportDef.Report.HierReturnCode = lHierRC
         vReportDef.Report.LastLevel = lReturnLevel
      // vReportDef.Report.ForcePageBreak = bForcePageBreak
      // lTempView = MakeIntegerFromView( vFooterDidNotFit )
      // vReportDef.Report.FooterDidNotFit = lTempView

      //xSET CURSOR FIRST vReportDef.FooterAtLevel WHERE
      //x    vReportDef.FooterAtLevel.EntityName = szCurrentEntityName
      //xIF RESULT >= zCURSOR_SET
      //x   vReportDef.FooterAtLevel.Complete = "Y"
      //xEND

//UNDEF  TraceLineS( "Processing hierarchical entity: ",
//UNDEF              szCurrentEntityName )
//UNDEF  TraceLineS( "SubobjectEntityName: ", szSubobjectEntityName )
//UNDEF  TraceLineI( "HierReturnCode: ", lHierRC )
//UNDEF  TraceLineI( "ReturnLevel: ", lReturnLevel )
//UNDEF  TraceLineI( "StartLevel: ", lStartLevel )

      END

      lRepeatHorizontalHold = 0

   END

   // Go to reusable routine to process any remaining footers.  A return code
   // of 1 indicates that not all of the necessary Footers could fit on the
   // page.  lReturnLevel is 0 to force all remaining Footers.
   lReturnLevel = 0
   vReportDef.Report.LastLevel = lReturnLevel
   nRC = ProcessFooters( vReportDef, vSubtask, szCurrentEntityName,
                         lReturnLevel, lRemainingSpaceOnPageY,
                         lBottomOfPage, lCurrentPosX, lCurrentPosY,
                         lTemp,
                         lPageWidth, lPageHeight, 0 )
   IF nRC = 1
      // Process a Page Footer if necessary before returning.
      IF lPrintHTML = 1
         lPageHeight = lCurrentPosY + lFooterPosY
         lFooterPosY = lCurrentPosY
      END

      ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                         lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                         lPageWidth, lPageHeight, lFlags )

      // Return with an indication that there are more Pages and save
      // the CurrentEntityName, last HierReturnCode and ReturnLevel.
      vReportDef.Report.CurrentEntityName = szCurrentEntityName
      vReportDef.Report.HierReturnCode = lHierRC
      vReportDef.Report.LastLevel = lReturnLevel

      RETURN 1 // return indicating that there are MORE pages

   END

   // Process a Page Footer if necessary before returning.
   IF lPrintHTML = 1
      lPageHeight = lCurrentPosY + lFooterPosY
      lFooterPosY = lCurrentPosY
   END

   ProcessPageFooter( vReportDef, vSourceHierOI, vSubtask,
                      lNewPosX, lNewPosY, lCurrentPosX, lFooterPosY,
                      lPageWidth, lPageHeight, lFlags )

   // We cannot do this since we need the view to reprint a page in preview
   // mode.
// IF vSourceHierOI != 0
//    DropView( vSourceHierOI ) // Done with hierarchical view, so drop it.
// END

   RETURN 0  // return indicating that this is the LAST page

END

/////////////////////////////////////////////////////////////////////////////
//
// Using the Group control and its Text subcontrols, format the data on the
// page starting at CurrentPosX and CurrentPosY.  Then return the new PosY,
// which would normally be the starting position for the next Group.
// We will process the Group that has cursor position in view vReportDef.
// We will assume here that the Group size is correct and that all the Text
// X and Y positions within the Group are correct. Well, not quite. See the
// note in the code below on sizing relative to the corrections needed for
// handling multi-line text controls.
// Generally speaking, this routine will only be called when we are
// assured that the entire Group set will fit into the remaining space
// on the page. However, there are 2 notable exceptions:
// 1. If the detail Group contains a multi-line text control, the size Y
//    of the control cannot be determined until print time and thus, it
//    may force an over run off of the page -- see the notes in the code
//    below on sizing.
// 2. If the detail Group has a flag set in the report def (to be added at
//    a later time) then we will allow for the Group to be broken from one
//    page to the next.
// This routine will return:
// 0  - If the entire Group set fit onto the page and
// -1 - If the Group set was only partially printed on the current page.
//      In this case, the Group set must be continued to be printed on the
//      next page. If printing on the current page is stopped in the middle
//      of printing a multi-line text control, vReportDef.Report.MultiLineTextPos
//      will be set to point to the first unprinted word in the control's text
//      string.  Otherwise, this attribute will be set to 0. In either case,
//      vReportDef.Report.ContinuedGroupFlag will be set > 0 to indicate
//      that printing of the Group needs to be continued on the next page.
//       -1 - indicate printing last page footer
//        1 - printing is in the middle of a multi-line text
//        2 - current control would not fit so use TopRange to adjust BottomRange
//      printing of the Group needs to be continued on the next page.
// Later we will put a box around the Group of data, depending on information
// in the Group.
//
/////////////////////////////////////////////////////////////////////////////

TRANSFORMATION OPERATION
fnFormatGroupOnPage( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                     VIEW    vSourceHierOI,
                     VIEW    vSubtask,
                     INTEGER plNewPosX,
                     INTEGER plNewPosY,
                     INTEGER lCurrentPosX,    // position of Group on page
                     INTEGER lCurrentPosY,    // position of Group on page
                     INTEGER lRemainingSpaceOnPageY,
                     INTEGER lContinuedGroupFlag,
                     INTEGER lPageWidth,
                     INTEGER lPageHeight,
                     INTEGER lOrigRemainingSpaceOnPageY,
                     INTEGER lFooterPosPageBottom )

   VIEW         vSourceOI
   VIEW         vReportTmp
   VIEW         vMappingOI
   VIEW         vSourceOrigOI
   INTEGER      lOrigPosY         // original y-position of control on page
   INTEGER      lRemainingSpaceOnPageStart
   INTEGER      lPagePosMaxX      // position of control on page
   INTEGER      lPagePosX         // position of control on page
   INTEGER      lPagePosY         // position of control on page
   INTEGER      lPagePosEndX      // end position of control on page
   INTEGER      lPagePosEndY      // end position of control on page
   INTEGER      lEndPosY          // bottom of multi-line control
   INTEGER      lNextWord         // begining of next word to print in multi-line text
   INTEGER      lMultiLineAdjustment // Adjustment +/- to posY to deal with multi-line
   INTEGER      lMultiLineIncrement  // Amount multi-line added to Group size
   INTEGER      lMaxSizeY   // temp value for max y size for all controls on same line
   INTEGER      lMultiLineSizeY   // temp value for actual size of multi-line
                                  // control after print
   INTEGER      lAdjust
   INTEGER      lTemp
   INTEGER      lStartBottomAdjustment
   INTEGER      lContinuedGroupAdjustment
   INTEGER      lRangeBottom
   INTEGER      lRemainingSpaceForCurrentLine
   INTEGER      lTextAddress // will hold the address of print text in multi-line case
   INTEGER      lCtrlBOI
   STRING (32766) szWorkString
   STRING (256) szViewName
   STRING (32)  szEntityName
   STRING (32)  szAttributeName
   STRING (32)  szContextName
   STRING (32)  szFaceName      // LF_FACENAME is 32
   STRING (32)  szCtrlTag
   STRING (10)  szQueryOperation
   STRING (256) szClass
   STRING (32)  szYN
   SHORT        nRectangleFlag
   SHORT        nRoundRectFlag
   SHORT        nEllipseFlag
   SHORT        nDiamondFlag
   SHORT        nHorizontalFlag
   SHORT        nVerticalFlag
   SHORT        nDiagDescendFlag
   SHORT        nDiagAscendFlag
   SHORT        nMultiLineFlag
   SHORT        nBoldFlag
   SHORT        nItalicFlag
   SHORT        nStrikeoutFlag
   SHORT        nUnderlineFlag
   STRING (2)   szOverrideHide
   SHORT        nHide
   INTEGER      lJustify
   INTEGER      lWork
   INTEGER      lFontSize
   INTEGER      lDefaultFontSize
   INTEGER      lTextColor
   INTEGER      lTextBkColor
   INTEGER      lBorderStyle
   INTEGER      lBorderColor
   INTEGER      lEscapement
   INTEGER      lType
   INTEGER      lPenWidth
   INTEGER      lPenType
   INTEGER      lPenColor
   INTEGER      lRoundValue
   INTEGER      lBackgroundColor
   INTEGER      lFlags            // Shape Flags attribute
   INTEGER      lPrintFlags
   INTEGER      lPrintHTML
   INTEGER      lPrintCSV
   INTEGER      lColumnCSV
   SHORT        bTopOfPage
   SHORT        bCurrentGroupCanContinue
   SHORT        bProcessedMultiLine
   SHORT        nSkipFlag
   SHORT        nLoop1

   SHORT        nRptExitEvent
   SHORT        nRptExitReturn
   STRING (32)  szRptExitOper

   INTEGER      lLastPage
   INTEGER      lPageNbr
   INTEGER      lTotalPageCnt
   SHORT        nRC

//UNDEF INTEGER lTempView
   STRING (32) szRptGroupSetTag
   STRING (32) szRptGroupTag
   szRptGroupSetTag = vReportDef.GroupSet.Tag
   szRptGroupTag = vReportDef.Group.Tag
//UNDEF
//UNDEF TraceLineI( "Formatting GroupSet/Group RemainingSpace: ",
//UNDEF             lRemainingSpaceOnPageY )
//UNDEF TraceLineS( "GroupSet: ", szRptGroupSetTag )
//UNDEF TraceLineS( "   Group: ", szRptGroupTag )


   szWorkString = vReportDef.Report.Tag
   szWorkString = szWorkString + "PrintDraftWithoutForm"
   SysReadZeidonIni( -1, "[Workstation]", szWorkString, szOverrideHide )

   lPrintFlags = vReportDef.Report.PrintFlags
   nRC = IsFlagSequenceSet( lPrintFlags, 256 )
   IF nRC = 0
      lPrintHTML = 0
      nRC = IsFlagSequenceSet( lPrintFlags, 128 )
      IF nRC = 0
         lPrintCSV = 0
      ELSE
         lPrintCSV = 1
         IF vReportDef.Control EXISTS
            lRangeBottom = vReportDef.Control.RangeBottom
         END
      END
   ELSE
      lPrintHTML = 1
      lPrintCSV = 0
   END

   lPageNbr = vReportDef.Report.CurrentPageNbr
   lTotalPageCnt = vReportDef.Report.TotalPageCnt

// TraceLineI( "Footer PageNumber: ", lPageNbr )
// TraceLineI( "Footer TotalPages: ", lTotalPageCnt )
   IF (lTotalPageCnt > 0 AND lPageNbr = lTotalPageCnt) OR
      lPrintHTML != 0 OR lPrintCSV != 0

      lLastPage = 1
   ELSE
      lLastPage = 0
   END

   lPagePosMaxX = 0
   plNewPosX = lCurrentPosX
   lMultiLineIncrement = 0
   lOrigPosY = lCurrentPosY
   lRemainingSpaceOnPageStart = lRemainingSpaceOnPageY
   lRangeBottom = 1
   lStartBottomAdjustment = 0
   lContinuedGroupAdjustment = 0
   bProcessedMultiLine = 0
   IF lRemainingSpaceOnPageY = lOrigRemainingSpaceOnPageY
      bTopOfPage = TRUE
   ELSE
      bTopOfPage = FALSE
   END
   IF vReportDef.GroupSet.Type = "E" AND    // entity GroupSet
      vReportDef.Group.Type = "ga"   // entity Group detail

      bCurrentGroupCanContinue = TRUE
   ELSE
      bCurrentGroupCanContinue = FALSE
   END

   // Position of controls as stored in the Report Def are relative
   // to the beginning of Group.  The actual position of the Group on
   // on the page (i.e. relative to the beginning of the page rather than
   // the beginning of the Group set) is passed in by lCurrentPosX and
   // lCurrentPosY.
   //
   // Both of the print routines used below require positions on the
   // actual page.  For that reason, we calculate the positions of the
   // controls on the page in lPagePosX and lPagePosY.
   //
   // One problem here is dealing with multi-line text controls.
   // With multi-line text controls, the size in the Y direction
   // cannot be determined ahead of time.  The size is determined
   // by DrawMultiLineTextToReport and is returned as a parameter.
   //
   // To compensate for this ambiguity, an adjustment factor is
   // calculated whenever we print multi-line text.  This factor
   // is added to all control Y positions and may be negative
   // if the amount of space used is actually less than the allotted
   // size recorded in the report def.
   lMultiLineAdjustment = 0
   lRemainingSpaceForCurrentLine = 0

   // Get the default font size.
   lDefaultFontSize = vReportDef.Report.ReportTextSize
   szWorkString = "ReportFont"
   nRC = GetWorkstationApplicationValues( vSubtask, szWorkString,
                                          szFaceName, 32, lFontSize,
                                          lWork, lWork, lWork, lWork,
                                          lWork, lWork, lWork, lWork, lWork )
   IF lDefaultFontSize = 0
      lDefaultFontSize = lFontSize
   END

   // We will use a temporary view for vSourceHierOI because the operation,
   // GetStringFromAttributeByContext calls operations that will not allow
   // a hierarchical cursor.
   IF vSourceHierOI != 0
   // CreateViewTrace( "Creating view (18): ", vSourceOI, vSourceHierOI, 0 )
      CreateViewFromViewForTask( vSourceOI, vSourceHierOI, 0 )
      NAME VIEW vSourceOI "-->vSourceI2"
   ELSE
      vSourceOI = 0
   END

   // Loop through the Text controls and format each on the Report page.
   // If we are formatting a continued Group (from the previous page),
   // we will assume that the views to vReportDef and vSourceHierOI still
   // point to the correct entities.  If we are formatting a new Group,
   // we will start with the first control for the Group.

   IF lContinuedGroupFlag > 0
      // Subtract the position of the first continued control to
      // adjust for starting in the middle of a Group. recall that
      // control positions are relative to the beginning of the Group
      // which here is passed in as lCurrentPosY.
      lMultiLineAdjustment = lMultiLineAdjustment - vReportDef.Control.PSDLG_Y
      lContinuedGroupFlag = vReportDef.PageState.ContinuedGroupFlagStartPage
      IF lContinuedGroupFlag = 1
         lStartBottomAdjustment = vReportDef.Control.RangeBottom
      ELSE
         lStartBottomAdjustment = vReportDef.Control.RangeTop
         // NOTE: above eliminates the space between ranges after a page break
         //       we may need to also set the MultilineINCREMENT to be negative
         //       by the amount of this space to ensure proper control position.
      END

      bProcessedMultiLine = 1
      // need to position the ReportDef to the continued control
      // since group header / footer processing could have moved it.
   // nLoop1 = zCURSOR_SET
      szWorkString = vReportDef.PageState.ContinuedControlTagStartPage
      nLoop1 = SetCursorFirstEntityByString( vReportDef, "Control", "Tag",
                                             szWorkString, "" )
      IF nLoop1 < zCURSOR_SET
         TraceLineS( "Report Internal Error: Continuation control not found.", "" )
         TraceLineS( "     GroupSet: ", szRptGroupSetTag )
         TraceLineS( "        Group: ", szRptGroupTag )
         TraceLineS( "      Control: ", szWorkString )
//UNDEF ELSE
//UNDEF  TraceLineS( "Continuation control set to : ", szWorkString )
//UNDEF  TraceLineS( "                    GroupSet: ", szRptGroupSetTag )
//UNDEF  TraceLineS( "                       Group: ", szRptGroupTag )
      END
      nRptExitEvent = zRGE_EVENT_GROUP_CONTINUE
   ELSE
      nLoop1 = SetCursorFirstEntity( vReportDef, "Control", "" )
      nRptExitEvent = zRGE_EVENT_PREPRINT
      fnSetGroupCtrlStatus( vReportDef,
                            zRCONTROL_STATUS_NOTPRINTED )  //not yet printed
   END

   szRptExitOper = vReportDef.Group.wOperName
   nRptExitReturn = InvokeReportExitCode( vSubtask, vReportDef,
                                          szRptExitOper, nRptExitEvent,
                                          lPageNbr, vSourceOI )
   IF nRptExitReturn = zRGE_RETURN_SUPPRESS
//UNDEF TraceLineI( "Exit Suppressed Formatting GroupSet/Group at PosY: ",
//UNDEF             lCurrentPosY )
//UNDEF TraceLineS( "     GroupSet: ", szRptGroupSetTag )
//UNDEF TraceLineS( "        Group: ", szRptGroupTag )
//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineS( "FormatGroupOnPage returning 0", "" )
//UNDEF END

      plNewPosY = lCurrentPosY
      IF vSourceOI != 0
      // DropViewTrace( "Dropping view (17): ", vSourceOI )
         DropView( vSourceOI )
         vSourceOI = 0
      END

      RETURN 0
   END
   IF nRptExitReturn = zRGE_RETURN_NEWPAGE
      IF nRptExitEvent = zRGE_EVENT_GROUP_CONTINUE
         TraceLineS( "zRGE_RETURN_NEWPAGE return from Exit ignored for ",
                     "zRGE_EVENT_GROUP_CONTINUE" )
      ELSE
 //UNDEF TraceLineI( "Exit Forced New Page GroupSet/Group at PosY: ",
 //UNDEF             lCurrentPosY )
 //UNDEF TraceLineS( "     GroupSet: ", szRptGroupSetTag )
 //UNDEF TraceLineS( "        Group: ", szRptGroupTag )
 //UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
 //UNDEF    TraceLineS( "FormatGroupOnPage returning -1", "" )
 //UNDEF END

         vReportDef.PageState.MultiLineTextPosEndPage = 0
         vReportDef.PageState.ContinuedGroupFlagEndPage = 2

         lRemainingSpaceOnPageY = 0
         plNewPosY = lFooterPosPageBottom

         IF vSourceOI != 0
         // DropViewTrace( "Dropping view (18): ", vSourceOI )
            DropView( vSourceOI )
            vSourceOI = 0
         END

         RETURN -1
      END
   END

   // We will adjust lRemainingSpaceOnPageY by lRemainingSpaceAdjustment when
   // we have finished the loop.  lRemainingSpaceAdjustment is set to the
   // size of the current Group plus any multi-line increments.

   // Before we start the loop, we adjust lRemainingSpaceOnPageY by
   // the y pos of the 1st control. We assume here that this routine
   // will not get called unless there was room to print something and
   // thus, lRemainingSpaceOnPageY will get reset in some fashion anyway.
//xlRemainingSpaceOnPageY = lRemainingSpaceOnPageY - vReportDef.Control.PSDLG_Y

// nRC = CreateViewTrace( "Creating view (19): ", vReportTmp, vReportDef, 0 )
   nRC = CreateViewFromViewForTask( vReportTmp, vReportDef, 0 )
   LOOP WHILE nLoop1 = zCURSOR_SET

      lWork = vReportDef.Control.Subtype
      IF szOverrideHide = "Y"
         nHide = 0
      ELSE
         nHide = IsFlagSequenceSet( lWork, 4096 )  // 0x00001000
      END

      IF lPrintCSV = 1

         lWork = vReportDef.Control.RangeBottom
         IF lWork != lRangeBottom
            PrintTextToCSV( vSubtask, 0, 0 )
         END

         lRangeBottom = lWork

         lColumnCSV = vReportDef.Control.ColumnCSV
         IF lColumnCSV > 0

         IF vReportDef.CtrlMapView EXISTS

            // Get text value to put on report AND GET AN ADDRESS TO IT.
            // If there is mapping on the report (determined by the existence
            // of the CtrlMapView entity), use it to get the text value.
            // Get text value to put on report AND STORE IT IN szWorkString.
            szEntityName = vReportDef.CtrlMapRelatedEntity.Name
            szAttributeName = vReportDef.CtrlMapER_Attribute.Name
            IF vReportDef.CtrlMapContext EXISTS
               szContextName = vReportDef.CtrlMapContext.Name
            ELSE
               szContextName = ""
            END

            // For mapping, we can have either vSourceOI, which is for
            // the hier view driving the report, or any other mapping
            // view.  We will determine this by getting the mapping view
            // for the control and comparing it to the original hier view.
            szViewName = vReportDef.CtrlMapView.Name
            nRC = GetViewByName( vMappingOI, szViewName,
                                 vSubtask, zLEVEL_ANY )
            IF nRC >= 0
            // GET VIEW vSourceOrigOI NAMED "TZ_SourceOrigOI"
               szViewName = "TZ_SourceOrigOI"
               nRC = GetViewByName( vSourceOrigOI, szViewName,
                                    vSubtask, zLEVEL_ANY )
               IF vMappingOI = vSourceOrigOI
                  vMappingOI = vSourceOI
               END
            ELSE
               szWorkString = "Report cannot get view by name for View.Entity.Attribute: " +
                                          szViewName + "." + szEntityName + "." + szAttributeName
               TraceLineS( szWorkString, "" )
            // szWorkString = ""
            END

            IF vReportDef.Control.wQueryOperation != ""
               // Query Operation
               szQueryOperation = vReportDef.Control.wQueryOperation

               // The following code creates the pointer, lTextAddress, as
               // explained below.
               lTextAddress = MakeIntegerFromPointer( szWorkString )
               ComputeQueryOperationValue( vReportDef, vMappingOI, szWorkString,
                                           szQueryOperation, szEntityName,
                                           szAttributeName )
            ELSE
               // Regular Mapping
               IF vMappingOI = 0
                  nRC = 1
               ELSE
                  nRC = CheckExistenceOfEntity( vMappingOI, szEntityName )
               END

               IF nRC = 0
                  GetAttributeDisplayLength( lWork, vMappingOI,
                                             szEntityName, szAttributeName, "" )
                  IF lWork > 32764
                     GetAddrForAttribute( lTextAddress, vMappingOI,
                                          szEntityName, szAttributeName )
                  ELSE
                     // The following code creates the pointer, lTextAddress,
                     // to szWorkString, because lTextAddress is the variable
                     // used later in a call.
                     lTextAddress = MakeIntegerFromPointer( szWorkString )
                     GetStringFromAttributeByContext( szWorkString, vMappingOI,
                                                      szEntityName,
                                                      szAttributeName,
                                                      "", 32764 )
                  END
               ELSE
                  lWork = 0
                  lTextAddress = 0
                  szWorkString = ""
               END
            END

         ELSE  // Ctrl has no Mapping.

            szWorkString = vReportDef.Control.Text

         END

         IF nHide = 0
            PrintTextToCSV( vSubtask, szWorkString, lColumnCSV )
         ELSE
            PrintTextToCSV( vSubtask, "", lColumnCSV )
         END

         END  // IF lColumnCSV > 0

      ELSE

      // Check to see if the next control will fit onto the page.
      // Since controls can be placed horizontally in an overlapping
      // manner, we must consider the longest of the overlapping controls.
      // This was taken into consideration in the Painter by computing
      // Control.RangeBottom.  We will also consider whether the last
      // controls in the Group were actually truncated by the Group size
      // itself.

      // Find the max y size on this line.
      lWork = vReportDef.Control.RangeBottom

      IF lPrintHTML = 1   // this is to put in line breaks
         IF lWork != lRangeBottom
            PrintTextToHTML( vSubtask, vMappingOI, 0, "",
                             0, 0, 0, 0, 0, 0, 0, 0, 0 )
         END
      END

      lRangeBottom = lWork
      lMaxSizeY = vReportDef.Group.SZDLG_Y
      IF lMaxSizeY > lRangeBottom
         lMaxSizeY = lRangeBottom
      END

      lMaxSizeY = lMaxSizeY - lStartBottomAdjustment
//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/ AND
//UNDEF     lStartBottomAdjustment != 0
//UNDEF    TraceLineI( ">> lMaxSizeY decremented to: ", lMaxSizeY )
//UNDEF    TraceLineI( "   by lStartBottomAdjustment: ",
//UNDEF                lStartBottomAdjustment )
//UNDEF END

      lMaxSizeY = lMaxSizeY + lMultiLineIncrement
//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/ AND
//UNDEF     lMultiLineIncrement != 0
//UNDEF    TraceLineI( ">> lMaxSizeY incremented to: ", lMaxSizeY )
//UNDEF    TraceLineI( "      by MultiLineIncrement: ", lMultiLineIncrement )
//UNDEF END

      // If there isn't room for the current control (unless we are at the
      // top of the page), return to caller, indicating that the Group is
      // only partly processed.  This could occur because a multi-line
      // control forced the other controls in the Group off the page.  The
      // -1 return code indicates a continued Group.
      // Also set the multi-line current position value in the Page entity to
      // 0 to indicate we are not breaking in the middle of a multi-line text
      // control.
      IF bTopOfPage = FALSE AND // OLD WAS ==> AND lOrigRemainingSpace < lMaxSizeY
         (lRemainingSpaceOnPageStart < lMaxSizeY OR
          lRemainingSpaceOnPageY < 1) // this is an extra safety check

         vReportDef.PageState.MultiLineTextPosEndPage = 0
         vReportDef.PageState.ContinuedGroupFlagEndPage = 2
         vReportDef.PageState.ContinuedControlTagEndPage = vReportDef.Control.Tag

         // Nothing is printed so this is our new Y pos.
         plNewPosY = lCurrentPosY

         nRptExitEvent = zRGE_EVENT_GROUP_SPLITTING
         nRptExitReturn = InvokeReportExitCode( vSubtask, vReportDef,
                                                szRptExitOper, nRptExitEvent,
                                                lPageNbr, vSourceOI )
         IF nRptExitReturn != 0
            TraceLineI( "Non-zero return from Exit ignored for zRGE_EVENT_GROUP_SPLITTING: rc=",
                        nRptExitReturn )
         END

         IF vSourceOI != 0
         // DropViewTrace( "Dropping view (19): ", vSourceOI )
            DropView( vSourceOI )
            vSourceOI = 0
         END

//UNDEF  IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF     TraceLineI( "FormatGroupOnPage returning -1 MaxSizeY: ",
//UNDEF                 lMaxSizeY )
//UNDEF     TraceLineI( "                            RangeBottom: ",
//UNDEF                 lRangeBottom )
//UNDEF     TraceLineI( "                     MultiLineIncrement: ",
//UNDEF                 lMultiLineIncrement )
//UNDEF     TraceLineI( "                   RemainingSpaceOnPage: ",
//UNDEF                 lRemainingSpaceOnPageY )
//UNDEF  END

      // DropViewTrace( "Dropping view (20): ", vReportTmp )
         DropView( vReportTmp )
         vReportTmp = 0

         RETURN -1

      END

//UNDEF szWorkString = vReportDef.Control.Tag

      lPagePosX = vReportDef.Control.PSDLG_X + vReportDef.Group.PSDLG_X
      lPagePosX = lPagePosX + plNewPosX
      IF lPagePosMaxX < lPagePosX
         lPagePosMaxX = lPagePosX
      END

      lPagePosY = vReportDef.Control.PSDLG_Y + lMultiLineAdjustment +
                  lOrigPosY + lMultiLineIncrement

//UNDEF TraceLineS( "Current Ctrl: ", szWorkString )
//UNDEF TraceLineI( " CurrentPosY: ", lCurrentPosY )
//UNDEF lWork = vReportDef.Control.RangeTop
//UNDEF TraceLineI( " RangeTop: ", lWork )
//UNDEF TraceLineI( " RangeBottom: ", lRangeBottom )

      // IF the SuppressEmptyTextControls flag has been set for the report
      // and IF this Group is a detail Group
      // and IF this Group is vertical
      // and IF there is another control on the same line as the current ctrl
      // and IF that control has data mapping
      // and IF the text string that is mapped to the control is empty
      // THEN... we have a set of controls which should be skipped.
      // So, to make the skip happen, we will print nothing and we will adjust
      // the run-time adjustment, lMultiLineAdjustment, in a negative manner.
      nSkipFlag = 0   // 0 = false
      SetViewFromView( vReportTmp, vReportDef )
      SET CURSOR NEXT vReportTmp.Control
      IF RESULT >= zCURSOR_SET AND
         vReportDef.Report.SuppressEmptyTextFields = "Y" AND
         vReportDef.Group.Type = "ga" AND
         vReportDef.Control.Type = 10 AND // 10 vertical controls
         vReportTmp.CtrlMapView EXISTS

         szEntityName = vReportTmp.CtrlMapRelatedEntity.Name
         szAttributeName = vReportTmp.CtrlMapER_Attribute.Name
         IF vReportDef.CtrlMapContext EXISTS
            szContextName = vReportDef.CtrlMapContext.Name
         ELSE
            szContextName = ""
         END

         // For mapping, we can have either vSourceOI, which is for the hier
         // view driving the report, or any other mapping view.  We will
         // determine this by getting the mapping view for the control and
         // comparing it to the original hier view.
         szViewName = vReportTmp.CtrlMapView.Name
         nSkipFlag = 1
      // GET VIEW vMappingOI NAMED szViewName
         nRC = GetViewByName( vMappingOI, szViewName, vSubtask, zLEVEL_ANY )
         IF nRC >= 0
         // GET VIEW vSourceOrigOI NAMED "TZ_SourceOrigOI"
            szViewName = "TZ_SourceOrigOI"
            RESULT = GetViewByName( vSourceOrigOI, szViewName, vSubtask, zLEVEL_ANY )
            IF vMappingOI = vSourceOrigOI
               vMappingOI = vSourceOI
            END

            IF vMappingOI = 0
               nRC = 1
            ELSE
               nRC = CheckExistenceOfEntity( vMappingOI, szEntityName )
            END

            IF nRC = 0
               GetStringFromAttributeByContext( szWorkString, vMappingOI,
                                                szEntityName, szAttributeName,
                                                szContextName, 32764 )
               IF szWorkString != ""
                  nSkipFlag = 0     // 0 = don't skip
               END
            END
         END
      END

      // If we need to skip this line and both controls on this line
      IF nSkipFlag > 0
         lMultiLineAdjustment = lMultiLineAdjustment -
                                                  vReportDef.Control.SZDLG_Y
         SetCursorNextEntity( vReportDef, "Control", "" )

      ELSE
      lPagePosEndX = lPagePosX + vReportDef.Control.SZDLG_X
      lPagePosEndY = lPagePosY + vReportDef.Control.SZDLG_Y
      IF lPagePosMaxX < lPagePosEndX
         lPagePosMaxX = lPagePosEndX
      END

//UNDEF TraceLineI( " Current Ctrl StartPos Y: ", lPagePosY )

      szCtrlTag = vReportDef.Control.Tag
      IF lLastPage = 1
         lTemp = 0
      ELSE
      // TraceLineS( "FormatGroup Ctrl: ", szCtrlTag )
         lTemp = ZeidonStringFind( szCtrlTag, 1, "LPO_" )  // LastPageOnly
      // TraceLineI( "         LPO Pos: ", lTemp )
      END

      IF lTemp > 0
         // do nothing here ... we are skipping this control
      ELSE
      IF vReportDef.ControlDef.Key = 3040   // Bitmap

         // TraceLineI( "Bitmap lPagePosX: ", lPagePosX )
         // TraceLineI( "Bitmap lPagePosY: ", lPagePosY )
         // TraceLineI( "Bitmap lPagePosEndX: ", lPagePosEndX )
         // TraceLineI( "Bitmap lPagePosEndY: ", lPagePosEndY )

         // Print the specified bitmap
         IF nHide = 0
            szEntityName = "Control"
            szAttributeName = "CtrlBOI"
            GetAddrForAttribute( lCtrlBOI, vReportDef,
                                 szEntityName, szAttributeName )

            IF lPrintHTML = 1
               nRC = PrintBitmapToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                        lPagePosEndX, lPagePosEndY, lCtrlBOI )
            ELSE
               nRC = DrawBitmapToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                         lPagePosEndX, lPagePosEndY, lCtrlBOI )
            END
         END

         vReportDef.Control.wPrintStatus = 3  // zRCONTROL_STATUS_PRINTED
         fnSetCtrlPrintValues( vReportDef, "", lPageNbr,
                               lPagePosX, lPagePosY )
      ELSE
      IF vReportDef.ControlDef.Key = 3050   // Shape

// TraceLineI( "Shape lPagePosX: ", lPagePosX )
// TraceLineI( "Shape lPagePosY: ", lPagePosY )
// TraceLineI( "Shape lPagePosEndX: ", lPagePosEndX )
// TraceLineI( "Shape lPagePosEndY: ", lPagePosEndY )

         // Print the specified shape
         nRC = SP_GetShapeCtrlBOI( vReportDef,
                                   nRectangleFlag, nRoundRectFlag,
                                   nEllipseFlag, nDiamondFlag,
                                   nHorizontalFlag, nVerticalFlag,
                                   nDiagDescendFlag, nDiagAscendFlag,
                                   lPenWidth, lPenType,
                                   lPenColor, lRoundValue,
                                   lBackgroundColor, lFlags )

         vReportDef.Control.wPrintStatus = 3  // zRCONTROL_STATUS_PRINTED
         fnSetCtrlPrintValues( vReportDef, "", lPageNbr,
                               lPagePosX, lPagePosY )

         IF nRectangleFlag != 0

            nRC = IsFlagSequenceSet( lFlags, 1 )
            IF nRC != 0
               lWork = lPagePosEndY
               lPagePosEndY = lFooterPosPageBottom - 10
            END

            IF lPrintHTML = 0
               IF nHide = 0
                  DrawRectangleToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                         lPagePosEndX, lPagePosEndY,
                                         lPenWidth, lPenType,
                                         lPenColor, 0, lBackgroundColor )
               END
            ELSE
               IF nHide = 0
                  PrintLineToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                   lPagePosEndX, lPagePosEndY,
                                   lPenWidth, lPenType,
                                   lPenColor, 0 )
               END
            END

            IF nRC != 0
               lPagePosEndY = lWork
            END
         END

         IF nRoundRectFlag != 0

            IF lRoundValue <= 0
               lRoundValue = 16
            END

            nRC = IsFlagSequenceSet( lFlags, 1 )
            IF nRC != 0
               lWork = lPagePosEndY
               lPagePosEndY = lFooterPosPageBottom - 10
            END

            IF lPrintHTML = 0
               IF nHide = 0
                  DrawRectangleToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                         lPagePosEndX, lPagePosEndY,
                                         lPenWidth, lPenType,
                                         lPenColor, lRoundValue, lBackgroundColor )
               END
            ELSE
               IF nHide = 0
                  PrintLineToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                   lPagePosEndX, lPagePosEndY,
                                   lPenWidth, lPenType,
                                   lPenColor, 0 )
               END
            END

            IF nRC != 0
               lPagePosEndY = lWork
            END
         END

         IF nEllipseFlag != 0 AND nHide = 0

            nRC = IsFlagSequenceSet( lFlags, 1 )
            IF nRC != 0
               lWork = lPagePosEndY
               lPagePosEndY = lFooterPosPageBottom - 10
            END

            IF lPrintHTML = 0
               DrawEllipseToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                    lPagePosEndX, lPagePosEndY,
                                    lPenWidth, lPenType, lPenColor,
                                    lBackgroundColor )
            ELSE
               PrintLineToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                lPagePosEndX, lPagePosEndY,
                                lPenWidth, lPenType,
                                lPenColor, 0 )
            END

            IF nRC != 0
               lPagePosEndY = lWork
            END
         END

         IF nDiamondFlag != 0 AND nHide = 0
            nRC = IsFlagSequenceSet( lFlags, 1 )
            IF nRC != 0
               lWork = lPagePosEndY
               lPagePosEndY = lFooterPosPageBottom - 10
            END

            IF lPrintHTML = 0
               DrawRectangleToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                      lPagePosEndX, lPagePosEndY,
                                      lPenWidth, lPenType,
                                      lPenColor, -1, lBackgroundColor )
            ELSE
               PrintLineToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                lPagePosEndX, lPagePosEndY,
                                lPenWidth, lPenType,
                                lPenColor, 0 )
            END

            IF nRC != 0
               lPagePosEndY = lWork
            END
         END

         IF nHorizontalFlag != 0 AND nHide = 0
            IF lPrintHTML = 1
               PrintLineToHTML( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                lPagePosEndX, lPagePosEndY,
                                lPenWidth, lPenType,
                                lPenColor, 0 )
            ELSE
               DrawLineToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                                 lPagePosEndX, lPagePosEndY,
                                 lPenWidth, lPenType,
                                 lPenColor, 0 )
            END
         END

         IF nVerticalFlag != 0 AND nHide = 0
            DrawLineToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                              lPagePosEndX, lPagePosEndY,
                              lPenWidth, lPenType,
                              lPenColor, 1 )
         END

         IF nDiagDescendFlag != 0 AND nHide = 0
            DrawLineToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                              lPagePosEndX, lPagePosEndY,
                              lPenWidth, lPenType,
                              lPenColor, 2 )
         END

         IF nDiagAscendFlag != 0 AND nHide = 0
            DrawLineToReport( vSubtask, vSourceOI, lPagePosX, lPagePosY,
                              lPagePosEndX, lPagePosEndY,
                              lPenWidth, lPenType,
                              lPenColor, 3 )
         END

      ELSE
         // If the Control has FontSize or Bold or Italic flags set,
         // create a temporary font with those characteristics and use it.
         // If not, use the default font.
         nRC = TX_GetTextRptCtrlBOI( vReportDef, nMultiLineFlag, nBoldFlag,
                                     nItalicFlag, nStrikeoutFlag,
                                     nUnderlineFlag, lJustify,
                                     lFontSize, lTextColor, lTextBkColor,
                                     lBorderStyle, lBorderColor,
                                     lEscapement, lType, szFaceName )

         // If the return code is <= 0, the CtrlBOI is null.
         IF nRC <= 0
            SelectFontForReport( vSubtask, "default" )
         ELSE
            IF lFontSize = 0
               lFontSize = lDefaultFontSize
            END

         // TraceLineI( "FormatGroupOnPage Font size: ", lFontSize )

            lEscapement = 0 - lEscapement
            CreateFontForReport( vSubtask, "control", lFontSize,
                                 nBoldFlag, nItalicFlag,
                                 nUnderlineFlag, nStrikeoutFlag,
                                 lTextColor, lTextBkColor,
                                 lEscapement, szFaceName )
            SelectFontForReport( vSubtask, "control" )
         END

         // PRINT TEXT

         // If Multi-line text.
         IF nMultiLineFlag = 1 AND vReportDef.CtrlMapView EXISTS

            // Get text value to put on report AND GET AN ADDRESS TO IT.
            // If there is mapping on the report (determined by the existence
            // of the CtrlMapView entity), use it to get the text value.
            // Otherwise, do no print at all.
            szEntityName = vReportDef.CtrlMapRelatedEntity.Name
            szAttributeName = vReportDef.CtrlMapER_Attribute.Name

            // For mapping, we can have either vSourceOI, which is for
            // the hier view driving the report, or any other mapping
            // view.  We will determine this by getting the mapping view
            // for the control and comparing it to the original hier view.
            szViewName = vReportDef.CtrlMapView.Name
         // GET VIEW vMappingOI NAMED szViewName
            nRC = GetViewByName( vMappingOI, szViewName, vSubtask, zLEVEL_ANY )
            IF nRC >= 0
            // GET VIEW vSourceOrigOI NAMED "TZ_SourceOrigOI"
               szViewName = "TZ_SourceOrigOI"
               nRC = GetViewByName( vSourceOrigOI, szViewName,
                                    vSubtask, zLEVEL_ANY )
               IF vMappingOI = vSourceOrigOI
                  vMappingOI = vSourceOI
               END
            ELSE
               szWorkString = "Report cannot get view by name: " + szViewName
               TraceLineS( szWorkString, "" )
            // szWorkString = ""
            END

            IF vMappingOI = 0
               nRC = 1
            ELSE
               nRC = CheckExistenceOfEntity( vMappingOI, szEntityName )
            END

            IF nRC = 0
//UNDEF        IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF           TraceLineS( " --> MultiLine Case : ", "TextAddress OK." )
//UNDEF        END
               GetAttributeDisplayLength( lWork, vMappingOI,
                                          szEntityName, szAttributeName, "" )
               IF lWork > 32764
                  GetAddrForAttribute( lTextAddress, vMappingOI,
                                       szEntityName, szAttributeName )
               ELSE
                  lTextAddress = MakeIntegerFromPointer( szWorkString )
                  GetStringFromAttributeByContext( szWorkString, vMappingOI,
                                                   szEntityName,
                                                   szAttributeName,
                                                   "", 32764 )
               END
            ELSE
//UNDEF        IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF           TraceLineS( " --> MultiLine Case : ", "TextAddress = 0" )
//UNDEF        END

               nRC = 0  // added to permit print of entire HTML when a view
                        // did not exist for the report ... dks 2005.12.22
               lWork = 0
               lTextAddress = 0
               szWorkString = ""
            END

            // If we are printing a continued Group, start printing
            // at the first unprinted word. Otherwise, start printing
            // at the beginning of the text.
            lNextWord = 0
            IF vReportDef.PageState.ContinuedGroupFlagStartPage > 0 AND
               lContinuedGroupFlag > 0

               IF bCurrentGroupCanContinue = TRUE
                  lNextWord = vReportDef.PageState.MultiLineTextPosStartPage
               END
            END

            // Do the print!  On return, lEndPosY will contain the amount of
            // space taken on the page by the multi-line text.
         // lPagePosEndX = lPagePosX + vReportDef.Control.SZDLG_X
            // Set lPagePosEndY to limit the amount of space to take.  This
            // is currently the same as the end of the page, but when we add
            // the option to prevent multiline text to grow beyond the size
            // of the text box defined, this limit will change
            lPagePosEndY = lFooterPosPageBottom

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineS( " --> Text for control : ", szWorkString )
//UNDEF        TraceLineI( " -->     start offset : ", lNextWord )
//UNDEF        TraceLineI( " --> RemainingSpaceOnPage: ", lRemainingSpaceOnPageY )
//UNDEF        TraceLineI( " -->            lPagePosY: ", lPagePosY )
//UNDEF        TraceLineI( " -->         lPagePosEndY: ", lPagePosEndY )
//UNDEF     END

            fnSetCtrlPrintValues( vReportDef, szWorkString, lPageNbr,
                                  lPagePosX, lPagePosY )

            IF lPrintHTML = 1
               IF nHide = 0
                  szClass = vReportDef.Control.CSS_Class
                  IF szClass != ""
                     szYN = vReportDef.Control.CSS_Font
                     IF szYN = "Y"
                       lType = lType + 16
                     END
                     szYN = vReportDef.Control.CSS_Position
                     IF szYN = "Y"
                       lType = lType + 32
                     END
                     szYN = vReportDef.Control.CSS_Size
                     IF szYN = "Y"
                       lType = lType + 64
                     END
                  END

                  PrintTextToHTML( vSubtask, vMappingOI, szWorkString,
                                   szClass, lPagePosX, lPagePosY,
                                   lPagePosEndX, lPagePosEndY, lJustify,
                                   lBorderStyle, lBorderColor, lEscapement,
                                   lType )
               END
            ELSE
            IF lTextAddress = 0 OR nHide = 1
               nRC = DrawMultiLineTextToReport( vSubtask, vMappingOI,
                                                "", lWork,
                                                lPagePosX, lPagePosY,
                                                lPagePosEndX, lPagePosEndY,
                                                lJustify, lBorderStyle,
                                                lBorderColor, lEscapement,
                                                lType, lEndPosY, lNextWord )
            ELSE
               nRC = DrawMultiLineTextToReport( vSubtask, vMappingOI,
                                                lTextAddress, lWork,
                                                lPagePosX, lPagePosY,
                                                lPagePosEndX, lPagePosEndY,
                                                lJustify, lBorderStyle,
                                                lBorderColor, lEscapement,
                                                lType, lEndPosY, lNextWord )
            END
            END

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineI( "     MultiLine EndPos Y: ", lEndPosY )
//UNDEF     END


            // If the end position is less than that determined by control
            // size, use control size instead to get more consistent looking
            // line spacing.
            lTemp = lPagePosY + vReportDef.Control.SZDLG_Y
            IF lTemp > lEndPosY
               lEndPosY = lTemp
            ELSE
               // Otherwise, the multi-line text took up more than one line
               // of space so we capture adjustment values.
               lEndPosY = lEndPosY + 1 // a classic fudge factor to open up
                                       // space between lines
               lTemp = lEndPosY - lTemp
               // Adjust the size of the set of controls being printed
               lMaxSizeY = lMaxSizeY + lTemp
//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineI( " --> increase lMaxSizeY to ", lMaxSizeY )
//UNDEF     END
               lMultiLineIncrement = lMultiLineIncrement + lTemp
            // lMultiLineAdjustment = lMultiLineAdjustment + lTemp
            END

            // In either case, record the size of this line ignoring previous
            // controls on this line
            lMultiLineSizeY = lEndPosY - lPagePosY

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineI( " --> lPagePosY = ", lPagePosY )
//UNDEF        TraceLineI( " --> lEndPosY = ", lEndPosY  )
//UNDEF        TraceLineI( " --> lMultiLineIncrement = ", lMultiLineIncrement )
//UNDEF        TraceLineI( " --> lMultiLineAdjustment = ",
//UNDEF                    lMultiLineAdjustment )
//UNDEF     END

            // If the text we just printed didn't fit on the page, make sure it
            // it is for an entity Group detail - otherwise, don't split.
            IF nRC = 1
               IF bCurrentGroupCanContinue = FALSE
                  TraceLineS( "WARNING: a multiline text field can ONLY be ",
                              "continued for an entity Detail Group." )
                  TraceLineS( "         GroupSet: ", vReportDef.GroupSet.Tag )
                  TraceLineS( "         Group   : ", vReportDef.Group.Tag )
                  TraceLineS( "         Control : ", vReportDef.Control.Tag )
                  TraceLineI( "         Text truncated to (chars): ",
                              lNextWord )
                  nRC = 0  // turn off continuation
               END
            END
            // If the text we just printed didn't fit on the page, return now.
            IF nRC = 1
               // Store offset to first unprinted word in multi-line text.
               vReportDef.PageState.MultiLineTextPosEndPage = lNextWord
            // TraceLineI( "FormatGroupOnPage MultiLineTextPos: ", lNextWord )
               vReportDef.PageState.ContinuedGroupFlagEndPage = 1
               vReportDef.PageState.ContinuedControlTagEndPage =
                                                       vReportDef.Control.Tag

               plNewPosY = lOrigPosY + vReportDef.Group.SZDLG_Y +
                                                         lMultiLineAdjustment
               vReportDef.Control.wPrintStatus = 2 // zRCONTROL_STATUS_PARTIALPRINT
               nRptExitEvent = zRGE_EVENT_GROUP_SPLITTING
               nRptExitReturn = InvokeReportExitCode( vSubtask, vReportDef,
                                                      szRptExitOper,
                                                      nRptExitEvent,
                                                      lPageNbr, vSourceOI )
               IF nRptExitReturn != 0
                  TraceLineI( "Non-zero return from Exit ignored for zRGE_EVENT_GROUP_SPLITTING: rc=",
                              nRptExitReturn )
               END
               IF vSourceOI != 0
//UNDVV           IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV              TraceLineV( "(FormatGroupOnPage.MultiLine) DropView( vSourceOI ): ",
//UNDVV                          vSourceOI )
//UNDVV           END
               // DropViewTrace( "Dropping view (21): ", vSourceOI )
                  DropView( vSourceOI )
                  vSourceOI = 0
               END

//UNDEF        IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF           TraceLineS( "FormatGroupOnPage returning -1", " MultiLine" )
//UNDEF        END

            // DropViewTrace( "Dropping view (22): ", vReportTmp )
               DropView( vReportTmp )
               vReportTmp = 0

               RETURN -1

            ELSE

               // Clear offset that may have been stored in previous iteration
               IF bCurrentGroupCanContinue = TRUE
                  vReportDef.PageState.MultiLineTextPosEndPage = 0
                  // PAS 08Nov01 - make sure we don't continue the Group.
                  vReportDef.PageState.ContinuedGroupFlagEndPage = 0
               END

               vReportDef.Control.wPrintStatus = 3  // zRCONTROL_STATUS_PRINTED
            END

         ELSE  // Not MultiLine Text ... or if it is, it has no Mapping.

            // Get text value to put on report AND STORE IT IN szWorkString.
            // If there is mapping on the report, use it to get the text
            // value.  (We will determine this by the existence of the
            // entity CtrlMapView.)  If there is no mapping on the report,
            // use the Text attribute value from the ReportDef.
            IF vReportDef.CtrlMapView EXISTS

               szEntityName = vReportDef.CtrlMapRelatedEntity.Name
               szAttributeName = vReportDef.CtrlMapER_Attribute.Name
               IF vReportDef.CtrlMapContext EXISTS
                  szContextName = vReportDef.CtrlMapContext.Name
               ELSE
                  szContextName = ""
               END

               // For mapping, we can have either vSourceOI, which is for
               // the hier view driving the report, or any other mapping
               // view.  We will determine this by getting the mapping view
               // for the control and comparing it to the original hier view.
               szViewName = vReportDef.CtrlMapView.Name
            // GET VIEW vMappingOI NAMED szViewName
               nRC = GetViewByName( vMappingOI, szViewName,
                                    vSubtask, zLEVEL_ANY )
               IF nRC >= 0
               // GET VIEW vSourceOrigOI NAMED "TZ_SourceOrigOI"
                  szViewName = "TZ_SourceOrigOI"
                  nRC = GetViewByName( vSourceOrigOI, szViewName,
                                       vSubtask, zLEVEL_ANY )
                  IF vMappingOI = vSourceOrigOI
                     vMappingOI = vSourceOI
                  END

                  IF vReportDef.Control.wQueryOperation != ""
                     // Query Operation
                     szQueryOperation = vReportDef.Control.wQueryOperation
                     ComputeQueryOperationValue( vReportDef, vMappingOI,
                                                 szWorkString,
                                                 szQueryOperation,
                                                 szEntityName,
                                                 szAttributeName )
                  ELSE
                     // Regular Mapping
                     IF vMappingOI = 0
                        nRC = 1
                     ELSE
                        nRC = CheckExistenceOfEntity( vMappingOI,
                                                      szEntityName )
                     END
                     IF nRC = 0
                        nRC = GetStringFromAttributeByContext( szWorkString,
                                                               vMappingOI,
                                                               szEntityName,
                                                               szAttributeName,
                                                               szContextName,
                                                               32764 )
                        IF nRC < 0
                           szWorkString = "Report cannot get View.Entity.Attribute.Context: " +
                                          szViewName + "." + szEntityName + "." + szAttributeName + "." + szContextName
                           TraceLineS( szWorkString, "" )
                           szWorkString = ""
                        END
                     ELSE
                        szWorkString = ""
                     END
                  END
               ELSE
                  szWorkString = "Report cannot get view by name for View.Entity.Attribute: " +
                                          szViewName + "." + szEntityName + "." + szAttributeName
                           TraceLineS( szWorkString, "" )
                  TraceLineS( szWorkString, "" )
               // szWorkString = ""
               END
            ELSE
               szWorkString = vReportDef.Control.Text
            END

// TraceLineS( " --> Single Line Case : ", "" )
// TraceLineS( " --> Text for control : ", szWorkString )
            lMultiLineSizeY = 0

         // lPagePosEndX = lPagePosX + vReportDef.Control.SZDLG_X
         // lPagePosEndY = lPagePosY + vReportDef.Control.SZDLG_Y

//          // Prior to putting the Text on the report, we will check if the
//          // text is to be right justified (the Control Subtype is 16777216,
//          // which is zCONTROL_RIGHTJUSTIFY).
// we now   IF vReportDef.Control.Subtype = 167772
// determine      // the final parameter defines the type of justification.
// justification  // 1 = right justify
// above          // 2 = center justify

            fnSetCtrlPrintValues( vReportDef, szWorkString, lPageNbr,
                                  lPagePosX, lPagePosY )

            IF nHide = 1
               szWorkString = ""
            END

            IF lPrintHTML = 1
               IF nHide = 0
                  szClass = vReportDef.Control.CSS_Class
                  IF szClass != ""
                     szYN = vReportDef.Control.CSS_Font
                     IF szYN = "Y"
                       lType = lType + 16
                     END
                     szYN = vReportDef.Control.CSS_Position
                     IF szYN = "Y"
                       lType = lType + 32
                     END
                     szYN = vReportDef.Control.CSS_Size
                     IF szYN = "Y"
                       lType = lType + 64
                     END
                  END

                  PrintTextToHTML( vSubtask, vMappingOI, szWorkString,
                                   szClass, lPagePosX, lPagePosY,
                                   lPagePosEndX, lPagePosEndY, lJustify,
                                   lBorderStyle, lBorderColor, lEscapement,
                                   lType )
               END
            ELSE
            // It could still be multi-line with no Mapping.
            IF nMultiLineFlag = 1

               lType = lType + 1
               lJustify = lJustify + 512  // add word break flag

               lWork = zstrlen( szWorkString )
               DrawMultiLineTextToReport( vSubtask, vMappingOI,
                                          szWorkString, lWork,
                                          lPagePosX, lPagePosY,
                                          lPagePosEndX, lPagePosEndY,
                                          lJustify, lBorderStyle,
                                          lBorderColor, lEscapement,
                                          lType, lEndPosY, lNextWord )

            ELSE

               IF nMultiLineFlag = 2  // Fixed height
                  lType = 2
               END

               DrawTextToReport( vSubtask, vMappingOI, szWorkString,
                                 lPagePosX, lPagePosY,
                                 lPagePosEndX, lPagePosEndY, lJustify,
                                 lBorderStyle, lBorderColor, lEscapement,
                                 lType )
            END
            END

            vReportDef.Control.wPrintStatus = 3  // zRCONTROL_STATUS_PRINTED
//          END
         END

         // The following section of code will set the remaining space
         // on the page. The tricky part here is that more than one
         // control can be on the same the same line (i.e.  overlap other
         // controls in the Y direction).  The algorithm goes like this:
         //
         // If the next control is on the same line as the current control
         //    If control is the first control on the line
         //       Get RemainingSpaceForCurrentLine
         //    Otherwise, there was a previous control on the line
         //       Take min of previous RemainSpaceForCurrentLine and
         //       RemainingSpace based on current control
         // Otherwise, the current control is the last on the current line
         //    If control is the first control on the line
         //       Get RemainingSpaceForPage
         //    Otherwise, there was a previous control on the line
         //       Take min of previous RemainSpaceForCurrentLine and
         //       RemainingSpace based on current control
         //
         // NOTE: this code assumes that there will only be one multi-line
         // text control in any set of overlapping controls.

         SetViewFromView( vReportTmp, vReportDef )
         IF SetCursorNextEntity( vReportTmp,
                                 "Control", "" ) = zCURSOR_SET AND
            vReportTmp.Control.RangeBottom = lRangeBottom

            lAdjust = vReportDef.Control.PSDLG_Y + vReportDef.Control.SZDLG_Y
            lRemainingSpaceForCurrentLine = lRemainingSpaceOnPageY -
                                 (lRangeBottom - lAdjust) - lMultiLineSizeY

         ELSE

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineI( "FormatGroupOnPage Change RemainingSpaceOnPage: ",
//UNDEF                    lRemainingSpaceOnPageY )
//UNDEF        TraceLineI( "                   lRemainingSpaceOnPageStart: ",
//UNDEF                    lRemainingSpaceOnPageStart )
//UNDEF        TraceLineI( "                                     MaxSizeY: ",
//UNDEF                    lMaxSizeY )
//UNDEF        TraceLineI( "                                Next MaxSizeY: ",
//UNDEF                    vReportTmp.Control.RangeBottom )
//UNDEF     END

         // lRemainingSpaceOnPageY = lRemainingSpaceOnPageY - lMaxSizeY
            lRemainingSpaceOnPageY = lRemainingSpaceOnPageStart - lMaxSizeY
            lMultiLineSizeY = 0
            lRemainingSpaceForCurrentLine = 0
            bTopOfPage = FALSE   // if adjusting RemainingSpace, then
                                 // can't be at top

//UNDEF     IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF        TraceLineI( "                    New  RemainingSpaceOnPage: ",
//UNDEF                    lRemainingSpaceOnPageY )
//UNDEF     END

         END
      END // else of SkipLastPage
      END // else
      END // else
      END // else
      END // else of: IF lPrintHTML = 1 OR lPrintCSV = 1

      // increment loop
      nLoop1 = SetCursorNextEntity( vReportDef, "Control", "" )

   END   // LOOP WHILE nLoop1 = zCURSOR_SET

   IF lPrintCSV = 1
      IF vReportDef.Control EXISTS
         PrintTextToCSV( vSubtask, 0, 0 )  // end of line
      END
   END

   nRptExitEvent = zRGE_EVENT_POSTPRINT
   nRptExitReturn = InvokeReportExitCode( vSubtask, vReportDef,
                                          szRptExitOper, nRptExitEvent,
                                          lPageNbr, vSourceOI )
   fnSetGroupCtrlStatus( vReportDef, zRCONTROL_STATUS_GROUPINACTIVE )
// DropViewTrace( "Dropping view (23): ", vReportTmp )
   DropView( vReportTmp )
   vReportTmp = 0

   IF vSourceOI != 0
//UNDVV IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDVV    TraceLineV( "(FormatGroupOnPage.end) DropView( vSourceOI ): ",
//UNDVV                vSourceOI )
//UNDVV END
   // DropViewTrace( "Dropping view (24): ", vSourceOI )
      DropView( vSourceOI )
      vSourceOI = 0
   END

   IF nRptExitReturn = zRGE_RETURN_NEWPAGE
//UNDEF TraceLineI( "Exit Forced New Page after Group at PosY: ",
//UNDEF             lCurrentPosY )

      lRemainingSpaceOnPageY = 0
      plNewPosY = lFooterPosPageBottom

   ELSE
      plNewPosY = lOrigPosY + vReportDef.Group.SZDLG_Y +
                  lMultiLineAdjustment + lMultiLineIncrement
   END

//UNDEF IF (lPageNbr >= 1 AND lPageNbr <= 4)/*TracePages*/
//UNDEF    TraceLineS( "FormatGroupOnPage returning 0", "" )
//UNDEF END

//UNDEF TraceLineI( "Formatting GroupSet/Group NewPosY: ", plNewPosY )
//UNDEF TraceLineS( "GroupSet: ", szRptGroupSetTag )
//UNDEF TraceLineS( "   Group: ", szRptGroupTag )

// TraceLineI( "Adding PagePos: ", lPagePosMaxX );
// plNewPosX = plNewPosX + lPagePosMaxX
   plNewPosX = lPagePosMaxX

   RETURN 0

END

TRANSFORMATION OPERATION
FormatGroupOnPage( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                   VIEW    vSourceHierOI,
                   VIEW    vSubtask,
                   INTEGER plNewPosX,
                   INTEGER plNewPosY,
                   INTEGER lCurrentPosX,    // position of Group on page
                   INTEGER lCurrentPosY,    // position of Group on page
                   INTEGER lRemainingSpaceOnPageY,
                   INTEGER lContinuedGroupFlag,
                   INTEGER lPageWidth,
                   INTEGER lPageHeight,
                   INTEGER lOrigRemainingSpaceOnPageY,
                   INTEGER lFooterPosPageBottom )

   VIEW        vReportDefTemp
   INTEGER     lContinuedGroupSave
   INTEGER     lOrigPosY         // original y-position of control on page
   INTEGER     lOrigRemainingSpace
   INTEGER     lFlags            // Group Flags attribute
   STRING (32) szTag
   SHORT       nRC

   lFlags = vReportDef.Group.Flags
   IF lFlags = 1  // this is an Overlay Group
      RETURN 0
   END

//
// char szWorkString[ 256 ];
// char szTag1[ 64 ];
// char szTag2[ 64 ];
// GetStringFromAttribute( szTag1, vReportDef, "GroupSet", "Tag" );
// GetStringFromAttribute( szTag2, vReportDef, "Group", "Tag" );
// if ( zstrcmp( szTag2, "GroupFooter" ) == 0 ||
//      zstrcmp( szTag2, "GroupHeader" ) == 0 )
// {
//    wsprintf( szWorkString, "FormatGroupOnPage GroupSet: %s   Group: %s",
//              szTag1, szTag2 );
//    TraceLineS( szWorkString, "" );
// }
//
   lFlags = lContinuedGroupFlag
   IF lContinuedGroupFlag < 0
      TraceLineI( "FormatGroupOnPage ContinuedGroupFlag: ", lContinuedGroupFlag )
      lContinuedGroupFlag = 0
   END

// CreateViewTrace( "Creating view (20): ", vReportDefTemp, vReportDef, 0 )
   CreateViewFromViewForTask( vReportDefTemp, vReportDef, 0 )
   GetStringFromAttribute( szTag, vReportDef, "Group", "Tag" )
   nRC = SetCursorFirstEntityByString( vReportDefTemp, "Group",
                                       "OverlayTag", szTag, "" )
   IF nRC >= zCURSOR_SET
      lContinuedGroupSave = vReportDef.PageState.ContinuedGroupFlagStartPage
      lOrigPosY = lCurrentPosY
      lOrigRemainingSpace = lRemainingSpaceOnPageY
      LOOP WHILE nRC >= zCURSOR_SET
         fnFormatGroupOnPage( vReportDefTemp, vSourceHierOI, vSubtask,
                              plNewPosX, plNewPosY, lCurrentPosX, lCurrentPosY,
                              lRemainingSpaceOnPageY, lContinuedGroupFlag,
                              lPageWidth, lPageHeight,
                              lOrigRemainingSpaceOnPageY,
                              lFooterPosPageBottom )
         nRC = SetCursorNextEntityByString( vReportDefTemp, "Group",
                                            "OverlayTag", szTag, "" )
      END

      vReportDef.PageState.ContinuedGroupFlagStartPage = lContinuedGroupSave
      lCurrentPosY = lOrigPosY
      lRemainingSpaceOnPageY = lOrigRemainingSpace
   END

// DropViewTrace( "Dropping view (25): ", vReportDefTemp )
   DropView( vReportDefTemp )
   vReportDefTemp = 0

   lContinuedGroupFlag = lFlags
   nRC = fnFormatGroupOnPage( vReportDef, vSourceHierOI, vSubtask,
                              plNewPosX, plNewPosY,
                              lCurrentPosX, lCurrentPosY,
                              lRemainingSpaceOnPageY, lContinuedGroupFlag,
                              lPageWidth, lPageHeight,
                              lOrigRemainingSpaceOnPageY,
                              lFooterPosPageBottom )

   RETURN nRC

END

LOCAL OPERATION
ProcessFooters( VIEW        vReportDef BASED ON LOD TZRPSRCO,
                VIEW        vSubtask,
                STRING (32) szCurrentEntityName,
                INTEGER     lReturnLevel,
                INTEGER     lRemainingSpaceOnPageY,
                INTEGER     lBottomOfPage,
                INTEGER     plCurrentPosX,
                INTEGER     plCurrentPosY,
                INTEGER     plRepeatHorizontal,
                INTEGER     lPageWidth,
                INTEGER     lPageHeight,
                INTEGER     bForcePageBreak )

   VIEW        vFooterDef BASED ON LOD TZRPSRCO
   VIEW        vTempDef   BASED ON LOD TZRPSRCO
   VIEW        vTemp
   VIEW        vFooterHierOI
   INTEGER     lOrigPosX
   INTEGER     lNewPosX
   INTEGER     lNewPosY
   INTEGER     lGroupTotal
   INTEGER     lTempView
   INTEGER     bValidView
   INTEGER     nFooterLoop
   INTEGER     nLevel
   STRING (32) szEntityName
   SHORT       nRC

   plRepeatHorizontal = 0

   // *** PROCESS FOOTERS AS NECESSARY ***

   // A footer Group is processed for the last instance of an entity under
   // its parent if there is a Group of Type "gf".  A problem here is that
   // multiple Footers might need to be processed when we position on a new
   // entity.  To handle this, an instance of FooterAtLevel was created on
   // the first instance of each entity that would later require a Footer.
   // They were created in reverse order by Level.  Thus our logic for
   // processing a Footer is to see if an instance of FooterAtLevel
   // exists for a Level higher than the level of the current entity.

   // A return code of -1 indicates that no Footers needed to be processed.
   // A return code of 0 indicates that Footers were processed and all would
   // fit on page.
   // A return code of 1 indicates that not all of the Footers would fit on
   // the page and that they will have to be added to the next page.

   // See if we need to process a Footer for the last entity Group.
   SET CURSOR FIRST vReportDef.FooterAtLevel WHERE
                    vReportDef.FooterAtLevel.Level >= lReturnLevel
   // If the current level is the same as the FooterAtLevel, we will check to
   // see if the entity names are the same.
   nFooterLoop = RESULT
   IF nFooterLoop >= zCURSOR_SET
      IF vReportDef.FooterAtLevel.Level = lReturnLevel AND
         vReportDef.FooterAtLevel.EntityName = szCurrentEntityName AND
         vReportDef.FooterAtLevel.Complete != "Y"

         nFooterLoop = -1

      END
   END

   lOrigPosX = plCurrentPosX

   // Now loop to process each Footer.
   LOOP WHILE nFooterLoop >= zCURSOR_SET
      GetViewFromAttribute( vFooterHierOI, vReportDef,
                            "FooterAtLevel", "SourceOI_Hier" )
      bValidView = IsValidView( vFooterHierOI )
      IF bValidView = FALSE
         bValidView = bValidView / bValidView
      END
//UNDVV IF bValidView = FALSE
//UNDVV    TraceLineV( "(nFooterLoop) PageState/FooterAtLevel invalid view: ",
//UNDVV                vFooterHierOI )
//UNDVV    DisplayEntityInstance( vReportDef, "PageState" )
//UNDVV    DisplayEntityInstance( vReportDef, "FooterAtLevel" )
//UNDVV END
   // CreateViewTrace( "Creating view (22): ", vFooterDef, vReportDef, 0 )
      CreateViewFromViewForTask( vFooterDef, vReportDef, 0 )
      szEntityName = vReportDef.FooterAtLevel.EntityName
      SET CURSOR FIRST vFooterDef.GroupSet WHERE
          vFooterDef.GroupSet.Tag = szEntityName

      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST vFooterDef.Group WHERE
             vFooterDef.Group.Type = "gf"
      ELSE
         TraceLineS( "ProcessFooters unable to locate GroupSet: ",
                     szEntityName )
      END

      IF vReportDef.PageState.ForcePageBreak != 0
         nRC = 1
      END

      // Make sure there is enough space on the Page for the Footer.  If
      // not, set up for the next Page.
      lRemainingSpaceOnPageY = lBottomOfPage - plCurrentPosY
      lGroupTotal = vFooterDef.Group.SZDLG_Y
      IF lRemainingSpaceOnPageY < lGroupTotal

         // Return with an indication that there are more Footers, but there
         // was not enough room to process them all.  Then save the last
         // ReturnLevel.

         vReportDef.FooterAtLevel.Complete = "Y"
         vReportDef.Report.LastLevel = lReturnLevel
         vReportDef.Report.ForcePageBreak = bForcePageBreak

         vTemp = vReportDef.Report.FooterDidNotFit
         IF vTemp != 0
         // DropViewTrace( "Dropping view (4f): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

      // vReportDef.Report.FooterDidNotFit = vReportDef.FooterAtLevel.SourceOI_Hier
         GetViewFromAttribute( vFooterHierOI, vReportDef,
                               "FooterAtLevel", "SourceOI_Hier" )

         IF vFooterHierOI != 0

         // bValidView = IsValidView( vFooterHierOI )
         // IF bValidView = FALSE
         // // bValidView = bValidView / bValidView
         //    TraceLineV( "FooterDidNotFit View is Invalid (11): ", vFooterHierOI )
         // // SysMessageBox( vSubtask, "Report.FooterDidNotFit", "Invalid View 11", TRUE )
         // ELSE
         //    TraceLineV( "FooterDidNotFit View is Valid (11): ", vFooterHierOI )
         // END

         // CreateViewTrace( "Creating view (4h): ", vTemp, vFooterHierOI, 0 )
            CreateViewFromViewForTask( vTemp, vFooterHierOI, 0 )
            lTempView = MakeIntegerFromView( vTemp )

         ELSE

            lTempView = 0

         END

         vReportDef.Report.FooterDidNotFit = lTempView
      // DropViewTrace( "Dropping view (26a): ", vFooterDef )
         DropView( vFooterDef )
         vFooterDef = 0

         RETURN 1 // return indicating that there are MORE pages

      END

      // Put Footer on Page.
      IF bValidView = TRUE

         plRepeatHorizontal = vFooterDef.GroupSet.RepeatHorizontal
         lNewPosX = lOrigPosX
         FormatGroupOnPage( vFooterDef, vFooterHierOI, vSubtask,
                            lNewPosX, lNewPosY, plCurrentPosX, plCurrentPosY,
                            lRemainingSpaceOnPageY,
                            0,   // continued Group flag 0 = not continued
                            lPageWidth, lPageHeight, lRemainingSpaceOnPageY,
                            lBottomOfPage )

         lNewPosX = 0  // can't have footers repeating horizontally
         plCurrentPosY = lNewPosY
         lRemainingSpaceOnPageY = lBottomOfPage - plCurrentPosY
      ELSE
         TraceLineS( "Footer has been Skipped.....", "" )
      END

      // Delete the FooterAtLevel that we processed in this loop.
      vTemp = vReportDef.FooterAtLevel.SourceOI_Hier
      IF vTemp != 0
         IF vTemp = vFooterHierOI
            vFooterHierOI = 0
         END

      // DropViewTrace( "Dropping view (26b): ", vTemp )
         DropView( vTemp )
         vTemp = 0
         vReportDef.FooterAtLevel.SourceOI_Hier = 0
      END

      DELETE ENTITY vReportDef.FooterAtLevel NONE

   // DropViewTrace( "Dropping view (26): ", vFooterDef )
      DropView( vFooterDef )
      vFooterDef = 0

      // Drop the view to the footer.
      // If we are processing a continued footer at the beginning of a page
      // unless it exists on a FooterAtLevel for the previous page.
   // CreateViewTrace( "Creating view (23): ", vTempDef, vReportDef, 0 )
      CreateViewFromViewForTask( vTempDef, vReportDef, 0 )
      SET CURSOR PREVIOUS vTempDef.PageState
      SET CURSOR FIRST vTempDef.FooterAtLevel
          WHERE vTempDef.FooterAtLevel.SourceOI_Hier = lTempView
      IF RESULT < zCURSOR_SET AND vFooterHierOI != 0
//UNDVV  bValidView = IsValidView( vFooterHierOI )
//UNDVV  IF bValidView = FALSE
//UNDVV     TraceLineV( "(nFooterLoop2) PageState/FooterAtLevel invalid view: ",
//UNDVV                 vFooterHierOI )
//UNDVV     DisplayEntityInstance( vTempDef, "PageState" )
//UNDVV     DisplayEntityInstance( vTempDef, "FooterAtLevel" )
//UNDVV  ELSE
         // DropViewTrace( "Dropping view (27): ", vFooterHierOI )
            DropView( vFooterHierOI )
            vFooterHierOI = 0
//UNDVV  END
      END

   // DropViewTrace( "Dropping view (28): ", vTempDef )
      DropView( vTempDef )
      vTempDef = 0

      // Position on the next Footer to be processed, using same logic as
      // preceeded this loop.
      SET CURSOR NEXT vReportDef.FooterAtLevel WHERE
                      vReportDef.FooterAtLevel.Level >= lReturnLevel
      nFooterLoop = RESULT
   // IF nFooterLoop >= zCURSOR_SET       DKS?
   //
   //    IF vReportDef.FooterAtLevel.Level = lReturnLevel AND
   //       vReportDef.FooterAtLevel.EntityName != szCurrentEntityName
   //
   //       nFooterLoop = -1
   //
   //    END
   // END                                 DKS?

      IF nFooterLoop >= zCURSOR_SET
         nLevel = vReportDef.FooterAtLevel.Level
         szEntityName = vReportDef.FooterAtLevel.EntityName

         IF nLevel < lReturnLevel
            nFooterLoop = -1
         ELSE

            IF nLevel > lReturnLevel
            ELSE

               LOOP WHILE nFooterLoop >= zCURSOR_SET AND
                          nLevel = lReturnLevel AND
                          szEntityName != szCurrentEntityName

                  SET CURSOR NEXT vReportDef.FooterAtLevel
                  nFooterLoop = RESULT
                  IF nFooterLoop >= zCURSOR_SET
                     nLevel = vReportDef.FooterAtLevel.Level
                     szEntityName = vReportDef.FooterAtLevel.EntityName
                     IF nLevel < lReturnLevel
                        nFooterLoop = -1
                     ELSE
                        IF szEntityName = szCurrentEntityName AND
                           vReportDef.FooterAtLevel.Complete != "Y"

                           nFooterLoop = -1

                        END
                     END
                  END
               END

               IF nFooterLoop >= zCURSOR_SET
                  IF nLevel < lReturnLevel OR
                     szEntityName != szCurrentEntityName OR
                     vReportDef.FooterAtLevel.Complete != "Y"

                     nFooterLoop = -1
                  END
               END
            END
         END
      END
   END

   // The normal return code of 0 indicates that there was room on the page
   // for all the Footers and that all were processed.
   RETURN nRC

END

LOCAL OPERATION
ProcessPageFooter( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                   VIEW    vSourceHierOI,
                   VIEW    vSubtask,
                   INTEGER plNewPosX,
                   INTEGER plNewPosY,
                   INTEGER lCurrentPosX,
                   INTEGER lCurrentPosY,
                   INTEGER lPageWidth,
                   INTEGER lPageHeight,
                   INTEGER lFlags )

   VIEW        vPageFooterDef BASED ON LOD TZRPSRCO
   VIEW        vTempOI
   STRING (32) szPageNumber
   INTEGER     nGroupSuppressedForPage
   INTEGER     lPageNbr
   INTEGER     lResetPageNbr
   INTEGER     lResetTotalPageCnt
   INTEGER     lTotalPages
   INTEGER     lPrintFlags
   INTEGER     lPrintHTML
   INTEGER     lTemp
   SHORT       nRC

   lPrintFlags = vReportDef.Report.PrintFlags
   nRC = IsFlagSequenceSet( lPrintFlags, 256 )
   IF nRC != 0
      lPrintHTML = 1
   ELSE
      lPrintHTML = 0
   END

   lPrintFlags = vReportDef.Report.PrintFlags
   nRC = IsFlagSequenceSet( lPrintFlags, 256 )
   nRC = IsFlagSequenceSet( lPrintFlags, 2048 ) // print PageFooter using PageHeader view
   IF nRC != 0
      GET VIEW vTempOI NAMED "-->HeaderViewForFooter"
      IF vTempOI != 0
         vSourceHierOI = vTempOI
      END
   END

   plNewPosX = 0      // no matter what, the Page Footer starts at zero
   lCurrentPosX = 0

   // This routine is called at the end of a page to process a Page Footer,
   // if there is one.
// CreateViewTrace( "Creating view (24): ", vPageFooterDef, vReportDef, 0 )
   CreateViewFromViewForTask( vPageFooterDef, vReportDef, 0 )
   lPageNbr = vPageFooterDef.Report.CurrentPageNbr
   lTotalPages = vPageFooterDef.Report.TotalPageCnt
   lTemp = 1073741824  // 0x40000000 ==> set up page numbering
   lResetTotalPageCnt = lTotalPages
   lResetPageNbr = HandlePageNumbering( vSubtask, szPageNumber, 0,
                                        lPageNbr, lResetTotalPageCnt, lTemp )

   SET CURSOR FIRST vPageFooterDef.GroupSet WHERE
                    vPageFooterDef.GroupSet.Type = "PF"
   LOOP WHILE RESULT >= zCURSOR_SET
      // Check if subtype specified for page footer.
      nGroupSuppressedForPage = GroupSuppressReason( vPageFooterDef, lResetPageNbr,
                                                     lResetTotalPageCnt )

      // Only process the footer if it is not suppressed.
      IF nGroupSuppressedForPage = 0
         SET CURSOR FIRST vPageFooterDef.Control WHERE
                          vPageFooterDef.Control.Tag = "PageNumber"
         IF RESULT >= zCURSOR_SET
            vPageFooterDef.Control.Text = szPageNumber
         END

         FormatGroupOnPage( vPageFooterDef, vSourceHierOI, vSubtask,
                            plNewPosX, plNewPosY,
                            lCurrentPosX, lCurrentPosY, 99999,
                            0,   // continued Group flag 0 ==> not continued
                            lPageWidth, lPageHeight, 99999, lPageHeight )
         lCurrentPosY = plNewPosY
      END

      SET CURSOR NEXT vPageFooterDef.Group
   END

// DropViewTrace( "Dropping view (29): ", vPageFooterDef )
   DropView( vPageFooterDef )
   vPageFooterDef = 0

   IF vTempOI != 0
      DropView( vTempOI )
   END

END

LOCAL OPERATION
ProcessPgDetailHeadrs( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                       VIEW    vSourceHierOI,
                       STRING ( 32 ) szCurrentEntityName,
                       VIEW    vSubtask,
                       INTEGER plNewPosX,
                       INTEGER plNewPosY,
                       INTEGER lCurrentPosX,
                       INTEGER lCurrentPosY,
                       INTEGER lRemainingSpaceOnPageY,
                       INTEGER lBottomOfPage,
                       INTEGER lPageWidth,
                       INTEGER lPageHeight )

   VIEW        vHeaderDef BASED ON LOD TZRPSRCO
   VIEW        vSourceOI
   STRING (32) szParentEntityName

   plNewPosY = lCurrentPosY

   // We will use a temporary view for vSourceHierOI because the operation,
   // GetStringFromAttributeByContext calls operations that will not allow
   // a hierarchical cursor.
   IF vSourceHierOI = 0
      RETURN
   END

// CreateViewTrace( "Creating view (26): ", vSourceOI, vSourceHierOI, 0 )
   CreateViewFromViewForTask( vSourceOI, vSourceHierOI, 0 )
   MiGetParentEntityNameForView( szParentEntityName, vSourceOI,
                                 szCurrentEntityName )
// DropViewTrace( "Dropping view (30): ", vSourceOI )
   DropView( vSourceOI )
   vSourceOI = 0

   IF szParentEntityName != ""

      ProcessPgDetailHeadrs( vReportDef, vSourceHierOI,
                             szParentEntityName, vSubtask,
                             plNewPosX, plNewPosY,
                             lCurrentPosX, lCurrentPosY,
                             lRemainingSpaceOnPageY, lBottomOfPage,
                             lPageWidth, lPageHeight )
      lCurrentPosY = plNewPosY
      lRemainingSpaceOnPageY = lBottomOfPage - lCurrentPosY

   // CreateViewTrace( "Creating view (27): ", vHeaderDef, vReportDef, 0 )
      CreateViewFromViewForTask( vHeaderDef, vReportDef, 0 )
      SET CURSOR FIRST vHeaderDef.GroupSet WHERE
                       vHeaderDef.GroupSet.Tag = szCurrentEntityName
      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST vHeaderDef.Group WHERE
                          vHeaderDef.Group.Type = "gh"
      ELSE
         TraceLineS( "ProcessPgDetailHeadrs unable to locate GroupSet: ",
                     szCurrentEntityName )
      END

      IF RESULT >= zCURSOR_SET
         FormatGroupOnPage( vHeaderDef, vSourceHierOI, vSubtask,
                            plNewPosX, plNewPosY,
                            lCurrentPosX, lCurrentPosY, lRemainingSpaceOnPageY,
                            0,   // continued Group flag 0 = not continued
                            lPageWidth, lPageHeight, lRemainingSpaceOnPageY,
                            lBottomOfPage )
         vReportDef.Report.CurrentEntityName = szCurrentEntityName
      END

   // DropViewTrace( "Dropping view (31): ", vHeaderDef )
      DropView( vHeaderDef )
      vHeaderDef = 0
   END

END

LOCAL OPERATION
GroupSuppressReason( VIEW    vReportDef BASED ON LOD TZRPSRCO,
                     INTEGER lPageNbr,
                     INTEGER lTotalPageCnt )

   STRING (1) szGroupSubType
   SHORT      nGroupSuppressedForPage

    // Check if subtype specified for page header.
   IF vReportDef.Group EXISTS
      szGroupSubType = vReportDef.Group.SubType
      IF lPageNbr > 1 AND szGroupSubType = "1"  // FirstPageOnly
         nGroupSuppressedForPage = 1
      ELSE
      IF lPageNbr < 2 AND szGroupSubType = "2"  // StartingOnPage2
         nGroupSuppressedForPage = 2
      ELSE
      IF szGroupSubType = "3"  // LastPageOnly
         IF lPageNbr = 0 OR           // suppress for all pages when counting
            lPageNbr < lTotalPageCnt  // suppress when not on last page
            nGroupSuppressedForPage = 3
         ELSE
            nGroupSuppressedForPage = 0
         END
      // TraceLineS ( "Group subtype of 'LastPageOnly' is no longer ",
      //              "supported - use a work entity at end of object." )
      // nGroupSuppressedForPage = 0
      ELSE
         nGroupSuppressedForPage = 0
      END END END
   ELSE
      nGroupSuppressedForPage = 9  // No Group in Group set??
   END

   // Finally, Only print Group if there are any controls to process.
   IF nGroupSuppressedForPage = 0
      IF vReportDef.Control DOES NOT EXIST
         nGroupSuppressedForPage = -1
      END
   END

   RETURN nGroupSuppressedForPage
END

/////////////////////////////////////////////////////////////////////////////
//
//    OPERATION: fnSetGroupCtrlStatus
//
//    Set all the controls within a Group to a specified status (usually -1
//    or 0).
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
fnSetGroupCtrlStatus( VIEW vReportDefIn BASED ON LOD TZRPSRCO,
                      SHORT nStatus )

   VIEW vReportDef BASED ON LOD TZRPSRCO

// CreateViewTrace( "Creating view (28): ", vReportDef, vReportDefIn, 0 )
   CreateViewFromViewForTask( vReportDef, vReportDefIn, 0 )

   FOR EACH vReportDef.Control
      vReportDef.Control.wPrintStatus = nStatus
   END

// DropViewTrace( "Dropping view (32): ", vReportDef )
   DropView( vReportDef )
   vReportDef = 0

END

/////////////////////////////////////////////////////////////////////////////
//
//    OPERATION: fnSetCtrlPrintValues
//
//    Sets the current controls LastPrint values
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
fnSetCtrlPrintValues( VIEW vReportDef BASED ON LOD TZRPSRCO,
                      STRING ( 255 ) szText,
                      INTEGER lPage,
                      INTEGER lPosX,
                      INTEGER lPosY )

   vReportDef.Control.wLastPrintText = szText
   vReportDef.Control.wLastPrintPage = lPage
   vReportDef.Control.wLastPrintPosX = lPosX
   vReportDef.Control.wLastPrintPosY = lPosY

END

/////////////////////////////////////////////////////////////////////////////
//
//    OPERATION: fnPageStateRemove
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
fnPageStateRemove( VIEW vReportDef BASED ON LOD TZRPSRCO,
                   INTEGER lPageNbr )

   VIEW vReportDef2 BASED ON LOD TZRPSRCO
   VIEW vTemp

   IF lPageNbr <= 0
      // The state for page number zero will never change.
      RETURN 0
   END

   // Delete all state entities for this page and beyond.
   FOR EACH vReportDef.PageState
      IF vReportDef.PageState.PageNbr >= lPageNbr
         FOR EACH vReportDef.FooterAtLevel
            vTemp = vReportDef.FooterAtLevel.SourceOI_Hier
//UNDVV     nRC = IsValidView( vTemp )
//UNDVV     IF nRC = FALSE
//UNDVV        TraceLineV( "(PageNbr>=lPageNbr) PageState/FooterAtLevel "
//UNDVV                    "invalid view: ", vTemp )
//UNDVV        DisplayEntityInstance( vReportDef, "PageState" )
//UNDVV        DisplayEntityInstance( vReportDef, "FooterAtLevel" )
//UNDVV     ELSE
               vReportDef.FooterAtLevel.SourceOI_Hier = 0
            // DropViewTrace( "Dropping view (33): ", vTemp )
               DropView( vTemp )
               vTemp = 0
//UNDVV     END
         END

         vTemp = vReportDef.PageState.FooterDidNotFit
         IF vTemp != 0
         // DropViewTrace( "Dropping view (4g): ", vTemp )
            DropView( vTemp )
            vTemp = 0
         END

         DELETE ENTITY vReportDef.PageState NONE
      END
   END

   SET CURSOR LAST vReportDef.PageState

   RETURN 0

END

/////////////////////////////////////////////////////////////////////////////
//
//    OPERATION: fnPageStateAdd
//
/////////////////////////////////////////////////////////////////////////////
LOCAL OPERATION
fnPageStateAdd( VIEW vReportDef BASED ON LOD TZRPSRCO,
                INTEGER lPageNbr )

   VIEW vReportDef2 BASED ON LOD TZRPSRCO
   VIEW vTempView
   INTEGER nPrevPageNbr
   INTEGER lTempView
   INTEGER bValidView

   IF lPageNbr <= 0
      // The state for page number zero will never change.
      CREATE ENTITY vReportDef.PageState FIRST
      vReportDef.PageState.PageNbr = 0
      vReportDef.PageState.StartLevel = 0
      vReportDef.PageState.LastLevel = 0
      vReportDef.PageState.HierReturnCode = zCURSOR_NULL
      vReportDef.PageState.CurrentEntityName =
                                     vReportDef.Report.WK_SubobjectEntityName
      vReportDef.PageState.AbsolutePos = -1
      RETURN 0
   END

   fnPageStateRemove( vReportDef, lPageNbr )
   nPrevPageNbr = lPageNbr - 1
   SET CURSOR FIRST vReportDef.PageState
          WHERE vReportDef.PageState.PageNbr = nPrevPageNbr
   IF RESULT < zCURSOR_SET
      TraceLineI( "Internal Error: fnPageStateAdd() cannot find page ",
                  nPrevPageNbr )
      RETURN -1
   END

   // Initialize state for this page
// CreateViewTrace( "Creating view (29): ", vReportDef2, vReportDef, 0 )
   CreateViewFromViewForTask( vReportDef2, vReportDef, 0 )
   CREATE ENTITY vReportDef.PageState LAST
   vReportDef.PageState.PageNbr = lPageNbr
   vReportDef.PageState.MultiLineTextPosStartPage =
              vReportDef2.PageState.MultiLineTextPosEndPage
   vReportDef.PageState.ContinuedGroupFlagStartPage =
              vReportDef2.PageState.ContinuedGroupFlagEndPage
   vReportDef.PageState.ContinuedControlTagStartPage =
              vReportDef2.PageState.ContinuedControlTagEndPage
   FOR EACH vReportDef2.LastHeaderEntityAtLevel
      CREATE ENTITY vReportDef.LastHeaderEntityAtLevel
      SetMatchingAttributesByName( vReportDef,  "LastHeaderEntityAtLevel",
                                   vReportDef2, "LastHeaderEntityAtLevel",
                                   zSET_NULL )
   END
   FOR EACH vReportDef2.FooterAtLevel
      CREATE ENTITY vReportDef.FooterAtLevel
      SetMatchingAttributesByName( vReportDef,  "FooterAtLevel",
                                   vReportDef2, "FooterAtLevel",
                                   zSET_NULL )

      // Make sure that the new entity has an independent view to
      // eliminate DropView problems later.
      lTempView = vReportDef.FooterAtLevel.SourceOI_Hier
      MakeViewFromInteger( vTempView, lTempView )

      bValidView = IsValidView( vTempView )
      IF bValidView = FALSE
         bValidView = bValidView / bValidView
      END

   // CreateViewTrace( "Creating view (30): ", vTempView, vTempView, 0 )
      CreateViewFromViewForTask( vTempView, vTempView, 0 )
      lTempView = MakeIntegerFromView( vTempView )
      vReportDef.FooterAtLevel.SourceOI_Hier = lTempView
   END

// DropViewTrace( "Dropping view (34): ", vReportDef2 )
   DropView( vReportDef2 )
   vReportDef2 = 0

   SET CURSOR LAST vReportDef.PageState

   RETURN 0

END
