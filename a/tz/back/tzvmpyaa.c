/* yacc -v -V qstats.y -p qq -D tzvspmaa.h -o tzvmpyaa.c -l tzvspmaa.y */
#ifdef YYTRACE
#define YYDEBUG 1
#else
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#endif
/*
 * Portable way of defining ANSI C prototypes
 */
#ifndef YY_ARGS
#ifdef __STDC__
#define YY_ARGS(x)     x
#else
#define YY_ARGS(x)     ()
#endif
#endif

#ifdef YACC_WINDOWS

#include <windows.h>

/*
 * the following is the handle to the current
 * instance of a windows program. The user
 * program calling qqparse must supply this!
 */

#ifdef STRICT
extern HINSTANCE hInst;
#else
extern HANDLE hInst;
#endif

#endif   /* YACC_WINDOWS */

#if YYDEBUG
typedef struct yyNamedType_tag {   /* Tokens */
   zCHAR  * name;      /* printable name */
   short   token;      /* token # */
   short   type;      /* token type */
} yyNamedType;
typedef struct yyTypedRules_tag {   /* Typed rule table */
   zCHAR  * name;      /* compressed rule string */
   short   type;      /* rule result type */
} yyTypedRules;

#endif


#define KZSYSSVC_INCL
#include <kzoengaa.h>     // Object Services public prototypes
#include "tzlodopr.h"
#define  EXDECL  extern
#include "tzvspmaa.ht"
//#include "tzvspmaa.h"
#include "tzvspmaa.hd"
#undef   EXDECL
typedef union {
   long     nValue;
   zPCHAR   szValue;
   double   ldValue;
} YYSTYPE;
#define qACTIVATE   1026
#define qAFTER   1002
#define qEACH   1003
#define qTATTRIBUTENAME   1004
#define qBEFORE   1005
#define qBASED   1006
#define qBREAK   1059
#define qCASE   1007
#define qCONDOPERATOR   1009
#define qCONSTANT   1010
#define qCREATE   1011
#define qCURSOR   1012
#define qCOMMIT   1013
#define qDELETE   1014
#define qELSE   1015
#define qEND   1016
#define qENTITY   1017
#define qTENTITYNAME   1018
#define qTDATE   1019
#define qFIRST   1020
#define qFOR   1021
#define qIF   1022
#define qJOIN   1024
#define qLAST   1025
#define qLOOP   1027
#define qLOD   1028
#define qMULTIPLE   1063
#define qNEXT   1030
#define qOF   1032
#define qON   1050
#define qOPERATION   1033
#define qOPERATOR   1034
#define qPREVIOUS   1035
#define qRESTRICTING   1061
#define qRETURN   1036
#define qROOTONLY   1064
#define qSINGLE   1065
#define qSET   1038
#define qTDECIMAL   1039
#define qTINTEGER   1040
#define qTO   1062
#define qTSHORT   1041
#define qTSTRING   1042
#define qUNTIL   1043
#define qVARIABLE   1044
#define qTVIEW   1045
#define qWHERE   1046
#define qWHILE   1047
#define qWITHIN   1048
#define qOTHERWISE   1049
#define qROOTONLYMULTIPLE   1066
#define qEMPTY   1067
#define qLIKE   1068
#define qEXISTS   1069
#define qEXIST   1070
#define qDOES   1071
#define qTCHARACTER   1072
#define qIS   1073
#define qNULL   1074
#define qATTRIBUTE   1075
#define qDERIVED   1076
#define qCONSTRAINT   1077
#define qTRANSFORMATION   1078
#define qSHORTCUTKEY   1079
#define qREGISTERED   1080
#define qAS   1081
#define qGET   1082
#define qAT   1083
#define qLEVEL   1084
#define qSUBTASK   1085
#define qTASK   1086
#define qAPPLICATION   1087
#define qSYSTEM   1088
#define qANY   1089
#define qNAME   1090
#define qUSING   1091
#define qINCLUDE   1092
#define qEXCLUDE   1093
#define qFROM   1094
#define qNONE   1095
#define qNAMED   1096
#define qCONTINUE   1102
#define qROOTONLYCONTINUE   1103
#define qSINGLEFORUPDATE   1104
#define qTUNKNOWN   1100
#define qTVOID   1101
#define qAND   1051
#define qOR   1052
#define qGLOBAL   1053
#define qLOCAL   1054
#define qOBJECT   1055
#define qDIALOG   1056
#define qDOMAIN   1057
#define qRETURNED   1058
#define qDEFINE   1060
#define qATTRIBUTEQUALIFIER   2001
#define qENTITYQUALIFIER   2002
#define qRESERVEDWORD   2003
#define qUSERDEFINED   2004
#define qDELIMITER   2005
#define qEXPRESSION   2006
#define qENDFUNC   2007
#define qOPERATIONCALL   2008
#define qNUMERIC   2009
#define qTEXT   2010
#define qEQUAL   3001
#define qADDITION   3003
#define qMINUS   3002
#define qMULTIPLICATION   3004
#define qDIVISION   3005
#define UMINUS   257
#define qCONDEQUAL   3006
#define qLESSTHANEQUAL   3007
#define qLESSTHAN   3008
#define qGREATERTHANEQUAL   3009
#define qGREATERTHAN   3010
#define qNOTEQUAL   3011
#define qNOT   3012
#define qCOMMA   3013
#define qLPAREN   3014
#define qRPAREN   3015
#define qLBRACE   3016
#define qRBRACE   3017
#define qOPENOPER   3018
#define qCLOSEOPER   3019
#define qSEMICOLON   3020
#define qCOLON   3021
#define qUNKNOWNTOKEN   3031
#define qNOTEXISTS   3022
#define qNOTNULL   3023
#define qLOCALOPERATION   4001
#define qDIALOGOPERATION   4004
#define qGLOBALOPERATION   4002
#define qDOMAINOPERATION   4005
#define qOBJECTOPERATION   4003
#define qZEIDONOPERATION   4006
#define qCONTROLOPERATION   4007
#define qBOTHVAR   5001
#define qCONCATOPERATOR   5002
extern int qqchar, yyerrflag;
extern YYSTYPE qqlval;
#if YYDEBUG
yyTypedRules yyRules[] = {
   { "&000: %001 &000",  0},
   { "%001: %002",  0},
   { "%001: %001 %002",  0},
   { "%001: &001",  0},
   { "%006:",  0},
   { "%002: %003 %004 %005 %006 %007",  0},
   { "%008:",  0},
   { "%002: %003 %005 %008 %007",  0},
   { "%003: %009 &032 %010",  0},
   { "%003: %009 &032 &001",  0},
   { "%009: &091",  0},
   { "%009: &090",  0},
   { "%009: &093",  0},
   { "%009: &094",  0},
   { "%011:",  0},
   { "%009: &092 %011 &063",  0},
   { "%012:",  0},
   { "%009: &018 %012 &063",  0},
   { "%009: &064",  0},
   { "%013:",  0},
   { "%009: &062 %013 &061",  0},
   { "%009: &065",  0},
   { "%009: &001",  0},
   { "%014:",  0},
   { "%004: &121 %014 %015 &122",  0},
   { "%016:",  0},
   { "%004: &121 %016 &122",  0},
   { "%015: %017",  0},
   { "%015: %015 &120 %017",  0},
   { "%018:",  0},
   { "%015: %015 &001 %018 %017",  0},
   { "%017: %019",  0},
   { "%017: %020 %019",  0},
   { "%017: %021",  0},
   { "%017: %020 %021",  0},
   { "%005: %022",  0},
   { "%005: %023",  0},
   { "%005: %022 %023",  0},
   { "%005: %023 %022",  0},
   { "%005:",  0},
   { "%007: &017",  0},
   { "%022: %024",  0},
   { "%022: %022 %024",  0},
   { "%024: %019",  0},
   { "%024: %021",  0},
   { "%019: %025 %010",  0},
   { "%019: %025 &001",  0},
   { "%025: &041",  0},
   { "%025: &040",  0},
   { "%025: &044 %026",  0},
   { "%025: &044",  0},
   { "%025: &019",  0},
   { "%025: &005",  0},
   { "%025: &043",  0},
   { "%025: &058",  0},
   { "%020: &095",  0},
   { "%027:",  0},
   { "%026: &121 &011 %027 &122",  0},
   { "%028:",  0},
   { "%026: &121 %028 &122",  0},
   { "%021: %029 %030",  0},
   { "%021: %029",  0},
   { "%021: %029 &001",  0},
   { "%029: &047 %010",  0},
   { "%030: &007 &031 &027 %010",  0},
   { "%030: &066 &067 %010",  0},
   { "%023: %031",  0},
   { "%023: %032",  0},
   { "%023: %031 %032",  0},
   { "%031: %033",  0},
   { "%031: %031 %033",  0},
   { "%033: %034",  0},
   { "%033: %035",  0},
   { "%033: %036",  0},
   { "%033: %037",  0},
   { "%033: %038",  0},
   { "%034: %039 %007",  0},
   { "%034: %039 %040 %007",  0},
   { "%034: %039 &001",  0},
   { "%035: %041 %042",  0},
   { "%035: %041 %023 %042",  0},
   { "%035: %041 %043 %007",  0},
   { "%035: %041 %043 %023 %007",  0},
   { "%035: %041 %043 &001",  0},
   { "%035: %041 %043 %023 &001",  0},
   { "%042: &045 %044",  0},
   { "%042: &045 %045",  0},
   { "%042: &045 &001",  0},
   { "%036: %046 %047 %007",  0},
   { "%049:",  0},
   { "%036: %046 %048 %049 %007",  0},
   { "%050:",  0},
   { "%036: %046 %047 %048 %050 %007",  0},
   { "%036: %046 %047 %048 &001",  0},
   { "%036: %046 %047 &001",  0},
   { "%036: %046 %048 &001",  0},
   { "%036: %046 &001",  0},
   { "%051:",  0},
   { "%036: %046 %048 %047 %051 %007",  0},
   { "%052:",  0},
   { "%036: %046 %052 %007",  0},
   { "%037: %053",  0},
   { "%037: %054",  0},
   { "%037: %055",  0},
   { "%037: %056",  0},
   { "%037: %057",  0},
   { "%037: %058",  0},
   { "%037: %059",  0},
   { "%037: %060",  0},
   { "%037: %061",  0},
   { "%037: %062",  0},
   { "%038: %063",  0},
   { "%065:",  0},
   { "%038: %064 &107 %065 %066",  0},
   { "%032: %067",  0},
   { "%039: &023 %044",  0},
   { "%039: &023 %045",  0},
   { "%068:",  0},
   { "%039: &023 %044 %068 %023",  0},
   { "%069:",  0},
   { "%039: &023 %045 %069 %023",  0},
   { "%070:",  0},
   { "%039: &023 &001 %070 %023",  0},
   { "%040: &016",  0},
   { "%071:",  0},
   { "%040: &016 %071 %023",  0},
   { "%041: &026",  0},
   { "%044: %072",  0},
   { "%044: %072 %073 %044",  0},
   { "%044: %072 %073 %045",  0},
   { "%045: %074 %044 %075",  0},
   { "%045: %074 %044 %075 %073 %045",  0},
   { "%045: %074 %044 %075 %073 %044",  0},
   { "%045: %074 %045 %075",  0},
   { "%045: %074 %045 %075 %073 %045",  0},
   { "%045: %074 %045 %075 %073 %044",  0},
   { "%045: %076 %045",  0},
   { "%043: %077 %044",  0},
   { "%043: %077 %045",  0},
   { "%043: %077 &001",  0},
   { "%046: &009 %066",  0},
   { "%047: %047 %078 %023",  0},
   { "%047: %047 %078",  0},
   { "%047: %078 %023",  0},
   { "%047: %078",  0},
   { "%079:",  0},
   { "%048: &051 &128 %079 %023",  0},
   { "%048: &051 &128",  0},
   { "%053: &039 &013 %080 %081",  0},
   { "%053: &039 &013 %080 %081 %082",  0},
   { "%056: &014 %010",  0},
   { "%059: &068 &047 %083 %084 &077 %010",  0},
   { "%059: &068 &047 %083 %084",  0},
   { "%059: &068 &047 %083",  0},
   { "%060: &076 &047 %085 %084 &077 %010",  0},
   { "%060: &076 &047 %085 %084",  0},
   { "%060: &076 &047 %085",  0},
   { "%086:",  0},
   { "%061: &078 &098 %086 %087 %088",  0},
   { "%087: &080 &098",  0},
   { "%088: &006",  0},
   { "%088: &003",  0},
   { "%088:",  0},
   { "%089:",  0},
   { "%062: &079 &098 %089 %090",  0},
   { "%090: &006",  0},
   { "%090: &081",  0},
   { "%090: &003",  0},
   { "%090:",  0},
   { "%091:",  0},
   { "%085: %010 %091 &011",  0},
   { "%092:",  0},
   { "%085: %010 %092 %010",  0},
   { "%093:",  0},
   { "%083: %010 %093 &082 %094",  0},
   { "%094: &011",  0},
   { "%094: %010",  0},
   { "%084: &069 &070 &071",  0},
   { "%084: &069 &070 &072",  0},
   { "%084: &069 &070 &073",  0},
   { "%084: &069 &070 &074",  0},
   { "%084: &069 &070 &075",  0},
   { "%096:",  0},
   { "%054: %095 %023 %096 %007",  0},
   { "%097:",  0},
   { "%054: %095 %097 %007",  0},
   { "%095: %098 %081 %082",  0},
   { "%095: %098 %081",  0},
   { "%099:",  0},
   { "%098: &022 %099 &004",  0},
   { "%100:",  0},
   { "%098: &022 %100 %010",  0},
   { "%101:",  0},
   { "%098: &022 %101 &011",  0},
   { "%098: &022",  0},
   { "%102:",  0},
   { "%081: &098 %102 %103",  0},
   { "%081: &098",  0},
   { "%103: &050 &098",  0},
   { "%103: &050 &092",  0},
   { "%105:",  0},
   { "%055: %104 %082 %105 %106",  0},
   { "%107:",  0},
   { "%055: %104 %082 %107",  0},
   { "%055: %104 %106",  0},
   { "%055: %104 &053",  0},
   { "%055: %104",  0},
   { "%108:",  0},
   { "%104: &002 %010 %108 %109",  0},
   { "%110:",  0},
   { "%104: &002 %010 %110",  0},
   { "%109: &038",  0},
   { "%109: &028",  0},
   { "%109: &037",  0},
   { "%109: &052",  0},
   { "%109: &083",  0},
   { "%109: &084",  0},
   { "%109: &085",  0},
   { "%106: %106 %111",  0},
   { "%106: %111",  0},
   { "%112:",  0},
   { "%111: &035 &098 %112 &042 %113",  0},
   { "%114:",  0},
   { "%057: &012 &018 &098 %114 &003",  0},
   { "%115:",  0},
   { "%057: &012 &018 &098 %115 &006",  0},
   { "%116:",  0},
   { "%057: &012 &018 &098 %116 &021",  0},
   { "%117:",  0},
   { "%057: &012 &018 &098 %117 &025",  0},
   { "%057: &012 &018 &098",  0},
   { "%118:",  0},
   { "%058: &015 &018 &098 %118 &021",  0},
   { "%119:",  0},
   { "%058: &015 &018 &098 %119 &025",  0},
   { "%120:",  0},
   { "%058: &015 &018 &098 %120 &034",  0},
   { "%121:",  0},
   { "%058: &015 &018 &098 %121 &029",  0},
   { "%122:",  0},
   { "%058: &015 &018 &098 %122 &081",  0},
   { "%058: &015 &018 &098",  0},
   { "%123:",  0},
   { "%063: %010 %123 %124",  0},
   { "%125:",  0},
   { "%064: %010 %125 %126",  0},
   { "%064: %010",  0},
   { "%064: &097",  0},
   { "%127:",  0},
   { "%066: %066 &108 %127 %066",  0},
   { "%128:",  0},
   { "%066: %066 &109 %128 %066",  0},
   { "%129:",  0},
   { "%066: %066 &110 %129 %066",  0},
   { "%130:",  0},
   { "%066: %066 &111 %130 %066",  0},
   { "%066: %074 %066 %075",  0},
   { "%131:",  0},
   { "%066: &109 %131 %066",  0},
   { "%066: %132",  0},
   { "%067: &036 %066",  0},
   { "%067: &036",  0},
   { "%133:",  0},
   { "%072: %066 &010 %133 %066",  0},
   { "%134:",  0},
   { "%072: %066 &107 %134 %066",  0},
   { "%072: %135",  0},
   { "%072: %066 &010 &001",  0},
   { "%136:",  0},
   { "%135: &098 %136 %137",  0},
   { "%073: &024",  0},
   { "%074: &121",  0},
   { "%075: &122",  0},
   { "%076: &119",  0},
   { "%077: &049",  0},
   { "%139:",  0},
   { "%078: &030 %138 %139 &128",  0},
   { "%140:",  0},
   { "%078: &030 &096 %140 &128",  0},
   { "%080: &021",  0},
   { "%080: &029",  0},
   { "%080: &034",  0},
   { "%080: &025",  0},
   { "%141:",  0},
   { "%082: &048 %141 %113",  0},
   { "%142:",  0},
   { "%113: %113 &024 %142 %113",  0},
   { "%143:",  0},
   { "%113: &121 %143 %113 &122",  0},
   { "%113: %144",  0},
   { "%145:",  0},
   { "%144: &097 %145 %146 %147",  0},
   { "%148:",  0},
   { "%144: &097 %148 %149",  0},
   { "%150:",  0},
   { "%144: &098 %150 %137",  0},
   { "%151:",  0},
   { "%144: &098 %151 %152 &098",  0},
   { "%146: &010",  0},
   { "%146: &107",  0},
   { "%146: &054",  0},
   { "%137: &055",  0},
   { "%137: &057 &119 &056",  0},
   { "%153:",  0},
   { "%149: %152 &119 %153 &060",  0},
   { "%149: %152 &060",  0},
   { "%152: &059",  0},
   { "%147: %010",  0},
   { "%147: %138",  0},
   { "%147: &097",  0},
   { "%154:",  0},
   { "%138: &109 %154 &011",  0},
   { "%138: &011",  0},
   { "%156:",  0},
   { "%124: %155 %156 %157 %158",  0},
   { "%159:",  0},
   { "%124: %155 %159 %158",  0},
   { "%155: &121",  0},
   { "%158: &122",  0},
   { "%132: %160",  0},
   { "%132: %063",  0},
   { "%160: %010",  0},
   { "%161:",  0},
   { "%160: %010 %161 %126",  0},
   { "%160: &096",  0},
   { "%160: &097",  0},
   { "%160: &011",  0},
   { "%160: &001",  0},
   { "%157: %066",  0},
   { "%162:",  0},
   { "%157: %066 &120 %162 %157",  0},
   { "%163:",  0},
   { "%126: &123 %163 %164 &124",  0},
   { "%165:",  0},
   { "%164: %066 &128 %165 %066",  0},
   { "%164: %066",  0},
   { "%010: &046",  0},
{ "$accept",  0},{ "error",  0}
};
yyNamedType yyTokenTypes[] = {
   { "$end",  0,  0},
   { "error",  256,  0},
   { "qACTIVATE",  1026,  0},
   { "qAFTER",  1002,  0},
   { "qEACH",  1003,  0},
   { "qTATTRIBUTENAME",  1004,  0},
   { "qBEFORE",  1005,  0},
   { "qBASED",  1006,  0},
   { "qBREAK",  1059,  0},
   { "qCASE",  1007,  0},
   { "qCONDOPERATOR",  1009,  0},
   { "qCONSTANT",  1010,  0},
   { "qCREATE",  1011,  0},
   { "qCURSOR",  1012,  0},
   { "qCOMMIT",  1013,  0},
   { "qDELETE",  1014,  0},
   { "qELSE",  1015,  0},
   { "qEND",  1016,  0},
   { "qENTITY",  1017,  0},
   { "qTENTITYNAME",  1018,  0},
   { "qTDATE",  1019,  0},
   { "qFIRST",  1020,  0},
   { "qFOR",  1021,  0},
   { "qIF",  1022,  0},
   { "qJOIN",  1024,  0},
   { "qLAST",  1025,  0},
   { "qLOOP",  1027,  0},
   { "qLOD",  1028,  0},
   { "qMULTIPLE",  1063,  0},
   { "qNEXT",  1030,  0},
   { "qOF",  1032,  0},
   { "qON",  1050,  0},
   { "qOPERATION",  1033,  0},
   { "qOPERATOR",  1034,  0},
   { "qPREVIOUS",  1035,  0},
   { "qRESTRICTING",  1061,  0},
   { "qRETURN",  1036,  0},
   { "qROOTONLY",  1064,  0},
   { "qSINGLE",  1065,  0},
   { "qSET",  1038,  0},
   { "qTDECIMAL",  1039,  0},
   { "qTINTEGER",  1040,  0},
   { "qTO",  1062,  0},
   { "qTSHORT",  1041,  0},
   { "qTSTRING",  1042,  0},
   { "qUNTIL",  1043,  0},
   { "qVARIABLE",  1044,  0},
   { "qTVIEW",  1045,  0},
   { "qWHERE",  1046,  0},
   { "qWHILE",  1047,  0},
   { "qWITHIN",  1048,  0},
   { "qOTHERWISE",  1049,  0},
   { "qROOTONLYMULTIPLE",  1066,  0},
   { "qEMPTY",  1067,  0},
   { "qLIKE",  1068,  0},
   { "qEXISTS",  1069,  0},
   { "qEXIST",  1070,  0},
   { "qDOES",  1071,  0},
   { "qTCHARACTER",  1072,  0},
   { "qIS",  1073,  0},
   { "qNULL",  1074,  0},
   { "qATTRIBUTE",  1075,  0},
   { "qDERIVED",  1076,  0},
   { "qCONSTRAINT",  1077,  0},
   { "qTRANSFORMATION",  1078,  0},
   { "qSHORTCUTKEY",  1079,  0},
   { "qREGISTERED",  1080,  0},
   { "qAS",  1081,  0},
   { "qGET",  1082,  0},
   { "qAT",  1083,  0},
   { "qLEVEL",  1084,  0},
   { "qSUBTASK",  1085,  0},
   { "qTASK",  1086,  0},
   { "qAPPLICATION",  1087,  0},
   { "qSYSTEM",  1088,  0},
   { "qANY",  1089,  0},
   { "qNAME",  1090,  0},
   { "qUSING",  1091,  0},
   { "qINCLUDE",  1092,  0},
   { "qEXCLUDE",  1093,  0},
   { "qFROM",  1094,  0},
   { "qNONE",  1095,  0},
   { "qNAMED",  1096,  0},
   { "qCONTINUE",  1102,  0},
   { "qROOTONLYCONTINUE",  1103,  0},
   { "qSINGLEFORUPDATE",  1104,  0},
   { "qTUNKNOWN",  1100,  0},
   { "qTVOID",  1101,  0},
   { "qAND",  1051,  0},
   { "qOR",  1052,  0},
   { "qGLOBAL",  1053,  0},
   { "qLOCAL",  1054,  0},
   { "qOBJECT",  1055,  0},
   { "qDIALOG",  1056,  0},
   { "qDOMAIN",  1057,  0},
   { "qRETURNED",  1058,  0},
   { "qDEFINE",  1060,  0},
   { "qATTRIBUTEQUALIFIER",  2001,  0},
   { "qENTITYQUALIFIER",  2002,  0},
   { "qRESERVEDWORD",  2003,  0},
   { "qUSERDEFINED",  2004,  0},
   { "qDELIMITER",  2005,  0},
   { "qEXPRESSION",  2006,  0},
   { "qENDFUNC",  2007,  0},
   { "qOPERATIONCALL",  2008,  0},
   { "qNUMERIC",  2009,  0},
   { "qTEXT",  2010,  0},
   { "qEQUAL",  3001,  0},
   { "qADDITION",  3003,  0},
   { "qMINUS",  3002,  0},
   { "qMULTIPLICATION",  3004,  0},
   { "qDIVISION",  3005,  0},
   { "UMINUS",  257,  0},
   { "qCONDEQUAL",  3006,  0},
   { "qLESSTHANEQUAL",  3007,  0},
   { "qLESSTHAN",  3008,  0},
   { "qGREATERTHANEQUAL",  3009,  0},
   { "qGREATERTHAN",  3010,  0},
   { "qNOTEQUAL",  3011,  0},
   { "qNOT",  3012,  0},
   { "qCOMMA",  3013,  0},
   { "qLPAREN",  3014,  0},
   { "qRPAREN",  3015,  0},
   { "qLBRACE",  3016,  0},
   { "qRBRACE",  3017,  0},
   { "qOPENOPER",  3018,  0},
   { "qCLOSEOPER",  3019,  0},
   { "qSEMICOLON",  3020,  0},
   { "qCOLON",  3021,  0},
   { "qUNKNOWNTOKEN",  3031,  0},
   { "qNOTEXISTS",  3022,  0},
   { "qNOTNULL",  3023,  0},
   { "qLOCALOPERATION",  4001,  0},
   { "qDIALOGOPERATION",  4004,  0},
   { "qGLOBALOPERATION",  4002,  0},
   { "qDOMAINOPERATION",  4005,  0},
   { "qOBJECTOPERATION",  4003,  0},
   { "qZEIDONOPERATION",  4006,  0},
   { "qCONTROLOPERATION",  4007,  0},
   { "qBOTHVAR",  5001,  0},
   { "qCONCATOPERATOR",  5002,  0}

};
#endif
static short yydef[] = {

     -1,   -5,   -9,  -13,  -41,   49,  -49,  -59,  -63,  334,
    -67,    7,  337,  338, -123, -127,  328, -131, -137,   48,
   -153, -157,   38,   23,  333, -161, -175, -183,   25, -191,
   -195, -199,    6, -203, -207, -219,   34, -229,   32,   30,
   -235, -249, -257,   24, -261, -265, -279, -293, -301,  326,
     46,   33,   31,   29,   28,  331,  332,   14,  329,  330,
    323,  325,   69,   68,   52,  324
};
static short yyex[] = {

   1016,  336,   -1,    1, 1033,  209,   -1,    3,    0,    0,
     -1,    1, 1004,  327, 1015,  327, 1016,  327, 1018,  327,
   1032,  327, 1039,  327, 1040,  327, 1041,  327, 1042,  327,
   1043,  327, 1045,  327, 1049,  327, 1072,  327,   -1,    1,
   3001,   66, 3014,   64, 3016,   65,   -1,    1, 1003,   39,
   1010,   41, 1044,   40, 2002,   42,   -1,    1, 1016,   37,
     -1,    1, 1016,   13,   -1,    1, 1026,  335, 1004,  335,
   1007,  335, 1011,  335, 1013,  335, 1014,  335, 1016,  335,
   1018,  335, 1021,  335, 1022,  335, 1027,  335, 1036,  335,
   1038,  335, 1039,  335, 1040,  335, 1041,  335, 1042,  335,
   1044,  335, 1045,  335, 1072,  335, 1082,  335, 1090,  335,
   1092,  335, 1093,  335, 2001,  335, 3013,  335, 3015,  335,
     -1,    1, 3015,    5,   -1,    4, 1016,  336,   -1,    1,
   3014,   64, 3016,   77,   -1,   76, 1063,   50, 1064,   50,
   1065,   50, 1066,   50, 1102,   50, 1103,   50, 1104,   50,
     -1,   51, 1061,   45,   -1,   47, 1048,   43,   -1,   44,
   1009,   83, 3001,   83, 3003,   83, 3002,   83, 3004,   83,
   3005,   83,   -1,   19,  256,   16, 1015,   16, 1016,   16,
     -1,   18,  256,   15, 1015,   15, 1016,   15,   -1,   17,
   1016,   10,   -1,    1, 1016,   20,   -1,   21, 3015,    8,
     -1,    1, 3015,   75,   -1,   74, 1020,   58, 1025,   59,
   1030,   61, 1035,   60, 1095,   62,   -1,   63, 1002,   53,
   1005,   54, 1020,   55, 1025,   56,   -1,   57, 1010,   35,
   1044,   36,   -1,    1, 1010,   67, 1044,   67, 1060,   67,
   2001,   67, 3002,   67, 3014,   67,   -1,    1,  256,   27,
   1016,   27, 1032,   27,   -1,   26, 1016,   12,   -1,    1,
   1016,   11,   -1,    1, 1009,   83, 3001,   83, 3003,   83,
   3002,   83, 3004,   83, 3005,   83,   -1,   22, 1009,   83,
   3001,   83, 3003,   83, 3002,   83, 3004,   83, 3005,   83,
     -1,    9, 1069,   72, 1071,   72, 1073,   73,   -1,    1,
   1009,   70, 1068,   70, 1073,   71, 3001,   70,   -1,    1
};
static short yyact[] = {

     -2, -343, -347, -348, -344, -346, -345, -341, -342, -340,
   1079, 1078, 1076, 1057, 1056, 1055, 1054, 1053, 1017,  256,
   -202, 1033, -324, -191, -200, -193, -201, -325,   -7, -190,
   -199, -304,   -4, -192, -327, -328, -323,  -12, -208, -186,
   -322, -194, -195, -196, -197, -262,  -15, 3014, 2001, 1093,
   1092, 1090, 1082, 1072, 1045, 1044, 1042, 1041, 1040, 1039,
   1038, 1036, 1027, 1026, 1022, 1021, 1018, 1014, 1013, 1011,
   1007, 1004, -339, -343, -347, -348, -344, -346, -345, -341,
   -342, -340, 1079, 1078, 1076, 1057, 1056, 1055, 1054, 1053,
   1017,  256, -359, 1075, -358, 1077, -357, 1077, -349, -208,
   1044,  256, -213, -214, -208, -216, -215, -257, -250, 3014,
   3002, 2001, 1060, 1044, 1010,  256, -181, 1017, -180, 1017,
   -208, 1044, -238, -179, -272, 1067, 1061, 1046,  -22, 2002,
   -191, -200, -193, -201,   -7, -190, -199, -304,   -4, -192,
   -208, -194, -195, -196, -197, -262, 2001, 1093, 1092, 1090,
   1082, 1044, 1038, 1036, 1027, 1026, 1022, 1021, 1014, 1013,
   1011, 1007, -291, 2002, -295, 2002, -174, 1045, -173, 1045,
   -172, 1012,  -26, -214, -208, -216, -215, -253, -257, -248,
   -250, 3014, 3012, 3002, 2002, 2001, 1060, 1044, 1010,  256,
   -306, 3001, -308, -168, -167, 1049, 1032,  256, -191, -200,
   -193, -201,   -7, -190, -199, -304,   -4, -192, -163, -208,
   -247, -194, -195, -196, -197, -262, 2001, 1093, 1092, 1090,
   1082, 1047, 1044, 1043, 1038, 1036, 1027, 1026, 1022, 1021,
   1014, 1013, 1011, 1007, -316,  -31, -331, 1016, 1015,  256,
   -320, -158, -159, 1080, 1006,  256,  -32, 3014, -329, -208,
   1044,  256, -324, -325, -327, -328, -323,  -12, -186, -322,
   1072, 1045, 1042, 1041, 1040, 1039, 1018, 1004, -324, -191,
   -200, -193, -201, -325,   -7, -190, -199, -304,   -4, -192,
   -327, -328, -323,  -12, -208, -186, -322, -194, -195, -196,
   -197, -262, 2001, 1093, 1092, 1090, 1082, 1072, 1045, 1044,
   1042, 1041, 1040, 1039, 1038, 1036, 1027, 1026, 1022, 1021,
   1018, 1014, 1013, 1011, 1007, 1004, -260, -261, -259, -258,
   3005, 3004, 3003, 3002, -211, 3016, -448, 3014,  -35, 2002,
    -36, 2002, -263, 2002, -179, 1061, -421, 1010, -419, 1003,
   -238, 1046, -331, 1016, -242, -239, -241, -240, 1035, 1030,
   1025, 1020,  -41, -256, -260, -261, -259, -258, 3005, 3004,
   3003, 3002, 3001, 1009, -248, -250, 3014, 3012, -213, -214,
   -208, -216, -215, -253, -257, -248, -250, 3014, 3012, 3002,
   2002, 2001, 1060, 1044, 1010,  256, -251, 1024, -445, -244,
   -218, 3002, 1060, 1010,  -42, 3021, -309, -168, 1032,  256,
   -310, -331, -168, -167, 1049, 1032, 1016,  256,  -46, -214,
   -208, -216, -215, -253, -257, -248, -250, 3014, 3012, 3002,
   2002, 2001, 1060, 1044, 1010,  256,  -47, -214, -208, -216,
   -215, -253, -257, -248, -250, 3014, 3012, 3002, 2002, 2001,
   1060, 1044, 1010,  256, -315, -191, -200, -193, -201, -331,
     -7, -190, -199, -304,   -4, -192, -208, -194, -195, -196,
   -197, -262, 2001, 1093, 1092, 1090, 1082, 1044, 1038, 1036,
   1027, 1026, 1022, 1021, 1016, 1014, 1013, 1011, 1007,  256,
   -163, 1043, -131, 1081, -130, 1050, -321, 1010, -337, 3015,
   -324, -325, -327, -328, -323,  -12, -186, -368, -322, 1072,
   1058, 1045, 1042, 1041, 1040, 1039, 1018, 1004, -260, -261,
   -259, -258, -249, 3015, 3005, 3004, 3003, 3002, -269, -268,
   -270, -267, -266, -265, -264, 1104, 1103, 1102, 1066, 1065,
   1064, 1063,  -49,  -48, -236, 3014, 2002, 2001, -108, 1048,
   -288, -290, -289, 1095, 1005, 1002, -107, 1094, -104, 1083,
   -227, -102, 1071, 1069, -254,  256,  -41, -256, -260, -261,
   -259, -258, -249, 3015, 3005, 3004, 3003, 3002, 3001, 1009,
   -249, 3015, -168, 1032, -311,  256, -314, -331, 1016,  256,
    -93, 1028, -370, 3015, -336,  -91, -338, 3015, 3013,  256,
   -217, 3015, -434, 1095, -433, 1030, -432, 1035, -431, 1025,
   -430, 1020, -429, 1025, -428, 1020, -427, 1005, -426, 1002,
   -237, 1024,  -83, 1062, -274, -275, 2002, 1055, -294, 2002,
   -292, -293, 1005, 1002, -287, 1010,  -82, 1084,  -81, 1091,
    -80, 1096,  -79, 1091,  -78, 3012, -444, 1010, -243, 3021,
   -245, 3021, -369, 3015, -259, -258, 3005, 3004, -210, 3017,
   -260, -261, -259, -258, -209, 3021, 3005, 3004, 3003, 3002,
   -260, -261, -259, -258, -212, 3013, 3005, 3004, 3003, 3002,
   -222, 1073, -230, -228, -229, 3001, 1068, 1009, -282, -281,
   -280, -279, -278, 1089, 1088, 1087, 1086, 1085, -284, -208,
   1044, 1010, -226, 1070, -231, 2002, -223, -225, 3012, 1074,
   -445, -208, -219, -218, 3002, 2001, 1044, 1010, -237, -235,
   3015, 1024, -224, 1074,   -1
};
static short yypact[] = {

     47,   72,   82,  109,  116,  125,  128,  146,  195,  146,
    243,  247,  260,  292,  316,  292,  320,  324,  332,  335,
    336,  340,  341,  320,  387,  388,  388,  388,  146,  398,
    482,  487,  260,  518,  518,  518,  543,  548,  549,  549,
    555,  572,  573,  146,  575,  576,  576,  610,  610,  611,
    335,  622,  629,  633,  341,  387,  387,  320,  646,  646,
    655,  665,  320,  320,  611,  320,  713,  109,  109,  535,
    710,  704,  698,  695,  499,  377,  377,  693,  121,  690,
    121,  683,  535,  535,  675,  671,  552,  671,  591,  649,
    499,  643,  121,  343,  343,  146,  641,  639,  637,  109,
    109,  635,  631,  627,  625,  121,  619,  616,  613,  609,
    607,  605,  603,  601,  599,  597,  595,  593,  109,  591,
    109,  109,  109,  109,  109,  343,  587,  260,  583,  581,
    121,  146,  578,  343,  109,  146,  146,  146,  377,  571,
    571,  563,  377,  552,  129,  547,  343,  539,  335,  535,
    525,  325,  513,  109,  343,  499,  489,  485,  483,  343,
    481,  462,  435,  417,  404,  343,  395,  391,  377,  366,
    358,  348,  121,  121,  343,  339,  121,  337,  333,  331,
    329,  327,  325,  109,  250,  121,  237,  216,  191,  181,
    109,  171,  121,  169,  167,  165,  163,  129,  121,  119,
    117,  100,   97,   95,   93,   21,   10
};
static short yygo[] = {

     -3, -356, -355,    2,   -1,  -16, -354, -352,   15, -126,
   -389, -390, -353, -386, -388, -417, -351, -382, -385, -387,
   -391, -418, -381,  174,  165,  164,  161,  159,  154,  146,
    133,  132,  125,   94,   93, -155, -206,   -5,   -5,   -5,
     -5,   -5,   -5,   -5, -221, -297, -283, -296, -318,   -5,
   -286, -317,   -5,   -5,   -5,   -5,   -5, -285,  -38, -420,
   -330, -319,   -5, -298,  -19, -350,  -18,  201,  198,  192,
    187,  185,  184,  176,  173,  172,  161,  137,  136,  135,
    131,  130,  105,   95,   92,   80,   79,   78,   71,   43,
     28,   15,   13,    9,    7,    0, -203, -204, -205, -156,
   -127, -157, -362, -361, -360,   90,   74,  -75, -335, -335,
   -334, -335, -366,  155,  127,   90,   74, -128, -333, -333,
   -332, -333, -367,  155,  127,   90,   74,  -33,  -14,   12,
   -277, -363, -300, -301, -413, -405, -402, -403, -404, -133,
   -161,  -13,  187,  161,  137,  136,  135,  131,   95,   43,
     28,   13,    7, -365, -365, -364,   32,   13, -185, -326,
    -92, -129,  -11, -371,  -10, -373, -372,    9, -375, -374,
      9, -376, -377, -378, -379, -380, -187, -160, -188, -384,
   -383,  160, -162, -409, -411, -406, -313, -303,  -28, -140,
    189,  163,  162,  138,   76,   75, -408, -410, -407, -312,
   -302, -412,  -27, -141,  189,  169,  163,  162,  138,   76,
     75,   -9,  -43, -165,   29,  -45,  -30,  164, -134,  -94,
    -95, -166, -392, -393, -394, -395, -396, -397, -398, -399,
   -400, -401, -307, -307, -307, -307, -307, -307, -307, -307,
   -307, -307, -307, -307, -307, -307, -450,  187,  161,  137,
    136,  135,  131,   95,   43,   28,   15,   13,    9,    7,
      0, -189, -135,  -17,  -62,  -66,  -64,  -63,  -62,  -61,
    -60,  -59, -437, -438,  -58, -440, -142, -153,  -24, -171,
    190,  183,  168,  153,  134,  124,  123,  122,  121,  120,
    118,  100,   99,   68,   67,    3, -305, -136, -137, -138,
   -132,  -25,  -77,  -76, -139,   56,   55, -169, -169, -169,
   -169, -169, -169, -169, -143, -169, -184,  189,  169,  168,
    163,  162,  142,  138,   76,   75,  -57,  -56, -439,  140,
    139, -170, -164,  -44,  -44,  -29,  164,   42,  -96, -145,
    -55,  -23,  144, -276, -299,  -21,   54,   22,  -40,  -54,
    -53,   39,  -39, -146,  -52, -414,  -37, -415, -105, -106,
   -103, -416,   -8, -147, -175, -198, -176, -177, -178, -148,
   -422,   -6, -149,  -51,  -20,  148, -273, -151, -423, -271,
   -424, -424, -425,   50,   19, -109, -442,  -65,  -71,  -50,
     83,   82,   69, -110, -111, -112, -113, -114, -115, -116,
   -117, -118, -182, -435, -183, -451, -436,  151, -122, -123,
   -124, -125, -154, -441, -100, -101, -255, -144, -232, -252,
     86, -220, -246,   71,  -97,  -98, -150,  -70,  -84, -443,
    -85,  -72, -234,  -86, -233,  -87,  -88,  -73,  -74,   85,
    -67,  -99,  -34, -119, -452,  -89,   67, -446, -447,   88,
   -120, -449, -152,  -68, -121,  -90,  -69,   -1
};
static short yypgo[] = {

      0,    0,    0,    0,   99,  101,    7,  158,  161,  180,
    218,  219,  220,  221,  175,  176,  176,  297,  298,  299,
    177,  300,  182,  211,  213,  213,  338,  216,  222,  228,
    228,  229,  229,  355,  357,  358,  359,  364,  362,  366,
    367,  368,  365,  369,  341,  372,  224,  376,  224,  224,
    377,  379,  382,  393,  394,  395,  396,  226,  397,  398,
    399,  400,  401,  227,  402,  404,  261,  414,  301,  301,
    430,  433,  435,  436,  443,  450,  451,  452,   66,  456,
    406,  454,  453,  451,  451,  451,  451,  448,  441,  432,
    432,  432,  438,  434,  434,  440,  419,  419,  431,  431,
    431,  429,  429,  429,  429,  389,  428,  427,  426,  339,
    339,  339,  339,  335,  425,  335,  424,  332,  331,  328,
    316,  304,  416,  417,  301,  301,  415,  412,  411,  410,
    409,  408,  261,  385,  378,  378,  378,  378,  378,  378,
    378,  371,  224,  224,  370,  370,  362,  363,  350,  350,
    350,  350,  350,  361,  361,  360,  352,  352,  357,  357,
    357,  356,  355,  355,  354,  353,  229,  228,  225,  222,
    213,  213,  182,  182,  178,  166,  262,  175,  173,  173,
    173,  173,  180,  180,  172,  172,  171,  163,  163,  162,
    122,  160,  158,  158,  158,  158,  158,  158,  158,  112,
    112,   22,  104,  104,  104,  104,  107,    5,    5,   36,
     36,   98,   36,   97,   96,   36,   36,   36,   36,    4,
      4,    2,   35,    2,    9,    0,    0,   36,   36,   36,
    100,  100,  100,    7,  128,  128,  155,  155,  117,  159,
    159,  122,  141,  141,  164,  164,  169,  169,  169,  169,
    169,  171,  171,  172,  172,  172,  172,  173,  173,  173,
    173,  173,  174,  174,  174,  174,  174,  174,  174,  174,
    174,  174,  176,  176,  176,  177,  189,  189,  203,  203,
    203,  203,  203,  216,  230,  231,  348,  223,  223,  365,
    365,  365,  341,  371,  374,  374,  226,  226,  226,  226,
    227,  227,  227,  227,  227,  246,  261,  279,  279,  279,
    279,  279,  389,  389,  422,  422,  403,  403,  442,  413,
    413,  451,  445,  455,  455,  445,  345,  296,  296,  279,
    279,  203,  203,  189,  141,  122,    7,    7,    7,    0
};
static short yyrlen[] = {

      0,    0,    0,    1,    0,    0,    2,    1,    0,    2,
      0,    0,    0,    0,    4,    2,    2,    0,    0,    0,
      1,    0,    2,    2,    2,    1,    0,    2,    4,    4,
      3,    4,    3,    0,    0,    0,    0,    0,    2,    0,
      0,    0,    1,    0,    1,    0,    4,    0,    2,    1,
      0,    0,    5,    0,    0,    0,    0,    3,    0,    0,
      0,    0,    0,    3,    0,    0,    1,    0,    4,    4,
      0,    0,    0,    0,    0,    0,    1,    0,    1,    0,
      4,    0,    0,    1,    1,    1,    1,    1,    0,    1,
      1,    1,    1,    2,    4,    0,    3,    1,    1,    1,
      1,    4,    3,    3,    4,    4,    0,    0,    0,    1,
      1,    1,    1,    4,    0,    4,    0,    1,    1,    1,
      1,    1,    3,    0,    3,    1,    0,    0,    0,    0,
      0,    0,    1,    0,    1,    1,    1,    1,    1,    1,
      1,    3,    2,    3,    2,    2,    3,    0,    3,    3,
      3,    3,    3,    1,    1,    0,    3,    3,    1,    1,
      1,    0,    1,    1,    2,    0,    6,    6,    2,    5,
      2,    3,    2,    2,    1,    1,    0,    1,    2,    3,
      3,    4,    2,    2,    4,    3,    2,    3,    4,    2,
      2,    0,    1,    1,    1,    1,    2,    1,    1,    2,
      2,    1,    2,    1,    2,    1,    0,    3,    4,    1,
      1,    0,    1,    0,    0,    1,    1,    1,    1,    3,
      3,    4,    0,    5,    0,    1,    2,    3,    3,    3,
      1,    3,    4,    2,    1,    2,    1,    1,    1,    4,
      3,    2,    1,    2,    1,    2,    1,    1,    1,    1,
      1,    2,    3,    2,    3,    3,    4,    3,    4,    5,
      5,    3,    1,    1,    1,    1,    1,    1,    1,    1,
      1,    1,    4,    4,    4,    3,    3,    3,    5,    5,
      5,    5,    2,    4,    5,    4,    4,    4,    3,    3,
      3,    3,    3,    4,    2,    1,    5,    5,    5,    5,
      5,    5,    5,    5,    5,    3,    3,    4,    4,    3,
      3,    1,    4,    1,    3,    1,    4,    3,    1,    1,
      1,    3,    4,    1,    4,    1,    3,    1,    2,    4,
      4,    3,    3,    1,    1,    1,    0,    1,    1,    2
};
#define YYS0   206
#define YYDELTA   129
#define YYNPACT   207
#define YYNDEF   66

#define YYr337   0
#define YYr338   1
#define YYr339   2
#define YYr3   3
#define YYr23   4
#define YYr25   5
#define YYr38   6
#define YYr50   7
#define YYr58   8
#define YYr87   9
#define YYr89   10
#define YYr91   11
#define YYr97   12
#define YYr99   13
#define YYr113   14
#define YYr115   15
#define YYr116   16
#define YYr117   17
#define YYr119   18
#define YYr121   19
#define YYr123   20
#define YYr124   21
#define YYr139   22
#define YYr140   23
#define YYr142   24
#define YYr144   25
#define YYr145   26
#define YYr147   27
#define YYr148   28
#define YYr152   29
#define YYr153   30
#define YYr155   31
#define YYr156   32
#define YYr162   33
#define YYr168   34
#define YYr169   35
#define YYr171   36
#define YYr184   37
#define YYr187   38
#define YYr188   39
#define YYr190   40
#define YYr192   41
#define YYr194   42
#define YYr195   43
#define YYr197   44
#define YYr200   45
#define YYr201   46
#define YYr202   47
#define YYr204   48
#define YYr206   49
#define YYr207   50
#define YYr209   51
#define YYr221   52
#define YYr222   53
#define YYr224   54
#define YYr226   55
#define YYr228   56
#define YYr230   57
#define YYr231   58
#define YYr233   59
#define YYr235   60
#define YYr237   61
#define YYr239   62
#define YYr241   63
#define YYr242   64
#define YYr244   65
#define YYr246   66
#define YYr262   67
#define YYr263   68
#define YYr265   69
#define YYr290   70
#define YYr292   71
#define YYr294   72
#define YYr296   73
#define YYr313   74
#define YYr315   75
#define YYr321   76
#define YYr322   77
#define YYr336   78
#define YYr333   79
#define YYr332   80
#define YYr331   81
#define YYr329   82
#define YYr327   83
#define YYr326   84
#define YYr325   85
#define YYr324   86
#define YYr318   87
#define YYr310   88
#define YYr309   89
#define YYr308   90
#define YYr307   91
#define YYr306   92
#define YYr305   93
#define YYr304   94
#define YYr303   95
#define YYr302   96
#define YYr301   97
#define YYr300   98
#define YYr299   99
#define YYr298   100
#define YYr297   101
#define YYr295   102
#define YYr293   103
#define YYr291   104
#define YYr288   105
#define YYr287   106
#define YYr285   107
#define YYr283   108
#define YYr282   109
#define YYr281   110
#define YYr280   111
#define YYr279   112
#define YYr278   113
#define YYr277   114
#define YYr276   115
#define YYr275   116
#define YYr274   117
#define YYr273   118
#define YYr272   119
#define YYr271   120
#define YYr270   121
#define YYr269   122
#define YYr268   123
#define YYr267   124
#define YYr266   125
#define YYr264   126
#define YYr257   127
#define YYr254   128
#define YYr252   129
#define YYr250   130
#define YYr248   131
#define YYr247   132
#define YYr220   133
#define YYr217   134
#define YYr216   135
#define YYr215   136
#define YYr214   137
#define YYr213   138
#define YYr212   139
#define YYr211   140
#define YYr210   141
#define YYr205   142
#define YYr203   143
#define YYr199   144
#define YYr198   145
#define YYr186   146
#define YYr182   147
#define YYr181   148
#define YYr180   149
#define YYr179   150
#define YYr178   151
#define YYr177   152
#define YYr176   153
#define YYr175   154
#define YYr173   155
#define YYr172   156
#define YYr170   157
#define YYr167   158
#define YYr166   159
#define YYr165   160
#define YYr163   161
#define YYr161   162
#define YYr160   163
#define YYr159   164
#define YYr157   165
#define YYr154   166
#define YYr151   167
#define YYr150   168
#define YYr149   169
#define YYr143   170
#define YYr141   171
#define YYr138   172
#define YYr137   173
#define YYr126   174
#define YYr114   175
#define YYr112   176
#define YYr111   177
#define YYr96   178
#define YYr95   179
#define YYr94   180
#define YYr93   181
#define YYr86   182
#define YYr85   183
#define YYr84   184
#define YYr83   185
#define YYr78   186
#define YYr65   187
#define YYr64   188
#define YYr63   189
#define YYr62   190
#define YYr56   191
#define YYr54   192
#define YYr53   193
#define YYr52   194
#define YYr51   195
#define YYr49   196
#define YYr48   197
#define YYr47   198
#define YYr46   199
#define YYr45   200
#define YYr40   201
#define YYr34   202
#define YYr33   203
#define YYr32   204
#define YYr31   205
#define YYr29   206
#define YYr26   207
#define YYr24   208
#define YYr22   209
#define YYr21   210
#define YYr19   211
#define YYr18   212
#define YYr16   213
#define YYr14   214
#define YYr13   215
#define YYr12   216
#define YYr11   217
#define YYr10   218
#define YYr9   219
#define YYr8   220
#define YYr7   221
#define YYr6   222
#define YYr5   223
#define YYr4   224
#define YYrACCEPT   YYr337
#define YYrERROR   YYr338
#define YYrLR2   YYr339
#if YYDEBUG
char * yysvar[] = {
   "$accept",
   "application",
   "operation_definition",
   "operation_declaration",
   "parameter_definition_list",
   "operation_body",
   "$4",
   "end_clause",
   "$6",
   "operation_type",
   "symbol",
   "$14",
   "$16",
   "$19",
   "$23",
   "parameter_declaration_list",
   "$25",
   "parameter_declaration",
   "$29",
   "local_declaration",
   "pointer_indicator",
   "view_declaration",
   "declaration_list",
   "statement_list",
   "declaration",
   "data_type",
   "dimension",
   "$56",
   "$58",
   "view_name",
   "view_type",
   "multiple_statements",
   "exit_statement",
   "statement",
   "conditional_statement",
   "loop_statement",
   "selection_statement",
   "action_statement",
   "assignment_statement",
   "if_phrase",
   "else_phrase",
   "loop_phrase",
   "until_phrase",
   "while_clause",
   "compound_condition",
   "multiple_condition",
   "case_phrase",
   "of_list",
   "otherwise",
   "$89",
   "$91",
   "$97",
   "$99",
   "set_action",
   "for_action",
   "activate_action",
   "commit_action",
   "create_action",
   "delete_action",
   "get_action",
   "name_action",
   "include_action",
   "exclude_action",
   "operation_call",
   "left_element",
   "$112",
   "r_expression",
   "return_value",
   "$117",
   "$119",
   "$121",
   "$124",
   "condition",
   "conditional_join",
   "lparen",
   "rparen",
   "negation_op",
   "while_keyword",
   "of_clause",
   "$145",
   "fnpl_phrase",
   "cursor_target",
   "where_clause",
   "view_var",
   "task_level",
   "name_var",
   "$157",
   "source_eq",
   "position",
   "$163",
   "exclude_position",
   "$169",
   "$171",
   "$173",
   "view_qual",
   "for_entry",
   "$182",
   "$184",
   "qualified_for",
   "$188",
   "$190",
   "$192",
   "$195",
   "scope",
   "activate_phrase",
   "$200",
   "restricting_phrase",
   "$202",
   "$207",
   "zdefine",
   "$209",
   "restricting_clause",
   "$220",
   "attribute_where_phrase",
   "$222",
   "$224",
   "$226",
   "$228",
   "$231",
   "$233",
   "$235",
   "$237",
   "$239",
   "$242",
   "parameter_value_list",
   "$244",
   "offset",
   "$248",
   "$250",
   "$252",
   "$254",
   "$257",
   "simple_expression",
   "$262",
   "$264",
   "exist_condition",
   "$268",
   "exist_phrase",
   "aconstant",
   "$275",
   "$277",
   "$283",
   "$285",
   "$287",
   "attribute_op_phrase",
   "$290",
   "where_op",
   "where_value",
   "$292",
   "is_null_phrase",
   "$294",
   "$296",
   "is_keyword",
   "$303",
   "$310",
   "openoper",
   "$313",
   "value_list",
   "closeoper",
   "$315",
   "value",
   "$322",
   "$329",
   "$331",
   "index_and_length",
   "$333",
   0
};
short yyrmap[] = {

    337,  338,  339,    3,   23,   25,   38,   50,   58,   87,
     89,   91,   97,   99,  113,  115,  116,  117,  119,  121,
    123,  124,  139,  140,  142,  144,  145,  147,  148,  152,
    153,  155,  156,  162,  168,  169,  171,  184,  187,  188,
    190,  192,  194,  195,  197,  200,  201,  202,  204,  206,
    207,  209,  221,  222,  224,  226,  228,  230,  231,  233,
    235,  237,  239,  241,  242,  244,  246,  262,  263,  265,
    290,  292,  294,  296,  313,  315,  321,  322,  336,  333,
    332,  331,  329,  327,  326,  325,  324,  318,  310,  309,
    308,  307,  306,  305,  304,  303,  302,  301,  300,  299,
    298,  297,  295,  293,  291,  288,  287,  285,  283,  282,
    281,  280,  279,  278,  277,  276,  275,  274,  273,  272,
    271,  270,  269,  268,  267,  266,  264,  257,  254,  252,
    250,  248,  247,  220,  217,  216,  215,  214,  213,  212,
    211,  210,  205,  203,  199,  198,  186,  182,  181,  180,
    179,  178,  177,  176,  175,  173,  172,  170,  167,  166,
    165,  163,  161,  160,  159,  157,  154,  151,  150,  149,
    143,  141,  138,  137,  126,  114,  112,  111,   96,   95,
     94,   93,   86,   85,   84,   83,   78,   65,   64,   63,
     62,   56,   54,   53,   52,   51,   49,   48,   47,   46,
     45,   40,   34,   33,   32,   31,   29,   26,   24,   22,
     21,   19,   18,   16,   14,   13,   12,   11,   10,    9,
      8,    7,    6,    5,    4,    1,    2,   15,   17,   20,
     27,   28,   30,   37,   41,   42,   43,   44,   55,   57,
     59,   60,   67,   68,   69,   70,   71,   72,   73,   74,
     75,   76,   77,   79,   80,   81,   82,   88,   90,   92,
     98,  100,  101,  102,  103,  104,  105,  106,  107,  108,
    109,  110,  118,  120,  122,  125,  128,  129,  131,  132,
    134,  135,  136,  146,  158,  164,  174,  183,  185,  189,
    191,  193,  196,  208,  218,  219,  223,  225,  227,  229,
    232,  234,  236,  238,  240,  243,  245,  253,  255,  256,
    258,  259,  286,  289,  311,  312,  314,  316,  317,  319,
    320,  323,  330,  335,  334,  328,  284,  261,  260,  251,
    249,  133,  130,  127,   66,   61,   39,   36,   35,    0
};
short yysmap[] = {

     11,   12,   14,   20,   22,   26,   27,   29,   52,   62,
     64,   69,   76,   77,   78,   80,   98,   99,  104,  109,
    110,  114,  115,  124,  131,  132,  133,  134,  138,  141,
    149,  161,  165,  182,  184,  185,  200,  202,  203,  205,
    213,  229,  232,  235,  237,  239,  242,  292,  293,  296,
    298,  307,  311,  313,  314,  321,  322,  328,  353,  354,
    356,  360,  391,  392,  420,  448,  450,  438,  437,  419,
    418,  417,  412,  410,  403,  394,  393,  390,  388,  387,
    386,  385,  376,  374,  373,  372,  371,  370,  359,  355,
    348,  344,  342,  337,  333,  332,  331,  330,  329,  320,
    318,  315,  312,  310,  309,  308,  306,  299,  297,  283,
    282,  281,  280,  279,  278,  277,  276,  275,  274,  273,
    272,  270,  269,  268,  267,  263,  261,  258,  253,  252,
    251,  249,  246,  234,  224,  223,  222,  221,  220,  218,
    217,  216,  215,  211,  210,  201,  199,  196,  192,  188,
    187,  178,  173,  172,  170,  169,  168,  158,  157,  151,
    147,  146,  145,  144,  142,  139,  137,  136,  130,  129,
    128,  123,  121,  120,  116,  113,  112,  111,  106,  103,
    102,  101,  100,   97,   72,   63,   54,   53,   40,   38,
     36,   35,   34,   33,   32,   31,   30,   28,   25,   24,
     23,   18,   17,   16,   15,   10,    0,   19,  406,  405,
    179,  408,   88,   89,   90,   91,  357,  226,  442,  443,
    444,  409,  440,  451,  441,  431,  316,  414,  415,  416,
    439,  411,  413,  445,  446,  295,  375,  105,  206,  207,
    208,  209,  396,  227,  397,  228,  143,  125,  265,   94,
    219,  317,  126,  319,  127,  212,   96,  174,  175,  176,
    177,   21,  189,  284,  285,  286,  287,  288,  289,  290,
    186,  108,  191,  377,  378,  197,  117,  421,  422,  423,
    424,  425,  427,  428,  204,  383,  384,  302,  303,  304,
    118,  380,  381,  379,  119,  426,  430,  122,  389,  230,
    335,  240,  241,   37,   39,  135,   41,  140,  233,  236,
    336,  243,  244,  338,  245,  150,  341,  401,  156,  159,
    254,   65,   66,   67,   68,  162,   70,   71,  163,  164,
    153,  345,  257,  346,  259,  347,  255,  349,   81,    1,
      2,    3,    4,    5,    6,    7,    8,    9,   86,   87,
    262,   79,  350,  171,   13,   82,   85,   84,   83,  260,
    404,  436,  167,   75,  166,   74,   73,  256,  402,  343,
    160,   61,  155,   60,  154,   59,   58,   57,   56,   55,
    152,  250,  148,  248,  247,  339,  238,  334,  400,  399,
    231,   51,   50,   49,   48,   47,   46,   45,   44,   43,
     42,  327,  326,  325,  340,  324,  323,  435,  434,  433,
    432,  214,  398,  382,  305,  429,  301,  198,  195,  194,
    193,  300,  291,  190,  107,  369,  368,  367,  366,  365,
    364,  363,  362,  361,  183,  180,  352,  351,  266,  264,
     95,  447,  294,  395,  225,  407,  358,  181,   93,   92,
    271,  449
};
int yyntoken = 141;
int yynvar = 166;
int yynstate = 452;
int yynrule = 340;
#endif

#if YYDEBUG
/*
 * Package up YACC context for tracing
 */
typedef struct yyTraceItems_tag {
   int   state, lookahead, errflag, done;
   int   rule, npop;
   short   * states;
   int   nstates;
   YYSTYPE * values;
   int   nvalues;
   short   * types;
} yyTraceItems;
#endif


/*
 * Copyright 1985, 1990 by Mortice Kern Systems Inc.  All rights reserved.
 *
 * Automaton to interpret LALR(1) tables.
 *
 * Macros:
 *   yyclearin - clear the lookahead token.
 *   yyerrok - forgive a pending error
 *   YYERROR - simulate an error
 *   YYACCEPT - halt and return( 0 )
 *   YYABORT - halt and return( 1 )
 *   YYRETURN(value) - halt and return value.  You should use this
 *      instead of return(value).
 *   YYREAD - ensure qqchar contains a lookahead token by reading
 *      one if it does not.  See also YYSYNC.
 *   YYRECOVERING - 1 if syntax error detected and not recovered
 *      yet; otherwise, 0.
 *
 * Preprocessor flags:
 *   YYDEBUG - includes debug code if 1.  The parser will print
 *       a travelogue of the parse if this is defined as 1
 *       and qqdebug is non-zero.
 *      yacc -t sets YYDEBUG to 1, but not qqdebug.
 *   YYTRACE - turn on YYDEBUG, and undefine default trace functions
 *      so that the interactive functions in 'ytrack.c' will
 *      be used.
 *   YYSSIZE - size of state and value stacks (default 150).
 *   YYSTATIC - By default, the state stack is an automatic array.
 *      If this is defined, the stack will be static.
 *      In either case, the value stack is static.
 *   YYALLOC - Dynamically allocate both the state and value stacks
 *      by calling malloc() and free().
 *   YYDYNAMIC - Dynamically allocate (and reallocate, if necessary)
 *      both the state and value stacks by calling malloc(),
 *      realloc(), and free().
 *   YYSYNC - if defined, yacc guarantees to fetch a lookahead token
 *      before any action, even if it doesnt need it for a decision.
 *      If YYSYNC is defined, YYREAD will never be necessary unless
 *      the user explicitly sets qqchar = -1
 *
 * Copyright (c) 1983, by the University of Waterloo
 */
/*
 * Prototypes
 */

#if defined(_MSC_VER)
# pragma warning(disable: 4102) // 'yyerrlabel' : unreferenced label
#endif

extern int qqlex YY_ARGS((void));
extern int qqerror YY_ARGS((zVIEW vSubtask, zCPCHAR , ...));

#if YYDEBUG

#include <stdlib.h>      /* common prototypes */
#include <string.h>

extern zPCHAR   yyValue YY_ARGS((YYSTYPE, int));   /* print qqlval */
extern void yyShowState YY_ARGS((yyTraceItems *));
extern void yyShowReduce YY_ARGS((yyTraceItems *));
extern void yyShowGoto YY_ARGS((yyTraceItems *));
extern void yyShowShift YY_ARGS((yyTraceItems *));
extern void yyShowErrRecovery YY_ARGS((yyTraceItems *));
extern void yyShowErrDiscard YY_ARGS((yyTraceItems *));

extern void yyShowRead YY_ARGS((int));
#endif

/*
 * If YYDEBUG defined and qqdebug set,
 * tracing functions will be called at appropriate times in qqparse()
 * Pass state of YACC parse, as filled into yyTraceItems yyx
 * If yyx.done is set by the tracing function, qqparse() will terminate
 * with a return value of -1
 */
#define YY_TRACE(fn) { \
   yyx.state = yystate; yyx.lookahead = qqchar; yyx.errflag =yyerrflag; \
   yyx.states = yys+1; yyx.nstates = yyps-yys; \
   yyx.values = yyv+1; yyx.nvalues = yypv-yyv; \
   yyx.types = yytypev+1; yyx.done = 0; \
   yyx.rule = yyi; yyx.npop = yyj; \
   fn(&yyx); \
   if (yyx.done) YYRETURN(-1); }

#ifndef I18N
#define m_textmsg(id, str, cls)   (str)
#else /*I18N*/
#include <m_nls.h>
#endif/*I18N*/

#ifndef YYSSIZE
# define YYSSIZE   150
#endif

#ifdef YYDYNAMIC
#define YYALLOC
char *getenv();
int atoi();
int yysinc = -1; /* stack size increment, <0 = double, 0 = none, >0 = fixed */
#endif

#ifdef YYALLOC
int yyssize = YYSSIZE;
#endif

#define YYERROR      goto yyerrlabel
#define yyerrok      yyerrflag = 0
#if YYDEBUG
#define yyclearin   { if (qqdebug) yyShowRead(-1); qqchar = -1; }
#else
#define yyclearin   qqchar = -1
#endif
#define YYACCEPT   YYRETURN(0)
#define YYABORT      YYRETURN(1)
#define YYRECOVERING()   (yyerrflag != 0)
#ifdef YYALLOC
#define YYRETURN(val)   { retval = (val); goto yyReturn; }
#else
#define YYRETURN(val)   return(val);
#endif
#if YYDEBUG
/* The if..else makes this macro behave exactly like a statement */
# define YYREAD   if (qqchar < 0) {               \
         if ((qqchar = qqlex()) < 0)   {      \
            if (qqchar == -2) YYABORT; \
            qqchar = 0;            \
         }   /* endif */         \
         if (qqdebug)               \
            yyShowRead(qqchar);         \
      }
      else
#else
# define YYREAD   if (qqchar < 0) {               \
         if ((qqchar = qqlex()) < 0) {         \
            if (qqchar == -2) YYABORT; \
            qqchar = 0;            \
         }   /* endif */         \
      } \
      else
#endif

#define YYERRCODE   50528259      /* value of `error' */
#define YYTOKEN_BASE   256
#define   YYQYYP   yyq[yyq-yyp]

/*
 * Simulate bitwise negation as if was done on a two's complement machine.
 * This makes the generated code portable to machines with different
 * representations of integers (ie. signed magnitude).
 */
#define   yyneg(s)   (-((s)+1))

YYSTYPE   yyval;            /* $ */
YYSTYPE   *yypvt;            /* $n */
YYSTYPE   qqlval;            /* qqlex() sets this */

int   qqchar,            /* current token */
   yyerrflag,         /* error flag */
   yynerrs;         /* error count */

#if YYDEBUG
int qqdebug = 0;      /* debug if this flag is set */
extern zCHAR  *yysvar[];   /* table of non-terminals (aka 'variables') */
extern yyNamedType yyTokenTypes[];   /* table of terminals & their types */
extern short   yyrmap[], yysmap[];   /* map internal rule/states */
extern int   yynstate, yynvar, yyntoken, yynrule;

extern int   yyGetType YY_ARGS((int));   /* token type */
extern zCHAR  *yyptok YY_ARGS((int));   /* printable token string */
extern int   yyExpandName YY_ARGS((int, int, zPCHAR , int));
              /* expand yyRules[] or yyStates[] */
static zPCHAR   yygetState YY_ARGS((int));

#define yyassert(condition, msg, arg) \
   if (!(condition)) { \
      printf(m_textmsg(2824, "\nyacc bug: ", "E")); \
      printf(msg, arg); \
      YYABORT; }
#else /* !YYDEBUG */
#define yyassert(condition, msg, arg)
#endif



#ifdef YACC_WINDOWS

/*
 * the following is the qqparse() function that will be
 * callable by a windows type program. It in turn will
 * load all needed resources, obtain pointers to these
 * resources, and call a statically defined function
 * win_yyparse(), which is the original qqparse() fn
 * When win_yyparse() is complete, it will return a
 * value to the new qqparse(), where it will be stored
 * away temporarily, all resources will be freed, and
 * that return value will be given back to the caller
 * qqparse(), as expected.
 */

static int win_yyparse();         /* prototype */

qqparse( )
{
   int wReturnValue;
   HANDLE hRes_table;      /* handle of resource after loading */
   short far *old_yydef;      /* the following are used for saving */
   short far *old_yyex;      /* the current pointers */
   short far *old_yyact;
   short far *old_yypact;
   short far *old_yygo;
   short far *old_yypgo;
   short far *old_yyrlen;

   /*
    * the following code will load the required
    * resources for a Windows based parser.
    */

   hRes_table = LoadResource (hInst,
      FindResource (hInst, "UD_RES_yyYACC", "yyYACCTBL"));

   /*
    * return an error code if any
    * of the resources did not load
    */

   if (hRes_table == NULL)
      return( 1 );

   /*
    * the following code will lock the resources
    * into fixed memory locations for the parser
    * (also, save the current pointer values first)
    */

   old_yydef = yydef;
   old_yyex = yyex;
   old_yyact = yyact;
   old_yypact = yypact;
   old_yygo = yygo;
   old_yypgo = yypgo;
   old_yyrlen = yyrlen;

   yydef = (short far *)LockResource (hRes_table);
   yyex = (short far *)(yydef + Sizeof_yydef);
   yyact = (short far *)(yyex + Sizeof_yyex);
   yypact = (short far *)(yyact + Sizeof_yyact);
   yygo = (short far *)(yypact + Sizeof_yypact);
   yypgo = (short far *)(yygo + Sizeof_yygo);
   yyrlen = (short far *)(yypgo + Sizeof_yypgo);

   /*
    * call the official qqparse() function
    */

   wReturnValue = win_yyparse();

   /*
    * unlock the resources
    */

   UnlockResource (hRes_table);

   /*
    * and now free the resource
    */

   FreeResource (hRes_table);

   /*
    * restore previous pointer values
    */

   yydef = old_yydef;
   yyex = old_yyex;
   yyact = old_yyact;
   yypact = old_yypact;
   yygo = old_yygo;
   yypgo = old_yypgo;
   yyrlen = old_yyrlen;

   return( wReturnValue );

} // end qqparse

static int win_yyparse()

#else /* YACC_WINDOWS */

/*
 * we are not compiling a windows resource
 * based parser, so call qqparse() the old
 * standard way.
 */

qqparse( zVIEW vSubtask )

#endif /* YACC_WINDOWS */

{
#ifdef YACC_WINDOWS
   register short far   *yyp;   /* for table lookup */
   register short far   *yyq;
#else
   register short      *yyp;   /* for table lookup */
   register short      *yyq;
#endif   /* YACC_WINDOWS */
   register short      yyi;
   register short      *yyps;      /* top of state stack */
   register short      yystate;   /* current state */
   register YYSTYPE   *yypv;      /* top of value stack */
   register int      yyj;
#if YYDEBUG
   yyTraceItems   yyx;         /* trace block */
   short   * yytp;
   int   yyruletype = 0;
#endif
#ifdef YYSTATIC
   static short   yys[YYSSIZE + 1];
   static YYSTYPE   yyv[YYSSIZE + 1];
#if YYDEBUG
   static short   yytypev[YYSSIZE+1];   /* type assignments */
#endif
#else /* ! YYSTATIC */
#ifdef YYALLOC
   YYSTYPE *yyv;
   short   *yys;
#if YYDEBUG
   short   *yytypev;
#endif
   YYSTYPE save_yylval;
   YYSTYPE save_yyval;
   YYSTYPE *save_yypvt;
   int save_yychar, save_yyerrflag, save_yynerrs;
   int retval;          /* return value holder */
#else
   short      yys[YYSSIZE + 1];
   static YYSTYPE   yyv[YYSSIZE + 1];   /* historically static */
#if YYDEBUG
   short   yytypev[YYSSIZE+1];      /* mirror type table */
#endif
#endif /* ! YYALLOC */
#endif /* ! YYSTATIC */
#ifdef YYDYNAMIC
   zPCHAR envp;
#endif


#ifdef YYDYNAMIC
   if ((envp = getenv("YYSTACKSIZE")) != (char *)0) {
      yyssize = atoi(envp);
      if (yyssize <= 0)
         yyssize = YYSSIZE;
   }
   if ((envp = getenv("YYSTACKINC")) != (char *)0)
      yysinc = atoi(envp);
#endif
#ifdef YYALLOC
   yys = (short *) malloc((yyssize + 1) * sizeof(short));
   yyv = (YYSTYPE *) malloc((yyssize + 1) * sizeof(YYSTYPE));
#if YYDEBUG
   yytypev = (short *) malloc((yyssize + 1) * sizeof(short));
#endif
   if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
      || yytypev == (short *) 0
#endif
   ) {
      qqerror(vSubtask, m_textmsg(4967, "Not enough space for parser stacks",
              "E"));
      return( 1 );
   }
   save_yylval = qqlval;
   save_yyval = yyval;
   save_yypvt = yypvt;
   save_yychar = qqchar;
   save_yyerrflag = yyerrflag;
   save_yynerrs = yynerrs;
#endif

   yynerrs = 0;
   yyerrflag = 0;
   yyclearin;
   yyps = yys;
   yypv = yyv;
   *yyps = yystate = YYS0;      /* start state */
#if YYDEBUG
   yytp = yytypev;
   yyi = yyj = 0;         /* silence compiler warnings */
#endif

yyStack:
   yyassert((unsigned)yystate < yynstate, m_textmsg(587, "state %d\n", ""), yystate);
#ifdef YYDYNAMIC
   if (++yyps > &yys[yyssize]) {
      int yynewsize;
      int yysindex = yyps - yys;
      int yyvindex = yypv - yyv;
#if YYDEBUG
      int yytindex = yytp - yytypev;
#endif
      if (yysinc == 0) {      /* no increment */
         qqerror(vSubtask, m_textmsg(4968, "Parser stack overflow", "E"));
         YYABORT;
      }
      else
      if (yysinc < 0)      /* binary-exponential */
         yynewsize = yyssize * 2;
      else            /* fixed increment */
         yynewsize = yyssize + yysinc;
      if (yynewsize < yyssize) {
         qqerror(vSubtask, m_textmsg(4967,
                 "Not enough space for parser stacks",
                 "E"));
         YYABORT;
      }
      yyssize = yynewsize;
      yys = (short *) realloc(yys, (yyssize + 1) * sizeof(short));
      yyps = yys + yysindex;
      yyv = (YYSTYPE *) realloc(yyv, (yyssize + 1) * sizeof(YYSTYPE));
      yypv = yyv + yyvindex;
#if YYDEBUG
      yytypev = (short *)realloc(yytypev,(yyssize + 1)*sizeof(short));
      yytp = yytypev + yytindex;
#endif
      if (yys == (short *)0 || yyv == (YYSTYPE *)0
#if YYDEBUG
         || yytypev == (short *) 0
#endif
      ) {
         qqerror(vSubtask, m_textmsg(4967,
                 "Not enough space for parser stacks",
                 "E"));
         YYABORT;
      }
   }
#else
   if (++yyps > &yys[YYSSIZE]) {
      qqerror(vSubtask, m_textmsg(4968, "Parser stack overflow", "E"));
      YYABORT;
   }
#endif /* !YYDYNAMIC */
   *yyps = yystate;   /* stack current state */
   *++yypv = yyval;   /* ... and value */
#if YYDEBUG
   *++yytp = yyruletype;   /* ... and type */

   if (qqdebug)
      YY_TRACE(yyShowState)
#endif

   /*
    *   Look up next action in action table.
    */
yyEncore:
#ifdef YYSYNC
   YYREAD;
#endif

#ifdef YACC_WINDOWS
   if (yystate >= Sizeof_yypact)    /* simple state */
#else /* YACC_WINDOWS */
   if (yystate >= sizeof yypact/sizeof yypact[ 0 ]) /* simple state */
#endif /* YACC_WINDOWS */
      yyi = yystate - YYDELTA;   /* reduce in any case */
   else {
      if (*(yyp = &yyact[yypact[yystate]]) >= 0) {
         /* Look for a shift on qqchar */
#ifndef YYSYNC
         YYREAD;
#endif
         yyq = yyp;
         yyi = qqchar;
         while (yyi < *yyp++)
            ;
         if (yyi == yyp[-1]) {
            yystate = yyneg(YYQYYP);
#if YYDEBUG
            if (qqdebug) {
               yyruletype = yyGetType(qqchar);
               YY_TRACE(yyShowShift)
            }
#endif
            yyval = qqlval;   /* stack what qqlex() set */
            yyclearin;      /* clear token */
            if (yyerrflag)
               yyerrflag--;   /* successful shift */
            goto yyStack;
         }
      }

      /*
        *   Fell through - take default action
        */

#ifdef YACC_WINDOWS
      if (yystate >= Sizeof_yydef)
#else /* YACC_WINDOWS */
      if (yystate >= sizeof yydef / sizeof yydef[ 0 ])
#endif /* YACC_WINDOWS */
         goto yyError;
      if ((yyi = yydef[yystate]) < 0)    { /* default == reduce? */
         /* Search exception table */
#ifdef YACC_WINDOWS
         yyassert((unsigned)yyneg(yyi) < Sizeof_yyex,
            m_textmsg(2825, "exception %d\n", "I num"), yystate);
#else /* YACC_WINDOWS */
         yyassert((unsigned)yyneg(yyi) < sizeof yyex / sizeof yyex[ 0 ],
            m_textmsg(2825, "exception %d\n", "I num"), yystate);
#endif /* YACC_WINDOWS */
         yyp = &yyex[yyneg(yyi)];
#ifndef YYSYNC
         YYREAD;
#endif
         while((yyi = *yyp) >= 0 && yyi != qqchar)
            yyp += 2;
         yyi = yyp[ 1 ];
         yyassert(yyi >= 0,
             m_textmsg(2826, "Ex table not reduce %d\n", "I num"), yyi);
      }
   }

   yyassert((unsigned)yyi < yynrule, m_textmsg(2827, "reduce %d\n", "I num"), yyi);
   yyj = yyrlen[yyi];
#if YYDEBUG
   if (qqdebug)
      YY_TRACE(yyShowReduce)
   yytp -= yyj;
#endif
   yyps -= yyj;      /* pop stacks */
   yypvt = yypv;      /* save top */
   yypv -= yyj;
   yyval = yypv[ 1 ]; /* default action $ = $1 */
#if YYDEBUG
   yyruletype = yyRules[yyrmap[yyi]].type;
#endif

   switch (yyi) {      /* perform semantic action */

case YYr3: {   /* application :  error */
 SyntaxError( vSubtask, eQNOOPERATIONSDEFINED, "" );
} break;

case YYr4: {   /* operation_definition :  operation_declaration parameter_definition_list operation_body */
 ActionQ( vSubtask, aQTURNOFFTEXTSAVE );
} break;

case YYr5: {   /* operation_definition :  operation_declaration parameter_definition_list operation_body $4 end_clause */
 ActionQ( vSubtask, aQINSERTOPERATIONENDSTMT );
} break;

case YYr6: {   /* operation_definition :  operation_declaration operation_body */
 ActionQ( vSubtask, aQTURNOFFTEXTSAVE );
} break;

case YYr7: {   /* operation_definition :  operation_declaration operation_body $6 end_clause */
 ActionQ( vSubtask, aQINSERTOPERATIONENDSTMT );
} break;

case YYr8: {   /* operation_declaration :  operation_type qOPERATION symbol */
 ActionQ( vSubtask, aQADDOPERATIONBYNAME );
} break;

case YYr9: {   /* operation_declaration :  operation_type qOPERATION error */
 SyntaxError( vSubtask, eQNOOPERATIONNAMEGIVEN,"" );
} break;

case YYr10: {   /* operation_type :  qLOCAL */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr11: {   /* operation_type :  qGLOBAL */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr12: {   /* operation_type :  qDIALOG */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr13: {   /* operation_type :  qDOMAIN */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr14: {   /* operation_type :  qOBJECT */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr16: {   /* operation_type :  qENTITY */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr18: {   /* operation_type :  qTRANSFORMATION */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr19: {   /* operation_type :  qDERIVED */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr21: {   /* operation_type :  qSHORTCUTKEY */
 ActionQ( vSubtask, aQSETOPERATIONTYPE );
} break;

case YYr22: {   /* operation_type :  error */
 SyntaxError( vSubtask, eQOPERATIONTYPENOTGIVEN,"" );
} break;

case YYr23: {   /* parameter_definition_list :  qLPAREN */
 ActionQ( vSubtask, aQBEGINPARMLIST );
} break;

case YYr24: {   /* parameter_definition_list :  qLPAREN $23 parameter_declaration_list qRPAREN */
 ActionQ( vSubtask, aQENDPARMLIST );
} break;

case YYr25: {   /* parameter_definition_list :  qLPAREN */
 ActionQ( vSubtask, aQBEGINPARMLIST );
} break;

case YYr26: {   /* parameter_definition_list :  qLPAREN $25 qRPAREN */
 ActionQ( vSubtask, aQENDPARMLIST );
} break;

case YYr29: {   /* parameter_declaration_list :  parameter_declaration_list error */
 SyntaxError( vSubtask, eQPARAMETERSNOTDELIMITED, "" );
} break;

case YYr31: {   /* parameter_declaration :  local_declaration */
 ActionQ( vSubtask, aQMARKLASTVARASPARM );
} break;

case YYr32: {   /* parameter_declaration :  pointer_indicator local_declaration */
 ActionQ( vSubtask, aQMARKLASTVARASPARMPTR );
} break;

case YYr33: {   /* parameter_declaration :  view_declaration */
 ActionQ( vSubtask, aQMARKLASTVARASPARM );
} break;

case YYr34: {   /* parameter_declaration :  pointer_indicator view_declaration */
 ActionQ( vSubtask, aQMARKLASTVARASPARMPTR );
} break;

case YYr38: {   /* operation_body :  statement_list declaration_list */
 SyntaxError( vSubtask, eQDECLMUSTPRECEEDSTMTS, "" ); yyerrok;
} break;

case YYr40: {   /* end_clause :  qEND */
 ActionQ( vSubtask, aQINSERTENDSTMT );
} break;

case YYr45: {   /* local_declaration :  data_type symbol */
 ActionQ( vSubtask, aQDECLARELOCALVARIABLE );
} break;

case YYr46: {   /* local_declaration :  data_type error */
 SyntaxError( vSubtask, eQNOVARIABLENAMEGIVEN, "" );
} break;

case YYr47: {   /* data_type :  qTINTEGER */
 ActionQ( vSubtask, aQSETLASTDATATYPEINTEGER );
} break;

case YYr48: {   /* data_type :  qTDECIMAL */
 ActionQ( vSubtask, aQSETLASTDATATYPEDECIMAL );
} break;

case YYr49: {   /* data_type :  qTSTRING dimension */
 ActionQ( vSubtask, aQSETLASTDATATYPESTRING );
} break;

case YYr50: {   /* data_type :  qTSTRING */
 SyntaxError( vSubtask, eQNODIMENSIONFORSTRING, "" ); yyerrok;
} break;

case YYr51: {   /* data_type :  qTENTITYNAME */
 ActionQ( vSubtask, aQSETLASTDATATYPEENTITYNAME );
} break;

case YYr52: {   /* data_type :  qTATTRIBUTENAME */
 ActionQ( vSubtask, aQSETLASTDATATYPEATTRIBUTENAME );
} break;

case YYr53: {   /* data_type :  qTSHORT */
 ActionQ( vSubtask, aQSETLASTDATATYPESHORT );
} break;

case YYr54: {   /* data_type :  qTCHARACTER */
 ActionQ( vSubtask, aQSETLASTDATATYPECHARACTER );
} break;

case YYr56: {   /* dimension :  qLPAREN qCONSTANT */
 ActionQ( vSubtask, aQSETSTRINGDEFINEDLENGTH );
} break;

case YYr58: {   /* dimension :  qLPAREN */
 SyntaxError( vSubtask, eQNODIMENSIONFORSTRING, "" ); yyerrok;
} break;

case YYr62: {   /* view_declaration :  view_name error */
 SyntaxError( vSubtask, eQINVALIDVIEWDECLARATION, "" );
} break;

case YYr63: {   /* view_name :  qTVIEW symbol */
 ActionQ( vSubtask, aQADDVIEWVARIABLE );
} break;

case YYr64: {   /* view_type :  qBASED qON qLOD symbol */
 ActionQ( vSubtask, aQLOADDEFASINSTANCE );
} break;

case YYr65: {   /* view_type :  qREGISTERED qAS symbol */
 ActionQ( vSubtask, aQLOADDEFFROMVOR );
} break;

case YYr78: {   /* conditional_statement :  if_phrase error */
 SyntaxError( vSubtask, eQNOENDFORIFSTMT, "" );
} break;

case YYr83: {   /* loop_statement :  loop_phrase while_clause error */
 SyntaxError( vSubtask, eQWHILECLAUSENEVERENDED, "" );
} break;

case YYr84: {   /* loop_statement :  loop_phrase while_clause statement_list error */
 SyntaxError( vSubtask, eQWHILECLAUSENEVERENDED, "" );
} break;

case YYr85: {   /* until_phrase :  qUNTIL compound_condition */
 ActionQ( vSubtask, aQINSERTUNTILSTMT );
} break;

case YYr86: {   /* until_phrase :  qUNTIL multiple_condition */
 ActionQ( vSubtask, aQINSERTUNTILSTMT );
} break;

case YYr87: {   /* until_phrase :  qUNTIL error */
 SyntaxError( vSubtask, eQUNTILNEEDSCONDITION, "" );
} break;

case YYr89: {   /* selection_statement :  case_phrase otherwise */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr91: {   /* selection_statement :  case_phrase of_list otherwise */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr93: {   /* selection_statement :  case_phrase of_list otherwise error */
 SyntaxError( vSubtask, eQCASENEVERENDED, "" ); yyerrok;
} break;

case YYr94: {   /* selection_statement :  case_phrase of_list error */
 SyntaxError( vSubtask, eQCASENEVERENDED, "" ); yyerrok;
} break;

case YYr95: {   /* selection_statement :  case_phrase otherwise error */
 SyntaxError( vSubtask, eQCASENEVERENDED, "" ); yyerrok;
} break;

case YYr96: {   /* selection_statement :  case_phrase error */
 SyntaxError( vSubtask, eQCASENEVERENDED, "" ); yyerrok;
} break;

case YYr97: {   /* selection_statement :  case_phrase otherwise of_list */
 SyntaxError( vSubtask, eQOFCANTFOLLOWOTHERWISE, "" ); yyerrok;
} break;

case YYr99: {   /* selection_statement :  case_phrase */
 ActionQ( vSubtask, aQADDLONEDEFAULT );
} break;

case YYr111: {   /* assignment_statement :  operation_call */
 ActionQ( vSubtask, aQINSERTOPERATIONCALL );
} break;

case YYr112: {   /* assignment_statement :  left_element qEQUAL */
 ActionQ( vSubtask, aQADDASSIGNMENTOPERATOR );
} break;

case YYr113: {   /* assignment_statement :  left_element qEQUAL $112 r_expression */
 ActionQ( vSubtask, aQINSERTEXPRESSIONSTMT );
} break;

case YYr114: {   /* exit_statement :  return_value */
 ActionQ( vSubtask, aQADDRETURNSTATEMENT );
} break;

case YYr115: {   /* if_phrase :  qIF compound_condition */
 ActionQ( vSubtask, aQINSERTIFSTMT );
} break;

case YYr116: {   /* if_phrase :  qIF multiple_condition */
 ActionQ( vSubtask, aQINSERTIFSTMT );
} break;

case YYr117: {   /* if_phrase :  qIF compound_condition */
 ActionQ( vSubtask, aQINSERTIFSTMT );
} break;

case YYr119: {   /* if_phrase :  qIF multiple_condition */
 ActionQ( vSubtask, aQINSERTIFSTMT );
} break;

case YYr121: {   /* if_phrase :  qIF error */
 SyntaxError( vSubtask, eQNOCONDITIONAFTERIF, "" );
} break;

case YYr123: {   /* else_phrase :  qELSE */
 ActionQ( vSubtask, aQINSERTELSESTMT );
} break;

case YYr124: {   /* else_phrase :  qELSE */
 ActionQ( vSubtask, aQINSERTELSESTMT );
} break;

case YYr126: {   /* loop_phrase :  qLOOP */
 ActionQ( vSubtask, aQINSERTLOOPSTMT );
} break;

case YYr137: {   /* while_clause :  while_keyword compound_condition */
 ActionQ( vSubtask, aQINSERTWHILESTMT );
} break;

case YYr138: {   /* while_clause :  while_keyword multiple_condition */
 ActionQ( vSubtask, aQINSERTWHILESTMT );
} break;

case YYr139: {   /* while_clause :  while_keyword error */
 SyntaxError( vSubtask, eQWHILENEEDSCONDITION, "" );
} break;

case YYr140: {   /* case_phrase :  qCASE r_expression */
 ActionQ( vSubtask, aQINSERTCASESTMT );
} break;

case YYr141: {   /* of_list :  of_list of_clause statement_list */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr142: {   /* of_list :  of_list of_clause */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr143: {   /* of_list :  of_clause statement_list */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr144: {   /* of_list :  of_clause */
 ActionQ( vSubtask, aQEXTRAENDNEEDED );
} break;

case YYr145: {   /* otherwise :  qOTHERWISE qCOLON */
 ActionQ( vSubtask, aQINSERTOTHERWISESTMT );
} break;

case YYr147: {   /* otherwise :  qOTHERWISE qCOLON */
 ActionQ( vSubtask, aQINSERTOTHERWISESTMT );
} break;

case YYr148: {   /* set_action :  qSET qCURSOR fnpl_phrase cursor_target */
 ActionQ( vSubtask, aQSETCURSORNOWHERE );
} break;

case YYr149: {   /* set_action :  qSET qCURSOR fnpl_phrase cursor_target where_clause */
 ActionQ( vSubtask, aQSETCURSORWITHWHERE );
} break;

case YYr150: {   /* commit_action :  qCOMMIT symbol */
 ActionQ( vSubtask, aQADDCOMMIT );
} break;

case YYr151: {   /* get_action :  qGET qTVIEW view_var task_level qUSING symbol */
 ActionQ( vSubtask, aQADDGETVIEWATLEVELFROMLEVEL );
} break;

case YYr152: {   /* get_action :  qGET qTVIEW view_var task_level */
 ActionQ( vSubtask, aQADDGETVIEWATLEVELU );
} break;

case YYr153: {   /* get_action :  qGET qTVIEW view_var */
 ActionQ( vSubtask, aQADDGETVIEW );
} break;

case YYr154: {   /* name_action :  qNAME qTVIEW name_var task_level qUSING symbol */
 ActionQ( vSubtask, aQADDNAMEVIEWWITHVIEW );
} break;

case YYr155: {   /* name_action :  qNAME qTVIEW name_var task_level */
 ActionQ( vSubtask, aQADDNAMEVIEW );
} break;

case YYr156: {   /* name_action :  qNAME qTVIEW name_var */
 ActionQ( vSubtask, aQADDNAMEVIEW );
} break;

case YYr157: {   /* include_action :  qINCLUDE qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETINCLUDETARGET );
} break;

case YYr159: {   /* source_eq :  qFROM qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETINCLUDESOURCE );
} break;

case YYr160: {   /* position :  qBEFORE */
 ActionQ( vSubtask, aQADDINCLUDEBEFORE );
} break;

case YYr161: {   /* position :  qAFTER */
 ActionQ( vSubtask, aQADDINCLUDE );
} break;

case YYr162: {   /* position :  */
 ActionQ( vSubtask, aQADDINCLUDE );
} break;

case YYr163: {   /* exclude_action :  qEXCLUDE qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETINCLUDETARGET );
} break;

case YYr165: {   /* exclude_position :  qBEFORE */
 ActionQ( vSubtask, aQADDEXCLUDEBEFORE );
} break;

case YYr166: {   /* exclude_position :  qNONE */
 ActionQ( vSubtask, aQADDEXCLUDENONE );
} break;

case YYr167: {   /* exclude_position :  qAFTER */
 ActionQ( vSubtask, aQADDEXCLUDE );
} break;

case YYr168: {   /* exclude_position :  */
 ActionQ( vSubtask, aQADDEXCLUDE );
} break;

case YYr169: {   /* name_var :  symbol */
 ActionQ( vSubtask, aQSAVENAMEVIEWNAME );
} break;

case YYr170: {   /* name_var :  symbol $169 qCONSTANT */
 ActionQ( vSubtask, aQSAVENAMEVIEWCONSTANT );
} break;

case YYr171: {   /* name_var :  symbol */
 ActionQ( vSubtask, aQSAVENAMEVIEWNAME );
} break;

case YYr172: {   /* name_var :  symbol $171 symbol */
 ActionQ( vSubtask, aQSAVENAMEVIEWVARIABLE );
} break;

case YYr173: {   /* view_var :  symbol */
 ActionQ( vSubtask, aQSAVEGETVIEWID );
} break;

case YYr175: {   /* view_qual :  qCONSTANT */
 ActionQ( vSubtask, aQSAVEGETVIEWCONSTANT );
} break;

case YYr176: {   /* view_qual :  symbol */
 ActionQ( vSubtask, aQSAVEGETVIEWNAME );
} break;

case YYr177: {   /* task_level :  qAT qLEVEL qSUBTASK */
 ActionQ( vSubtask, aQADDGETVIEWATLEVEL );
} break;

case YYr178: {   /* task_level :  qAT qLEVEL qTASK */
 ActionQ( vSubtask, aQADDGETVIEWATLEVEL );
} break;

case YYr179: {   /* task_level :  qAT qLEVEL qAPPLICATION */
 ActionQ( vSubtask, aQADDGETVIEWATLEVEL );
} break;

case YYr180: {   /* task_level :  qAT qLEVEL qSYSTEM */
 ActionQ( vSubtask, aQADDGETVIEWATLEVEL );
} break;

case YYr181: {   /* task_level :  qAT qLEVEL qANY */
 ActionQ( vSubtask, aQADDGETVIEWATLEVEL );
} break;

case YYr182: {   /* for_action :  for_entry statement_list */
 ActionQ( vSubtask, aQSETNEXT );
} break;

case YYr184: {   /* for_action :  for_entry */
 ActionQ( vSubtask, aQSETNEXT );
} break;

case YYr186: {   /* for_entry :  qualified_for cursor_target where_clause */
 ActionQ( vSubtask, aQADDFORWITHWHERE );
} break;

case YYr187: {   /* for_entry :  qualified_for cursor_target */
 ActionQ( vSubtask, aQADDFORNOWHERE );
} break;

case YYr188: {   /* qualified_for :  qFOR */
 ActionQ( vSubtask, aQSETEACHFLAG );
} break;

case YYr190: {   /* qualified_for :  qFOR */
 ActionQ( vSubtask, aQSETVARIABLEFLAG );
} break;

case YYr192: {   /* qualified_for :  qFOR */
 ActionQ( vSubtask, aQSETCONSTANTFLAG );
} break;

case YYr194: {   /* qualified_for :  qFOR */
 ActionQ( vSubtask, aQSETNOEACHFLAG );
} break;

case YYr195: {   /* cursor_target :  qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETCURSORLASTCONTROL );
} break;

case YYr197: {   /* cursor_target :  qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETCURSORLASTCONTROL );
} break;

case YYr198: {   /* scope :  qWITHIN qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETSCOPE );
} break;

case YYr199: {   /* scope :  qWITHIN qOBJECT */
 ActionQ( vSubtask, aQSETOBJECTSCOPE );
} break;

case YYr200: {   /* activate_action :  activate_phrase where_clause */
 ActionQ( vSubtask, aQADDACTIVATEWHERE );
} break;

case YYr201: {   /* activate_action :  activate_phrase where_clause $200 restricting_phrase */
 ActionQ( vSubtask, aQADDACTIVATESTMT );
} break;

case YYr202: {   /* activate_action :  activate_phrase where_clause */
 ActionQ( vSubtask, aQADDACTIVATEWHERE );
} break;

case YYr203: {   /* activate_action :  activate_phrase where_clause $202 */
 ActionQ( vSubtask, aQADDACTIVATESTMT );
} break;

case YYr204: {   /* activate_action :  activate_phrase restricting_phrase */
 ActionQ( vSubtask, aQADDACTIVATESTMT );
} break;

case YYr205: {   /* activate_action :  activate_phrase qEMPTY */
 ActionQ( vSubtask, aQADDACTIVATESTMTEMPTY );
} break;

case YYr206: {   /* activate_action :  activate_phrase */
 ActionQ( vSubtask, aQADDACTIVATESTMTNOWHERE );
} break;

case YYr207: {   /* activate_phrase :  qACTIVATE symbol */
 ActionQ( vSubtask, aQVERIFYACTIVATEOBJECT );
} break;

case YYr209: {   /* activate_phrase :  qACTIVATE symbol */
 ActionQ( vSubtask, aQVERIFYACTIVATEOBJECT );
} break;

case YYr210: {   /* activate_phrase :  qACTIVATE symbol $209 */
 ActionQ( vSubtask, aQSAVEACTIVATESINGLE );
} break;

case YYr211: {   /* zdefine :  qSINGLE */
 ActionQ( vSubtask, aQSAVEACTIVATESINGLE );
} break;

case YYr212: {   /* zdefine :  qMULTIPLE */
 ActionQ( vSubtask, aQSAVEACTIVATEMULTIPLE );
} break;

case YYr213: {   /* zdefine :  qROOTONLY */
 ActionQ( vSubtask, aQSAVEACTIVATEROOTONLY );
} break;

case YYr214: {   /* zdefine :  qROOTONLYMULTIPLE */
 ActionQ( vSubtask, aQSAVEACTIVATEROOTONLYMULTIPLE );
} break;

case YYr215: {   /* zdefine :  qCONTINUE */
 ActionQ( vSubtask, aQSAVEACTIVATECONTINUE );
} break;

case YYr216: {   /* zdefine :  qROOTONLYCONTINUE */
 ActionQ( vSubtask, aQSAVEACTIVATEROOTONLYCONTINUE );
} break;

case YYr217: {   /* zdefine :  qSINGLEFORUPDATE */
 ActionQ( vSubtask, aQSAVEACTIVATESINGLEFORUPDATE );
} break;

case YYr220: {   /* restricting_clause :  qRESTRICTING qENTITYQUALIFIER */
 ActionQ( vSubtask, aQSETRESTRICTION );
} break;

case YYr221: {   /* restricting_clause :  qRESTRICTING qENTITYQUALIFIER $220 qTO attribute_where_phrase */
 ActionQ( vSubtask, aQADDRESTRICTACTIVATEWHERE );
} break;

case YYr222: {   /* create_action :  qCREATE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDCREATESTMTAFTER );
} break;

case YYr224: {   /* create_action :  qCREATE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDCREATESTMTBEFORE );
} break;

case YYr226: {   /* create_action :  qCREATE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDCREATESTMTFIRST );
} break;

case YYr228: {   /* create_action :  qCREATE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDCREATESTMTLAST );
} break;

case YYr230: {   /* create_action :  qCREATE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDCREATESTMTAFTER );
} break;

case YYr231: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTFIRST );
} break;

case YYr233: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTLAST );
} break;

case YYr235: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTPREVIOUS );
} break;

case YYr237: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTNEXT );
} break;

case YYr239: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTNONE );
} break;

case YYr241: {   /* delete_action :  qDELETE qENTITY qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDDELETESTMTNEXT );
} break;

case YYr242: {   /* operation_call :  symbol */
 ActionQ( vSubtask, aQADDOPERATIONNAMETOEXPR );
} break;

case YYr244: {   /* left_element :  symbol */
 ActionQ( vSubtask, aQADDVARIABLEOFFSETASTARGET );
} break;

case YYr246: {   /* left_element :  symbol */
 ActionQ( vSubtask, aQADDVARIABLEASTARGET );
} break;

case YYr247: {   /* left_element :  qATTRIBUTEQUALIFIER */
 ActionQ( vSubtask, aQADDOCEATOEXPRASTARGET );
} break;

case YYr248: {   /* r_expression :  r_expression qADDITION */
 ActionQ( vSubtask, aQADDOPERATORTOEXPR );
} break;

case YYr250: {   /* r_expression :  r_expression qMINUS */
 ActionQ( vSubtask, aQADDOPERATORTOEXPR );
} break;

case YYr252: {   /* r_expression :  r_expression qMULTIPLICATION */
 ActionQ( vSubtask, aQADDOPERATORTOEXPR );
} break;

case YYr254: {   /* r_expression :  r_expression qDIVISION */
 ActionQ( vSubtask, aQADDOPERATORTOEXPR );
} break;

case YYr257: {   /* r_expression :  qMINUS */
 ActionQ( vSubtask, aQADDUNARYOPERATOR );
} break;

case YYr262: {   /* condition :  r_expression qCONDOPERATOR */
 ActionQ( vSubtask, aQADDCONDOPERATORTOEXPR );
} break;

case YYr263: {   /* condition :  r_expression qCONDOPERATOR $262 r_expression */
 ActionQ( vSubtask, aQCHECKSTOREDOCEA );
} break;

case YYr264: {   /* condition :  r_expression qEQUAL */
 ActionQ( vSubtask, aQADDCONDEQUALTOEXPR );
} break;

case YYr265: {   /* condition :  r_expression qEQUAL $264 r_expression */
 ActionQ( vSubtask, aQCHECKSTOREDOCEA );
} break;

case YYr266: {   /* condition :  exist_condition */
 ActionQ( vSubtask, aQADDCHECKEXIST );
} break;

case YYr267: {   /* condition :  r_expression qCONDOPERATOR error */
 SyntaxError( vSubtask, eQINVALIDCONDEXPRESSION, "" );
} break;

case YYr268: {   /* exist_condition :  qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDWHERELEFTEQCOND );
} break;

case YYr269: {   /* exist_condition :  qENTITYQUALIFIER $268 exist_phrase */
 ActionQ( vSubtask, aQINCREMENTWHEREINDEX );
} break;

case YYr270: {   /* conditional_join :  qJOIN */
 ActionQ( vSubtask, aQADDJOINTOEXPR );
} break;

case YYr271: {   /* lparen :  qLPAREN */
 ActionQ( vSubtask, aQADDLPARENTOEXPR );
} break;

case YYr272: {   /* rparen :  qRPAREN */
 ActionQ( vSubtask, aQADDRPARENTOEXPR );
} break;

case YYr273: {   /* negation_op :  qNOT */
 ActionQ( vSubtask, aQADDNOTOPERATORTOEXPR );
} break;

case YYr274: {   /* while_keyword :  qWHILE */
 ActionQ( vSubtask, aQDELETELOOPSTMT );
} break;

case YYr275: {   /* of_clause :  qOF aconstant */
 ActionQ( vSubtask, aQADDCONSTANTTOEXPR );
} break;

case YYr276: {   /* of_clause :  qOF aconstant $275 qCOLON */
 ActionQ( vSubtask, aQINSERTOFSTMT );
} break;

case YYr277: {   /* of_clause :  qOF qDEFINE */
 ActionQ( vSubtask, aQADDDEFINETOEXPR );
} break;

case YYr278: {   /* of_clause :  qOF qDEFINE $277 qCOLON */
 ActionQ( vSubtask, aQINSERTOFSTMT );
} break;

case YYr279: {   /* fnpl_phrase :  qFIRST */
 ActionQ( vSubtask, aQSETFIRSTCURSOR  );
} break;

case YYr280: {   /* fnpl_phrase :  qNEXT */
 ActionQ( vSubtask, aQSETNEXTCURSOR  );
} break;

case YYr281: {   /* fnpl_phrase :  qPREVIOUS */
 ActionQ( vSubtask, aQSETPREVIOUSCURSOR  );
} break;

case YYr282: {   /* fnpl_phrase :  qLAST */
 ActionQ( vSubtask, aQSETLASTCURSOR  );
} break;

case YYr283: {   /* where_clause :  qWHERE */
 ActionQ( vSubtask, aQSETUPWHERE );
} break;

case YYr285: {   /* attribute_where_phrase :  attribute_where_phrase qJOIN */
 ActionQ( vSubtask, aQADDWHEREJOIN );
} break;

case YYr287: {   /* attribute_where_phrase :  qLPAREN */
 ActionQ( vSubtask, aQSETWHERELEFTPAREN );
} break;

case YYr288: {   /* attribute_where_phrase :  qLPAREN $287 attribute_where_phrase qRPAREN */
 ActionQ( vSubtask, aQSETWHERERIGHTPAREN );
} break;

case YYr290: {   /* attribute_op_phrase :  qATTRIBUTEQUALIFIER */
 ActionQ( vSubtask, aQADDWHERELEFTAQ );
} break;

case YYr291: {   /* attribute_op_phrase :  qATTRIBUTEQUALIFIER $290 where_op where_value */
 ActionQ( vSubtask, aQINCREMENTWHEREINDEX );
} break;

case YYr292: {   /* attribute_op_phrase :  qATTRIBUTEQUALIFIER */
 ActionQ( vSubtask, aQADDWHERELEFTAQ );
} break;

case YYr293: {   /* attribute_op_phrase :  qATTRIBUTEQUALIFIER $292 is_null_phrase */
 ActionQ( vSubtask, aQINCREMENTWHEREINDEX );
} break;

case YYr294: {   /* attribute_op_phrase :  qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDWHERELEFTEQ );
} break;

case YYr295: {   /* attribute_op_phrase :  qENTITYQUALIFIER $294 exist_phrase */
 ActionQ( vSubtask, aQINCREMENTWHEREINDEX );
} break;

case YYr296: {   /* attribute_op_phrase :  qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDWHERELEFTEQ );
} break;

case YYr297: {   /* attribute_op_phrase :  qENTITYQUALIFIER $296 is_keyword qENTITYQUALIFIER */
 ActionQ( vSubtask, aQADDWHERERIGHTEQ );
} break;

case YYr298: {   /* where_op :  qCONDOPERATOR */
 ActionQ( vSubtask, aQADDWHERECONDOPER );
} break;

case YYr299: {   /* where_op :  qEQUAL */
 ActionQ( vSubtask, aQADDWHERECONDEQUAL );
} break;

case YYr300: {   /* where_op :  qLIKE */
 ActionQ( vSubtask, aQADDWHERELIKE );
} break;

case YYr301: {   /* exist_phrase :  qEXISTS */
 ActionQ( vSubtask, aQADDWHEREEXISTS );
} break;

case YYr302: {   /* exist_phrase :  qDOES qNOT qEXIST */
 ActionQ( vSubtask, aQADDWHERENOTEXIST );
} break;

case YYr303: {   /* is_null_phrase :  is_keyword qNOT */
 ActionQ( vSubtask, aQCONFIRMNOT );
} break;

case YYr304: {   /* is_null_phrase :  is_keyword qNOT $303 qNULL */
 ActionQ( vSubtask, aQADDWHEREISNOTNULL );
} break;

case YYr305: {   /* is_null_phrase :  is_keyword qNULL */
 ActionQ( vSubtask, aQADDWHEREISNULL );
} break;

case YYr306: {   /* is_keyword :  qIS */
 ActionQ( vSubtask, aQADDWHEREIS );
} break;

case YYr307: {   /* where_value :  symbol */
 ActionQ( vSubtask, aQADDWHEREVARIABLE );
} break;

case YYr308: {   /* where_value :  aconstant */
 ActionQ( vSubtask, aQADDWHERECONSTANT );
} break;

case YYr309: {   /* where_value :  qATTRIBUTEQUALIFIER */
 ActionQ( vSubtask, aQADDWHERERIGHTAQ );
} break;

case YYr310: {   /* aconstant :  qMINUS */
 ActionQ( vSubtask, aQADDUNARYOPERATOR );
} break;

case YYr313: {   /* parameter_value_list :  openoper */
 ActionQ( vSubtask, aQADDOPENOPERTOEXPR );
} break;

case YYr315: {   /* parameter_value_list :  openoper */
 ActionQ( vSubtask, aQADDOPENOPERTOEXPR );
} break;

case YYr318: {   /* closeoper :  qRPAREN */
 ActionQ( vSubtask, aQADDCLOSEOPERTOEXPR );
} break;

case YYr321: {   /* value :  symbol */
 ActionQ( vSubtask, aQADDVARIABLETOEXPR );
} break;

case YYr322: {   /* value :  symbol */
 ActionQ( vSubtask, aQADDVARIABLEOFFSETTOEXPR );
} break;

case YYr324: {   /* value :  qDEFINE */
 ActionQ( vSubtask, aQADDDEFINETOEXPR );
} break;

case YYr325: {   /* value :  qATTRIBUTEQUALIFIER */
 ActionQ( vSubtask, aQADDAQTOEXPR );
} break;

case YYr326: {   /* value :  qCONSTANT */
 ActionQ( vSubtask, aQADDCONSTANTTOEXPR );
} break;

case YYr327: {   /* value :  error */
 SyntaxError( vSubtask, eQBADTOKENWHEREVALUEEXPECTED, "" );
} break;

case YYr329: {   /* value_list :  r_expression qCOMMA */
 ActionQ( vSubtask, aQADDCOMMATOEXPR );
} break;

case YYr331: {   /* offset :  qLBRACE */
 ActionQ( vSubtask, aQADDLBRACETOEXPR );
} break;

case YYr332: {   /* offset :  qLBRACE $331 index_and_length qRBRACE */
 ActionQ( vSubtask, aQADDRBRACETOEXPR );
} break;

case YYr333: {   /* index_and_length :  r_expression qCOLON */
 ActionQ( vSubtask, aQADDCOLONTOEXPR );
} break;

case YYr336: {   /* symbol :  qVARIABLE */
 ActionQ( vSubtask, aQSETVARIABLETEXT );
} break;
   case YYrACCEPT:
      YYACCEPT;
   case YYrERROR:
      goto yyError;
   }

   /*
    *   Look up next state in goto table.
    */

   yyp = &yygo[yypgo[yyi]];
   yyq = yyp++;
   yyi = *yyps;
   while (yyi < *yyp++)
      ;

   yystate = yyneg(yyi == *--yyp? YYQYYP: *yyq);
#if YYDEBUG
   if (qqdebug)
      YY_TRACE(yyShowGoto)
#endif
   goto yyStack;

yyerrlabel:   ;      /* come here from YYERROR   */
/*
#pragma used yyerrlabel
 */
   yyerrflag = 1;
   if (yyi == YYrERROR) {
      yyps--;
      yypv--;
#if YYDEBUG
      yytp--;
#endif
   }

yyError:
   switch (yyerrflag) {

   case 0:      /* new error */
      yynerrs++;
      yyi = qqchar;
      qqerror(vSubtask, m_textmsg(4969, "Syntax error", "E"));
      if (yyi != qqchar) {
         /* user has changed the current token */
         /* try again */
         yyerrflag++;   /* avoid loops */
         goto yyEncore;
      }

   case 1:      /* partially recovered */
   case 2:
      yyerrflag = 3;   /* need 3 valid shifts to recover */

      /*
       *   Pop states, looking for a
       *   shift on `error'.
       */

      for ( ; yyps > yys; yyps--, yypv--
#if YYDEBUG
, yytp--
#endif
      ) {
#ifdef YACC_WINDOWS
         if (*yyps >= Sizeof_yypact)
#else /* YACC_WINDOWS */
         if (*yyps >= sizeof yypact / sizeof yypact[ 0 ])
#endif /* YACC_WINDOWS */
            continue;
         yyp = &yyact[yypact[*yyps]];
         yyq = yyp;
         do {
            if (YYERRCODE == *yyp) {
               yyp++;
               yystate = yyneg(YYQYYP);
               goto yyStack;
            }
         } while (*yyp++ > YYTOKEN_BASE);

         /* no shift in this state */
#if YYDEBUG
         if (qqdebug && yyps > yys+1)
            YY_TRACE(yyShowErrRecovery)
#endif
         /* pop stacks; try again */
      }
      /* no shift on error - abort */
      break;

   case 3:
      /*
       *   Erroneous token after
       *   an error - discard it.
       */

      if (qqchar == 0)  /* but not EOF */
         break;
#if YYDEBUG
      if (qqdebug)
         YY_TRACE(yyShowErrDiscard)
#endif
      yyclearin;
      goto yyEncore;   /* try again in same state */
   }
   YYABORT;

#ifdef YYALLOC
yyReturn:
   qqlval = save_yylval;
   yyval = save_yyval;
   yypvt = save_yypvt;
   qqchar = save_yychar;
   yyerrflag = save_yyerrflag;
   yynerrs = save_yynerrs;
   free((char *)yys);
   free((char *)yyv);
#if YYDEBUG
   free((char *)yytypev);
#endif
   return(retval);
#endif
}


#if YYDEBUG
/*
 * Return type of token
 */
int
yyGetType(tok)
int tok;
{
   yyNamedType * tp;
   for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
      if (tp->token == tok)
         return( tp->type );

   return( 0 );
}
/*
 * Print a token legibly.
 */
char *
yyptok(tok)
int tok;
{
   yyNamedType * tp;
   for (tp = &yyTokenTypes[yyntoken-1]; tp > yyTokenTypes; tp--)
      if (tp->token == tok)
         return( tp->name );

   return "";
}

/*
 * Read state 'num' from YYStatesFile
 */
#ifdef YYTRACE

static zPCHAR
yygetState(num)
int num;
{
   int   size;
   static FILE *yyStatesFile = (FILE *) 0;
   static zCHAR yyReadBuf[YYMAX_READ+1];

   if ( yyStatesFile == (FILE *) 0 &&
        (yyStatesFile = fopen(YYStatesFile, "r")) == (FILE *) 0 )
   {
      return "yyExpandName: cannot open states file";
   }

   if ( num < yynstate - 1 )
      size = (int)(yyStates[ num + 1 ] - yyStates[ num ] );
   else
   {
      /* length of last item is length of file - ptr(last-1) */
      if ( fseek( yyStatesFile, 0L, 2 ) < 0 )
         goto cannot_seek;

      size = (int) (ftell(yyStatesFile) - yyStates[num]);
   }

   if ( size < 0 || size > YYMAX_READ )
      return "yyExpandName: bad read size";

   if ( fseek( yyStatesFile, yyStates[ num ], 0 ) < 0 )
   {
cannot_seek:
      return "yyExpandName: cannot seek in states file";
   }

   (void) fread(yyReadBuf, 1, size, yyStatesFile);
   yyReadBuf[size] = 0;
   return yyReadBuf;
}
#endif /* YYTRACE */
/*
 * Expand encoded string into printable representation
 * Used to decode yyStates and yyRules strings.
 * If the expansion of 's' fits in 'buf', return( 1 ) otherwise, 0.
 */
int
yyExpandName(num, isrule, buf, len)
int num, isrule;
char * buf;
int len;
{
   int   i, n, cnt, type;
   zCHAR  * endp, * cp;
   zCHAR  *s;

   if (isrule)
      s = yyRules[num].name;
   else
#ifdef YYTRACE
      s = yygetState(num);
#else
      s = "*no states*";
#endif

   for (endp = buf + len - 8; *s; s++) {
      if (buf >= endp) {      /* too large: return( 0 ) */
      full:   (void) strcpy(buf, " ...\n");
         return( 0 );
      }
      else
      if (*s == '%') {      /* nonterminal */
         type = 0;
         cnt = yynvar;
         goto getN;
      }
      else
      if (*s == '&') {      /* terminal */
         type = 1;
         cnt = yyntoken;
      getN:
         if (cnt < 100)
            i = 2;
         else
         if (cnt < 1000)
            i = 3;
         else
            i = 4;
         for (n = 0; i-- > 0; )
            n = (n * 10) + *++s - '0';
         if (type == 0) {
            if (n >= yynvar)
               goto too_big;
            cp = yysvar[n];
         }
         else
         if (n >= yyntoken) {
             too_big:
            cp = "<range err>";
         }
         else
            cp = yyTokenTypes[n].name;

         if ((i = strlen(cp)) + buf > endp)
            goto full;
         (void) strcpy(buf, cp);
         buf += i;
      }
      else
         *buf++ = *s;
   }

   *buf = 0;
   return( 1 );
}
#ifndef YYTRACE
/*
 * Show current state of qqparse
 */
void
yyShowState(tp)
yyTraceItems * tp;
{
   short * p;
   YYSTYPE * q;

   printf(
       m_textmsg(2828, "state %d (%d), zCHAR %s (%d)\n", "I num1 num2 zCHAR num3"),
         yysmap[tp->state], tp->state,
         yyptok(tp->lookahead), tp->lookahead);
}
/*
 * show results of reduction
 */
void
yyShowReduce(tp)
yyTraceItems * tp;
{
   printf("reduce %d (%d), pops %d (%d)\n",
      yyrmap[tp->rule], tp->rule,
      tp->states[tp->nstates - tp->npop],
      yysmap[tp->states[tp->nstates - tp->npop]]);
}
void
yyShowRead(val)
int val;
{
   printf(m_textmsg(2829, "read %s (%d)\n", "I token num"), yyptok(val), val);
}
void
yyShowGoto(tp)
yyTraceItems * tp;
{
   printf(m_textmsg(2830, "goto %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowShift(tp)
yyTraceItems * tp;
{
   printf(m_textmsg(2831, "shift %d (%d)\n", "I num1 num2"), yysmap[tp->state], tp->state);
}
void
yyShowErrRecovery(tp)
yyTraceItems * tp;
{
   short   * top = tp->states + tp->nstates - 1;

   printf(
   m_textmsg(2832, "Error recovery pops state %d (%d), uncovers %d (%d)\n", "I num1 num2 num3 num4"),
      yysmap[*top], *top, yysmap[*(top-1)], *(top-1));
}
void
yyShowErrDiscard(tp)
yyTraceItems * tp;
{
   printf(m_textmsg(2833, "Error recovery discards %s (%d), ", "I token num"),
      yyptok(tp->lookahead), tp->lookahead);
}
#endif   /* ! YYTRACE */
#endif   /* YYDEBUG */
