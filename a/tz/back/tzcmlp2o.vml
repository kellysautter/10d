/*
CHANGE LOG
2000.10.20    SR   Z2000  Size of path variables
   Modified size of FileName, XDM_Filename and XOD_FileName in function
   GenerateCallHeader, sz and sz2 in function GenerateTransShell
   because size of attributes ExecDir, MetaSrcDir and PgmSrcDir has
   been changed to 254 in datamodel.
*/


/**************************************************************
   Generate interface headers that will be linked with all Domain,
   Object Constraint, Entity Constraint and Derived Attribute
   operation code for environments for which dynamically calling
   routines is difficult.  The main routine opens the output file
   for the generated code and then calls sub operations for
   generating the code.
**************************************************************/
TRANSFORMATION OPERATION
GenerateCallHeader( VIEW vLPLR BASED ON LOD TZCMLPLO, VIEW vSubtask )

   VIEW vXDM BASED ON LOD TZDMXGPO
   VIEW vXOD BASED ON LOD TZZOXODO
   VIEW vWk  BASED ON LOD TZCMHDWO

   STRING ( 513 ) FileName       // size according to zMAX_FILESPEC_LTH+1
   INTEGER        f
   STRING ( 513 ) XDM_FileName   // size according to zMAX_FILESPEC_LTH+1
   STRING ( 254 ) Sl
   STRING ( 2 )   Quote
   INTEGER        nFirstTime
   STRING ( 513 ) XOD_FileName   // size according to zMAX_FILESPEC_LTH+1
   SHORT  nRC

   Quote = "\"
   FileName = vLPLR.LPLR.PgmSrcDir
   FileName = FileName + "\kzoehdaa.c"
   f = SysOpenFile( vLPLR, FileName, COREFILE_WRITE )

/**************************************************************
   Generate a Domain header that will be linked with all Domain
   operation code for environments for which dynamically calling
   routines is difficult.  The header has a case statement for every
   Domain with an operation, which has a call to the corresponding
   Domain operation.  OE operations use their normal SysDomainCall
   interface but end up calling the generated SysDomainCall routine
   instead of the one normally in kzoesyaa.c.  The SysGetDomainProc
   routine returns an integer for the case statement instead of the
   Domain routine address.
   The code is generated by navigating through all the Domain entities
   in the TZDMXGPO object instance named ZEIDON.XDM.
**************************************************************/

   XDM_FileName = vLPLR.LPLR.ExecDir
   XDM_FileName = XDM_FileName + "\zeidon.xdm"
   ActivateOI_FromFile ( vXDM, "TZDMXGPO", vLPLR, XDM_FileName, zSINGLE )
   NAME VIEW vXDM "vXDM"

   Sl = "#include " + Quote + "kzoephdr.h" + Quote
   wl( f, Sl )
   Sl = "#include " + Quote + "ZeidonOp.h" + Quote
   wl( f, Sl )
   wl( f, "// " )
   wl( f, "// MODULE NAME:  KZOEHDAA  -  Object services Library Resolution " )
   wl( f, "// DESCRIPTION:  This is the source file which returns function pointers " )
   wl( f, "//               for Domain, Object and Transformation operations. " )
   wl( f, " " )

   ACTIVATE vWk EMPTY
   CREATE ENTITY vWk.Root

   FOR EACH vXDM.Domain
      SET CURSOR FIRST vWk.Executable
          WHERE vWk.Executable.Name = vXDM.Domain.DLL_Name

      IF RESULT < zCURSOR_SET
         CREATE ENTITY vWk.Executable
         vWk.Executable.Name = vXDM.Domain.DLL_Name
      END

      IF vXDM.Domain.OperName != ""
         CREATE ENTITY vWk.Object
         vWk.Object.Name = vXDM.Domain.Name
         vWk.Object.OperName = vXDM.Domain.OperName
         vWk.Object.Type = "D"
      END
   END

   DropObjectInstance( vXDM )

   // Build work object for Object Constraints, Entity Constraints and Derived Attributes.

   SET CURSOR FIRST vLPLR.W_MetaType WHERE vLPLR.W_MetaType.Type = 2007
   FOR EACH vLPLR.W_MetaDef

      XOD_FileName = vLPLR.LPLR.ExecDir
      XOD_FileName = XOD_FileName + "\" + vLPLR.W_MetaDef.Name + ".XOD"
      nRC = ActivateOI_FromFile( vXOD, "TZZOXODO", vLPLR, XOD_FileName, zSINGLE )
      IF nRC >= 0
         SET CURSOR FIRST vWk.Executable
             WHERE vWk.Executable.Name = vXOD.OBJECT.OPER_LIBNM

         IF RESULT < zCURSOR_SET
            CREATE ENTITY vWk.Executable
            vWk.Executable.Name = vXOD.OBJECT.OPER_LIBNM
         END

         // Create the Object Entity Constraint work entity if necessary.
         IF vXOD.OBJECT.OCEOPER != ""
            CREATE ENTITY vWk.Object
            vWk.Object.Name = vXOD.OBJECT.NAME
            vWk.Object.OperName = vXOD.OBJECT.OCEOPER
            vWk.Object.Type = "O"
         END

         AnalyzeEntity( vXOD, vWk, vXOD.OBJECT.NAME )
      END

      DropObjectInstance( vXOD )

   END

   FOR EACH vWk.Executable
      nFirstTime = 1

      FOR EACH vWk.Object

         IF nFirstTime = 1
            nFirstTime = 0
            wl( f, "zPVOID " )
            Sl = vWk.Executable.Name + "( zPCHAR pszFunctionName )"
            wl( f, Sl )
            wl( f, "{" )
         END

         IF vWk.Object.Type = "D"
            Sl = "   // Operation Calls for Domain: " + vWk.Object.Name
         END

         IF vWk.Object.Type = "O"
            Sl = "   // Object Constraint for Object: " + vWk.Object.Name
         END

         IF vWk.Object.Type = "E"
            Sl = "   // Entity Constraint for Object.Entity: " + vWk.Object.Name
         END

         IF vWk.Object.Type = "A"
            Sl = "   // Derived Attribute for Object.Entity.Attr: " + vWk.Object.Name
         END

         wl( f, Sl )

         Sl = "   if ( zstrcmp( pszFunctionName, " + Quote + vWk.Object.OperName + Quote + " ) == 0 )"
         wl( f, Sl )
         Sl = "      return( (zPVOID) " + vWk.Object.OperName + " );"
         wl( f, Sl )
         wl( f, " " )

      END

      IF nFirstTime = 0
         wl( f, "   return( 0 ); " )
         wl( f, " " )
         wl( f, "}" )
         wl( f, " " )
      END

   END

   vWk = 0
   SysCloseFile( vLPLR, f, 0 )

   GenerateTransShell( vLPLR, vSubtask )

END


LOCAL OPERATION
AnalyzeEntity( VIEW vXOD BASED ON LOD TZZOXODO,
               VIEW vWk  BASED ON LOD TZCMHDWO,
               STRING (32)  ObjectName )

   // First process the recursive sub entities.
   FOR EACH vXOD.CHILDENTITY
      SetViewToSubobject( vXOD, "CHILDENTITY" )
      AnalyzeEntity( vXOD, vWk, ObjectName )
      ResetViewFromSubobject( vXOD )
   END

   // Create the Object Entity Constraint work entity if necessary.
   IF vXOD.ENTITY.ECEOPER != ""
      CREATE ENTITY vWk.Object
      vWk.Object.Name = ObjectName + "." + vXOD.ENTITY.NAME
      vWk.Object.OperName = vXOD.ENTITY.ECEOPER
      vWk.Object.Type = "E"
   END

   FOR EACH vXOD.ATTRIB
      // Create the Derived Attribute work entity if necessary.
      IF vXOD.ATTRIB.DERIVEDF != ""
         CREATE ENTITY vWk.Object
         vWk.Object.Name = ObjectName + "." + vXOD.ENTITY.NAME + "." + vXOD.ATTRIB.NAME
         vWk.Object.OperName  = vXOD.ATTRIB.DERIVEDF
         vWk.Object.Type = "A"
      END
   END

END


LOCAL OPERATION
wl( INTEGER       nFile,
    STRING ( 32 ) StatementLine )

   VIEW vSubtask

   vSubtask = GetDefaultViewForActiveTask( )
   SysWriteLine( vSubtask, nFile, StatementLine )

END


TRANSFORMATION OPERATION
GenerateTransShell( VIEW vLPLR BASED ON LOD TZCMLPLO, VIEW vSubtask )
   VIEW vLOD BASED ON LOD TZZOLODO
   INTEGER f
   INTEGER l
   INTEGER lArgCount
   INTEGER lViewCount
   INTEGER nFirstTime
   STRING ( 10 )  szl
   STRING ( 10 )  szViewCount
   STRING ( 2 )   Quote
   STRING ( 513 ) sz            // size according to zMAX_FILESPEC_LTH + 1
   STRING ( 513 ) sz2           // size according to zMAX_FILESPEC_LTH + 1

   Quote = "\"
   //Quote = '"'
   // Set meta type for LODs
   SET CURSOR FIRST vLPLR.W_MetaType WHERE vLPLR.W_MetaType.Type = 2007
   FOR EACH vLPLR.W_MetaDef
      ActivateMetaOI( vSubtask, vLOD, vLPLR, 2007, 0 )
      FOR EACH vLOD.SourceFile WHERE vLOD.SourceFile.LanguageType = "V"
         sz = vLPLR.LPLR.PgmSrcDir
         sz = sz + "\" + vLOD.SourceFile.Name + ".c"
         f = SysOpenFile( vLPLR, sz, 448 ) // 448 = COREFILE_APPEND
         IF f != 0
            wl( f, " " )
            wl( f, "zLONG OPERATION" )
            sz = "o" + vLOD.LOD.Name + "_CallTransformation( "
            l = GetStringLength( sz )
            sz = sz + "zPCHAR pszOperName,"
            wl( f, sz )
            sz = ""
            LOOP WHILE l > 0
               sz = sz + " "
               l = l - 1
            END
            sz2 = sz + "zVIEW  vArgs,"
            wl( f, sz2 )
            sz2 = sz + "zPVIEW pvViewList[] )"
            wl( f, sz2 )
            wl( f, "{" )
            wl( f, "   zLONG lRC;" )
            wl( f, " " )

            FOR EACH vLOD.Operation WHERE vLOD.Operation.Type = "T"
               sz = "   if ( zstrcmp( pszOperName, " + Quote
               IF vLOD.SourceFile.LanguageType = "V"
                  sz = sz + "o" + vLOD.LOD.Name + "_"
               END
               sz = sz + vLOD.Operation.Name + Quote + " ) == 0 )"
               wl( f, sz )
               wl( f, "   {" )

               // Set up local variables for each non-view argument.
               l = 0
               nFirstTime = 1
               FOR EACH vLOD.Parameter
                  l = l + 1
                  ConvertIntegerToString( l, szl, 10 )

                  IF vLOD.Parameter.DataType = "S"
                     sz = "      zPCHAR   pszArg" + szl + ";" +
                        "  // " + vLOD.Parameter.ShortDesc
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "Y"
                     IF nFirstTime = 1
                        nFirstTime = 0
                        wl( f, "      zLONG    lTemp;" )
                     END
                     sz = "      zCHAR    cArg" + szl + ";" +
                        "  // " + vLOD.Parameter.ShortDesc
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "M"
                     sz = "      zDECIMAL dArg" + szl + ";" +
                        "  // " + vLOD.Parameter.ShortDesc
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "N"
                     IF nFirstTime = 1
                        nFirstTime = 0
                        wl( f, "      zLONG    lTemp;" )
                     END
                     sz = "      zSHORT   nArg" + szl + ";" +
                        "  // " + vLOD.Parameter.ShortDesc
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "L"
                     sz = "      zLONG    lArg" + szl + ";" +
                        "  // " + vLOD.Parameter.ShortDesc
                     wl( f, sz )
                  END
               END

               lArgCount = l

               wl( f, " " )
               sz = "      SetCursorFirstEntity( vArgs, " + Quote + "Argument" +
                               Quote + ", 0 );"
               wl( f, sz )
               nFirstTime = 1

               // Gen code to get each argument from the argument list.
               l = 0
               FOR EACH vLOD.Parameter
                  wl( f, " " )
                  sz = "      // Get value for " + vLOD.Parameter.ShortDesc
                  wl( f, sz )
                  IF nFirstTime = 1
                     nFirstTime = 0
                  ELSE
                     sz = "      SetCursorNextEntity( vArgs, " + Quote + "Argument" +
                                     Quote + ", 0 );"
                     wl( f, sz )
                  END

                  l = l + 1
                  ConvertIntegerToString( l, szl, 10 )

                  IF vLOD.Parameter.DataType = "S"
                     sz = "      GetAddrForAttribute( &pszArg" + szl + ", vArgs, " +
                       Quote + "Argument" + Quote + ", " + Quote + "Value" +
                       Quote + " );"
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "N"
                     sz = "      GetIntegerFromAttribute( &lTemp, vArgs, " +
                       Quote + "Argument" + Quote + ", " + Quote + "Value" +
                       Quote + " );"
                     wl( f, sz )
                     sz = "      nArg" + szl + " = (zSHORT) lTemp;"
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "Y"
                     sz = "      GetIntegerFromAttribute( &lTemp, vArgs, " +
                       Quote + "Argument" + Quote + ", " + Quote + "Value" +
                       Quote + " );"
                     wl( f, sz )
                     sz = "      cArg" + szl + " = (zCHAR) lTemp;"
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "L"
                     sz = "      GetIntegerFromAttribute( &lArg" + szl + ", vArgs, " +
                       Quote + "Argument" + Quote + ", " + Quote + "Value" +
                       Quote + " );"
                     wl( f, sz )
                  END

                  IF vLOD.Parameter.DataType = "M"
                     sz = "      GetDecimalFromAttribute( &dArg" + szl + ", vArgs, " +
                       Quote + "Argument" + Quote + ", " + Quote + "Value" +
                       Quote + " );"
                     wl( f, sz )
                  END

               END

               wl( f, " " )
               sz = "      lRC = (zLONG) o" + vLOD.LOD.Name + "_" +
                     vLOD.Operation.Name + "( "
               l = GetStringLength( sz )
               sz2 = ""
               LOOP WHILE l > 0
                  sz2 = sz2 + " "
                  l = l - 1
               END
               l = 0
               lViewCount = 0
               FOR EACH vLOD.Parameter
                  l = l + 1
                  ConvertIntegerToString( l, szl, 10 )

                  IF vLOD.Parameter.DataType = "V"
                     IF vLOD.Parameter.PFlag != "Y"
                        sz = sz + "*"
                     END

                     ConvertIntegerToString( lViewCount, szViewCount, 10 )
                     sz= sz + "pvViewList[ " + szViewCount + " ]"
                     lViewCount = lViewCount + 1
                  END

                  IF vLOD.Parameter.DataType = "S"
                     sz = sz + "pszArg" + szl
                  END

                  IF vLOD.Parameter.DataType = "N"
                     sz = sz + "nArg" + szl
                  END

                  IF vLOD.Parameter.DataType = "Y"
                     sz = sz + "cArg" + szl
                  END

                  IF vLOD.Parameter.DataType = "L"
                     sz = sz + "lArg" + szl
                  END

                  IF vLOD.Parameter.DataType = "M"
                     sz = sz + "dArg" + szl
                  END

                  IF l != lArgCount
                     sz = sz + ",     // " + vLOD.Parameter.ShortDesc
                  ELSE
                     sz = sz + " );   // " + vLOD.Parameter.ShortDesc
                  END

                  wl( f, sz )
                  sz = sz2
               END

               wl( f, "      return( lRC );" )
               wl( f, "   }" )
               wl( f, " " )

            END // FOR EACH vLOD.Operation...

            wl( f, "   return( -1 );" )
            wl( f, "}" )
            SysCloseFile( vLPLR, f, 0 )

         END // if f != 0...

      END  // FOR EACH vLOD.SourceFile

   END // FOR EACH vLPLR.W_MetaDef

END // GenTransShell

/*************************************************************************************************
**    
**    OPERATION: CheckOI_ForDupZKey
**    
*************************************************************************************************/
TRANSFORMATION OPERATION
CheckOI_ForDupZKey( VIEW vTZCMLPLO BASED ON LOD TZCMLPLO,
                    VIEW vHierMetaOI_Orig,
                    STRING ( 32 ) szRootEntityName )

   VIEW vHierMetaOI
   STRING ( 32 )   szCurrentEntityName
   STRING ( 32 )   szPreviousEntityName
   STRING ( 2000 ) szMsg
   STRING ( 20 )   szZKey
   INTEGER         lZKey
   INTEGER         lLastZKey
   SHORT           nHierRC
   SHORT           nReturnLevel

   // Check the vHierMetaOI object instance for a duplicate ZKey. Do this by creating a work
   // subobject in vHierMetaOI of all ZKey values in the vHierMetaOI, then sorting and comparing them.
   
   FOR EACH vTZCMLPLO.EntityZKey 
      DELETE ENTITY vTZCMLPLO.EntityZKey NONE 
   END
   FOR EACH vTZCMLPLO.DuplicateZKey 
      DELETE ENTITY vTZCMLPLO.DuplicateZKey NONE 
   END
   
   CreateViewFromView( vHierMetaOI, vHierMetaOI_Orig )
   NAME VIEW vHierMetaOI "vHierMetaOIDuplicates"
   SetCursorFirstEntity( vHierMetaOI, szRootEntityName, "" )
   DefineHierarchicalCursor( vHierMetaOI, szRootEntityName )
   nHierRC = zCURSOR_SET
   // Create Root ZKey.
   GetIntegerFromAttribute( lZKey, vHierMetaOI, szRootEntityName, "ZKey" )
   CREATE ENTITY vTZCMLPLO.EntityZKey 
   vTZCMLPLO.EntityZKey.ZKey       = lZKey
   vTZCMLPLO.EntityZKey.EntityName = szRootEntityName
   LOOP WHILE nHierRC >= zCURSOR_SET
      nHierRC = SetCursorNextEntityHierarchical( nReturnLevel,
                                                 szCurrentEntityName,
                                                 vHierMetaOI )
      IF nHierRC >= zCURSOR_SET
         // Create ZKey, unless Entity is identified as No Duplicate Check.
         SET CURSOR FIRST vTZCMLPLO.DuplicateCheckEntity WHERE vTZCMLPLO.DuplicateCheckEntity.EntityName = szCurrentEntityName
         IF RESULT >= zCURSOR_SET 
            GetIntegerFromAttribute( lZKey, vHierMetaOI, szCurrentEntityName, "ZKey" )
            CREATE ENTITY vTZCMLPLO.EntityZKey 
            vTZCMLPLO.EntityZKey.ZKey       = lZKey
            vTZCMLPLO.EntityZKey.EntityName = szCurrentEntityName
   
            // For recursive subentity, step down a level.
            IF nHierRC = zCURSOR_SET_RECURSIVECHILD
               SetViewToSubobject( vHierMetaOI, szCurrentEntityName )
            END
         END
      END
   END
   DropView( vHierMetaOI )
   
   // Sort ZKey entries and loop through each entry looking for duplicates.
   OrderEntityForView( vTZCMLPLO, "EntityZKey", "ZKey A" )
   SET CURSOR FIRST vTZCMLPLO.EntityZKey 
   lLastZKey = 0
   FOR EACH vTZCMLPLO.EntityZKey 
      lZKey = vTZCMLPLO.EntityZKey.ZKey 
      IF lLastZKey = lZKey
         CREATE ENTITY vTZCMLPLO.DuplicateZKey 
         vTZCMLPLO.DuplicateZKey.ZKey        = vTZCMLPLO.EntityZKey.ZKey 
         vTZCMLPLO.DuplicateZKey.EntityName1 = vTZCMLPLO.EntityZKey.EntityName 
         vTZCMLPLO.DuplicateZKey.EntityName2 = szPreviousEntityName
      END
      lLastZKey            = lZKey
      szPreviousEntityName = vTZCMLPLO.EntityZKey.EntityName
   END
   
   // If a duplicate ZKey was found, issue a message.
   IF vTZCMLPLO.DuplicateZKey EXISTS
      szMsg = "The following ZKeys and Entities are duplicates: " + NEW_LINE
      FOR EACH vTZCMLPLO.DuplicateZKey 
         szZKey = vTZCMLPLO.DuplicateZKey.ZKey 
         szMsg = szMsg + "   " + szZKey + " / " + vTZCMLPLO.DuplicateZKey.EntityName1 + " / " + vTZCMLPLO.DuplicateZKey.EntityName2 + NEW_LINE
      END
      MessageSend( vTZCMLPLO, "", "Configuration Management", szMsg, zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
   ELSE
      MessageSend( vTZCMLPLO, "", "Configuration Management", "There were no duplicate keys in object.", zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
   END
   
   // Remove temporary work entities.
   FOR EACH vTZCMLPLO.EntityZKey 
      DELETE ENTITY vTZCMLPLO.EntityZKey NONE 
   END

END
