/*
CHANGE LOG
2002.12.17  DonC
   Added derived operation dAttributeTextMapName.
2002.09.30  DonC
   Modified LOD_Migrate to use DBMS Name from Old TE, instead of from POD, as the POD
   sometimes had an obsolete value.
2002.03.04  TMV
   Modified MoveAttribInSequence for proper sequencing
   as a result of a fix in the driver regarding listctrls
2001.05.29  BL  JOINS
   Modified fnCopyPOD_Entity for error in C Generation
2001.05.24  BL  JOINS
   Move delete old POD_Entity from Relink Code to Save LOD
   Modified LOD_EntityCopy for copy Entity with POD_Entity (Join Definition)
2001.05.09  BL  JOINS
   Modified LOD_RelinkDelete for delete all POD_Entities with TE_DBMS_SourceForEntity,
   where this included DataSource does not exists in the TE
2000.10.20  SR  Z2000 Size of path variables
   Modified size of
   - SourceFileName in function GetRelationshipName,
   - SourceFileName in function GetERAttributeName,
   - SourceFileName and SourceName in function LOD_Migrate and
   - SourceFileName1, SourceFileName2 and SourceName in function LOD_OperationCopy
   because size of attributes ExecDir, MetaSrcDir and PgmSrcDir has been changed to 254
   in datamodel.
2000.09.28  DC    Z10
   Modified fnRelinkRelationships to correct error message and to remove the LOD Entity
   from the LOD if the relationship has been deleted.
2000.10.02  HH
   fix bug 051157, "minor relink" by ZKey if attribute names or relationship names
   were changed in the ER, but the LOD was not saved prior to migration.
2000.08.04  BL    Z10
   Rename Message Text
2000.06.30  BL    Z10
   Modified NewAttributeSequence for check NULL value
2000.06.20  DC    Z10
   Modified LOD_RelinkDelete to handle changing the POD.TE_SourceZKey when a DBMS Source
   entry has been deleted and recreated by the same name.
2000.05.20  BL    Z10
   Added NewAttributeSequence, DelAttribFromSequence, MoveAttribInSequence:
   if insert new Attribute, delete Attribute, move Attribute then set new Attribute
   Sequence
   Added SetAttributeSequence, MoveAttribInSequence: set original Attribute Sequence
   Added SortAttributes: sort Attributes before commit LOD
2000.04.28  DC    Z10
   Modified LOD_RelinkDelete so that ER_RelLinks would be re-included if there was no match
   on ER_Entity ZKeys. Also corrected ER_Attribute relinking and renamed fnRelinkWorkAttrib
   operation for consistency with other local operations.
2000.01.03  BL    Z10  Repository
   Modified Operation LOD_RelinkDelete: Relink TE
1999.09.15  DC    Z10
   Created operation LOD_OperationCopy so that the code could be reused in CopyLOD in TZZOLODD.C.
1999.06.10  DC    Z10
   Modified LOD_RelinkDelete to reinclude ER_RelLink entries if they have been deleted
   and readded by the same name in the ER. Before, they didn't relink and there was
   no error.
1999.04.09  DC    Z10   Domains
   Added constraint to AttributeConstraints for DerivedExpression.
*** Start of original LOG entries
19.06.1997  DonC
   Modified error message ZO00406 to give more information to the operator on what was
   wrong to produce the error.
1997.11.13  DGC
   Changed CopyFile() to SysCopyFile().
18.12.1997  DonC
   Modified LOD_EntityCopy to give error message if source ER_Entity doesn't exist
   in target.
24.01.1998  DonC
   Modified LOD_Migrate to copy POD.
02.02.1998  DonC
   Corrected LOD_Migrate to not give error message when no TE exists.
02.06.1998  DonC
   Modified LOD_Migrate so that new VORs would use the Name from the LOD itself instead
   of the LOD_Name passed in the call. This is because the LOD_Name passed was all upper
   case characters if a rebuild of the XLP had been done. (QS 187)
18.08.1998 DonC
   Modified LOD_EntityCopy to process attribute LOD_AttributeRec.DB_DerivedValue and entity DB_ER_AttributeRec.
   (TB 50)
18.08.1998 DonC
   Eliminated Sequence-Priority validation from AttributeConstraints because the original code was erroneous
   and because the new interface does not require such a validation.
1999/02/11 DC
   Modified LOD_Migrate to set the DBMS Source last used correctly in the POD. (TB 506)
*/

DERIVED ATTRIBUTE OPERATION
DIL_NLS_Text( VIEW          vLOD BASED ON LOD TZZOLODO,
              STRING ( 32 ) lpEntity,
              STRING ( 32 ) lpAttribute,
              SHORT         GetOrSetFlag )

// LAST MESSAGE ID: ZO00416

   SHORT        nLanguageCode
   STRING (254) szDIL_Text

   SysGetLanguageCode ( nLanguageCode )

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

      // Determine DIL text to use by checking the NLS Language Code for a match on
      // a DIL_NLS_Text entity.  If there is a match, use it.  Otherwise, use the
      // LOD_Attribute.DIL_Text attribute.

      SET CURSOR FIRST vLOD.DIL_NLS_Text  WHERE
                       vLOD.DIL_NLS_Text.LanguageIndex  = nLanguageCode
      IF RESULT >= zCURSOR_SET
         szDIL_Text = vLOD.DIL_NLS_Text.Text
      ELSE
         szDIL_Text = vLOD.LOD_Attribute.DIL_Text
      END

      StoreStringInRecord ( vLOD, lpEntity, lpAttribute, szDIL_Text )

        /* end zDERIVED_GET */
   OF   zDERIVED_SET:

      // As for zDERIVED_GET above, use the Language Code to store the data entered into
      // the derived attribute.  If there is DIL_NLS_Text entity that matches the
      // Language Code, then set the data there.  If not, set it into the
      // LOD_Attribute.DIL_Text attribute.

      GetStringFromRecord ( vLOD, lpEntity, lpAttribute, szDIL_Text, 254 )

      SET CURSOR FIRST vLOD.DIL_NLS_Text  WHERE
                       vLOD.DIL_NLS_Text.LanguageIndex  = nLanguageCode
      IF RESULT >= zCURSOR_SET
         vLOD.DIL_NLS_Text.Text = szDIL_Text
      ELSE
         vLOD.LOD_Attribute.DIL_Text = szDIL_Text
      END

        /* end zDERIVED_SET */
   END  /* case */

END

TRANSFORMATION OPERATION
LOD_Migrate( VIEW          NewMainLOD BASED ON LOD TZZOLODO,
             STRING ( 32 ) LOD_Name,
             VIEW          SourceLPLR BASED ON LOD TZCMLPLO,
             VIEW          vSubtask )

   VIEW SourceLPLR2      BASED ON LOD TZCMLPLO
   VIEW NewRecursiveLOD  BASED ON LOD TZZOLODO
   VIEW OldMainLOD       BASED ON LOD TZZOLODO
   VIEW OldRecursiveLOD  BASED ON LOD TZZOLODO
   VIEW NewERD           BASED ON LOD TZEREMDO
   VIEW SourceERD        BASED ON LOD TZEREMDO
   VIEW CurrentLPLR      BASED ON LOD TZCMLPLO
   VIEW TempLPLR         BASED ON LOD TZCMLPLO
   VIEW SourceVOR_LPLR   BASED ON LOD TZCMLPLO
   VIEW TargetVOR_LPLR   BASED ON LOD TZCMLPLO
   VIEW ReturnedTE       BASED ON LOD TZTENVRO
   VIEW OldTE            BASED ON LOD TZTENVRO
   VIEW NewVOR           BASED ON LOD TZWDVORO

   STRING ( 513 ) SourceFileName            // zMAX_FILESPEC_LTH+1
   STRING ( 513 ) TargetFileName            // zMAX_FILESPEC_LTH+1
   STRING ( 40 )  SourceName
   STRING ( 200 ) szMsg
   STRING ( 200 ) szFileName
   STRING ( 1 )   ModifyFlag
   STRING ( 1 )   MergeOperationsFlag
   STRING ( 9 )   ExtensionName

   INTEGER        ErrorFlag
   INTEGER        ERD_Flag
   INTEGER        Offset
   SHORT          StringLength
   SHORT          nRC

   ErrorFlag = 0
   RetrieveViewForMetaList( vSubtask, CurrentLPLR, zREFER_ERD_META )
   ResetViewFromSubobject( CurrentLPLR ) // Get visibility to root.

   // Activate existing source meta OldMainLOD
   SourceFileName = SourceLPLR.LPLR.MetaSrcDir + "\" + LOD_Name + ".LOD"
   ActivateOI_FromFile ( OldMainLOD, "TZZOLODO", CurrentLPLR, SourceFileName, 8192 )
   // 8192 is zIGNORE_ATTRIB_ERRORS
   NAME VIEW OldMainLOD "OldMainLOD"

   // Activate existing source ERD.
   SourceFileName = SourceLPLR.LPLR.MetaSrcDir + "\" + SourceLPLR.LPLR.Name + ".PMD"
   ActivateOI_FromFile ( SourceERD, "TZEREMDO", CurrentLPLR, SourceFileName, 8192 )   // 8192 is zIGNORE_ATTRIB_ERRORS
   NAME VIEW SourceERD "SourceERD"

   // Activate the current ERD.  If it doesn't exist, it is an error.
   // It is also an error, if the LOD references a Domain that is not in the LPLR, but
   // this is checked inside the code of LOD_EntityCopy.
   GET VIEW NewERD NAMED "NewERD"
   IF RESULT < 0
      IF CurrentLPLR.W_MetaDef EXISTS
         nRC = ActivateMetaOI( vSubtask, NewERD, CurrentLPLR, zREFER_ERD_META, 0 )
         NAME VIEW NewERD "NewERD"
      ELSE
         nRC = -1
      END

      IF nRC < 0
         // Unless the LOD is a work lod, it is an error to migrate it without an
         // ERD. The only way we know this is to loop through all the entities
         // to see if any of them are against the ERD.
         ERD_Flag = 0
         FOR EACH OldMainLOD.LOD_Entity
            IF OldMainLOD.LOD_Entity.Work != "Y"
               ERD_Flag = 1
            END
         END
         IF ERD_Flag = 1
            MessageSend( vSubtask, "ZO00401", "LOD Migration",
                         "No current Data Model exists.",
                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
            RETURN -1
         END
      END
   END

   // If the LOD entity doesn't exist, this is a new LOD and we must create it.
   IF NewMainLOD.LOD DOES NOT EXIST
      CreateMetaEntity( vSubtask, NewMainLOD, "LOD", zPOS_AFTER )
        // Can't use SetMatchingAttributes operation because of derived attribute from a
        // different LPLR.
        NewMainLOD.LOD.LastSyncDate            = OldMainLOD.LOD.LastSyncDate
        NewMainLOD.LOD.Name                    = OldMainLOD.LOD.Name
        NewMainLOD.LOD.Desc                    = OldMainLOD.LOD.Desc
        NewMainLOD.LOD.ReLinked                = OldMainLOD.LOD.ReLinked
        NewMainLOD.LOD.ActivateConstraint      = OldMainLOD.LOD.ActivateConstraint
        NewMainLOD.LOD.ActivateEmptyConstraint = OldMainLOD.LOD.ActivateEmptyConstraint
        NewMainLOD.LOD.CommitConstraint        = OldMainLOD.LOD.CommitConstraint
        NewMainLOD.LOD.DropOIConstraint        = OldMainLOD.LOD.DropOIConstraint
        NewMainLOD.LOD.DLL_Name                = OldMainLOD.LOD.DLL_Name
        NewMainLOD.LOD.CacheNumberPerEntity    = OldMainLOD.LOD.CacheNumberPerEntity
   END

   // If the LOD_EntityParent entity exists, then we are merging Operations into a current LOD and not changing
   // any of the Entities themselves.
   // If the LOD_EntityParent entity doesn't exist, then we are either replacing the whole LOD or creating a new one,
   // and all data from the source LOD is recreated in the target LOD.
   IF NewMainLOD.LOD_EntityParent DOES NOT EXIST

      CreateViewFromViewForTask( NewRecursiveLOD, NewMainLOD, 0 )
      CreateViewFromViewForTask( OldRecursiveLOD, OldMainLOD, 0 )
      NAME VIEW NewRecursiveLOD "NewRecursiveLOD"
      NAME VIEW OldRecursiveLOD "OldRecursiveLOD"

      // Go to copy Source Files and Operations.
      LOD_OperationCopy( vSubtask, NewMainLOD, OldMainLOD, SourceLPLR )

      // Force the activation of the TE, because it is needed by the XOD build routine,
      // which requires that the TE and ER have been linked.
      // Also get the old TE, for retrieving up-to-date POD information.
      GET VIEW ReturnedTE NAMED "TE_DB_Environ"
      IF RESULT < 0
         RetrieveViewForMetaList( vSubtask, TempLPLR, zREFER_DTE_META )
         IF TempLPLR.W_MetaDef EXISTS
            ActivateMetaOI( vSubtask, ReturnedTE, TempLPLR, zREFER_DTE_META, 0 )
            // Name for building of XOD.
            NAME VIEW ReturnedTE "TE_DB_Environ"
            // Get old TE or set view to zero.
            CreateViewFromViewForTask( SourceLPLR2, SourceLPLR, 0 )
            SET CURSOR FIRST SourceLPLR2.W_MetaType WHERE SourceLPLR2.W_MetaType.Type = 2006
            IF SourceLPLR2.W_MetaDef EXISTS
               SourceFileName = SourceLPLR2.LPLR.MetaSrcDir + "\" + SourceLPLR2.W_MetaDef.Name + ".DTE"
               ActivateOI_FromFile ( OldTE, "TZTENVRO", CurrentLPLR, SourceFileName, 8192 ) // 8192 is zIGNORE_ATTRIB_ERRORS
               NAME VIEW OldTE "OldTE"
               DropView ( TempLPLR )
            ELSE
               OldTE = 0
            END
            DropView( SourceLPLR2 )
         ELSE
            ReturnedTE = 0
            OldTE = 0
         END
      ELSE
         GET VIEW OldTE NAMED "OldTE"
      END

      CreateViewFromViewForTask( SourceLPLR2, SourceLPLR, 0 )
      // If the old LOD was saved with TE and there is a TE in new LPLR, copy POD.
      IF OldMainLOD.POD EXISTS AND OldTE != 0

         // Try to set cursor on DBMS_Source which corresponds to the old POD.  If a
         // match, continue to process the POD.  Otherwise position on first DBMS_Source.
         SET CURSOR  FIRST OldMainLOD.TE_DBMS_Source WITHIN OldMainLOD.POD WHERE
                    OldMainLOD.TE_DBMS_Source.ZKey = OldMainLOD.POD.TE_SourceZKey
         SET CURSOR FIRST OldTE.TE_DBMS_Source WHERE
                    OldTE.TE_DBMS_Source.ZKey = OldMainLOD.TE_DBMS_Source.ZKey
         SET CURSOR FIRST ReturnedTE.TE_DBMS_Source WHERE
                    ReturnedTE.TE_DBMS_Source.Name = OldTE.TE_DBMS_Source.Name
         IF RESULT < zCURSOR_SET
            // Try to position on first TE.
            SET CURSOR FIRST ReturnedTE.TE_DBMS_Source
         END
         IF RESULT >= zCURSOR_SET
            CreateMetaEntity( vSubtask, NewMainLOD, "POD", zPOS_AFTER )
            SetMatchingAttributesByName ( NewMainLOD, "POD", OldMainLOD, "POD", zSET_NULL )
            INCLUDE NewMainLOD.TE_DB_Environ FROM ReturnedTE.TE_DB_Environ
            NewMainLOD.POD.TE_SourceZKey = ReturnedTE.TE_DBMS_Source.ZKey
         END
      END

      FOR EACH OldRecursiveLOD.LOD_EntityParent
         nRC = LOD_EntityCopy( NewMainLOD,
                               NewRecursiveLOD,
                               OldMainLOD,
                               OldRecursiveLOD,
                               SourceLPLR2,
                               CurrentLPLR,
                               NewERD,
                               SourceERD,
                               ReturnedTE,
                               vSubtask,
                               "",
                               "" )

         IF nRC != 0  // Pass along any errors
            ErrorFlag = 1
         END

      END
      DropView( SourceLPLR2 )
      DropView( NewRecursiveLOD )
      DropView( OldRecursiveLOD )

   ELSE

      // The LOD already exists, so we are only merging Operations (including source code) into the LOD.
      // Note that the following code does not handle the situation where Operations in the Source LPLR
      // have been moved from one Source File to another. It assumes that they're in the same Source File.
      FOR EACH OldMainLOD.SourceFile

         // Initialize SourceFile.
         SET CURSOR FIRST NewMainLOD.SourceFile WHERE NewMainLOD.SourceFile.Name = OldMainLOD.SourceFile.Name
         IF RESULT < zCURSOR_SET
            // Copy over the whole Source File, including Operations and Code.
            CreateMetaEntity( vSubtask, NewMainLOD, "SourceFile", zPOS_AFTER )
            SetMatchingAttributesByName ( NewMainLOD, "SourceFile", OldMainLOD, "SourceFile", zSET_NULL )

            // Set up Source and Target file names for Operations.
            ExtensionName = OldMainLOD.SourceFile.Extension
            SourceFileName = SourceLPLR.LPLR.PgmSrcDir + "\" + OldMainLOD.SourceFile.Name + "." + ExtensionName
            TargetFileName = CurrentLPLR.LPLR.PgmSrcDir + "\" + NewMainLOD.SourceFile.Name + "." + ExtensionName

            // Copy the .C file or the .VML file, if it exists, from the source directory to the
            // target directory.
            SysCopyFile( vSubtask, SourceFileName, TargetFileName, TRUE )

            MergeOperationsFlag = "N"
         ELSE

            // Set up Source and Target file names for Operations.
            // Only set up merge Source for VML.
            ExtensionName = OldMainLOD.SourceFile.Extension
            IF ExtensionName = "VML"
               SourceFileName = SourceLPLR.LPLR.PgmSrcDir + "\" + OldMainLOD.SourceFile.Name + ".VML"
               TargetFileName = CurrentLPLR.LPLR.PgmSrcDir + "\" + NewMainLOD.SourceFile.Name + ".VML"
            ELSE
               szMsg = "LOD Operations in Source, " + OldMainLOD.SourceFile.Name + ", will not be merged because the Source code is not VML."
               MessageSend( vSubtask, "ZO", "LOD Merge", szMsg, zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
               SourceFileName = ""
               TargetFileName = ""
            END
            MergeOperationsFlag = "Y"
         END

         // Merge each Operation and related code, if requested.
         FOR EACH OldMainLOD.Operation
            ModifyFlag = "Y"
            SET CURSOR FIRST NewMainLOD.Operation WHERE NewMainLOD.Operation.Name = OldMainLOD.Operation.Name
            IF RESULT >= zCURSOR_SET
               IF NewMainLOD.Operation.DoNotMergeFlag = "Y"
                  ModifyFlag = "N"
               ELSE
                  DELETE ENTITY NewMainLOD.Operation NONE
               END
            END
            IF ModifyFlag = "Y"    // Either the Operation is new or it is to replace the old Operation.
               CreateMetaEntity( vSubtask, NewMainLOD, "Operation", zPOS_AFTER )
               SetMatchingAttributesByName ( NewMainLOD, "Operation", OldMainLOD, "Operation", zSET_NULL )
               FOR EACH OldMainLOD.Parameter
                  CreateMetaEntity( vSubtask, NewMainLOD, "Parameter", zPOS_AFTER )
                  SetMatchingAttributesByName ( NewMainLOD, "Parameter", OldMainLOD, "Operation", zSET_NULL )
               END

               // Merge in the Operation code, unless it was copied in for a new SourceFile above.
               IF MergeOperationsFlag = "Y"
                  CopyOperationCode( NewMainLOD, TargetFileName, SourceFileName, NewMainLOD.Operation.Name )
               END
            END
         END
      END

      // If there is an ObjectConstraint file on the SourceFile, make sure it is also on the Target.
      IF OldMainLOD.LOD_ConstraintOper EXISTS
         IF NewMainLOD.LOD_ConstraintOper EXISTS
            EXCLUDE NewMainLOD.LOD_ConstraintOper
         END
         SET CURSOR FIRST NewMainLOD.Operation WITHIN OldMainLOD.LOD
                    WHERE NewMainLOD.Operation.Name = OldMainLOD.LOD_ConstraintOper.Name
         IF RESULT >= zCURSOR_SET
            INCLUDE NewMainLOD.LOD_ConstraintOper FROM NewMainLOD.Operation
         END
      END

   END

   DropObjectInstance( OldMainLOD )

   // Don't migrate any LOD without a root entity.
   SET CURSOR FIRST NewMainLOD.LOD_EntityParent
   IF RESULT < zCURSOR_SET
      szMsg = "LOD (" + NewMainLOD.LOD.Name + ") is empty and will not be migrated."
      MessageSend( vSubtask, "", "Entity Copy",
                   szMsg,
                   zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
      RETURN -1
   END

   // If the ERD was modified during LOD copy, prompt the user for save of both the LOD and ERD together. If the LOD
   // is to be saved, the ERD must also be saved. We will not do this if component errors have occurred during the copy.
   IF CurrentLPLR.LPLR.wMergeComponentError = "Y"
      MessageSend( vSubtask, "", "LOD Migrate",
                   "An error occurred during the copy of the LOD. Migrating the LOD will be aborted.",
                   zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
      CurrentLPLR.LPLR.wMergeComponentError = ""
      RETURN -1
   END
   IF CurrentLPLR.LPLR.wMergeER_ModifiedFlag = "Y"
      nRC = MessagePrompt( vSubtask, "", "LOD Migrate",
                           "The ER was modified in the process of migrating the LOD. Do you want to save both the ER and the LOD?",
                           0, zBUTTONS_YESNOCANCEL, 0, zICON_QUESTION )
      IF nRC = zRESPONSE_YES
         // Commit the ER.
         // We will not use CommitMetaOI because it requires getting an updatable version of the ER, which creates
         // all sorts of meta problems because we already have a LOD which is referencing a "referencable" version
         // of the ER. We thus have made our changes to the "referencable" version (GET VIEW NewERD NAMED "TZEREMDO_REF" above)
         // and will commit it here.
         szFileName = CurrentLPLR.LPLR.MetaSrcDir + "\" +
                      CurrentLPLR.LPLR.Name + ".PMD"
         nRC = CommitOI_ToFile( NewERD, szFileName, zASCII )
         IF nRC < 0
            MessageSend( vSubtask, "", "LOD Merge",
                         "An error occurred during the save of the ER. Merging the LOD will be aborted.",
                         zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
            CurrentLPLR.LPLR.wMergeComponentError  = ""
            CurrentLPLR.LPLR.wMergeER_ModifiedFlag = ""
            RETURN -1
         END
      ELSE
         // The User response was no, so warn him that the LOD was not copied.
         CurrentLPLR.LPLR.wMergeER_ModifiedFlag = ""
         MessageSend( vSubtask, "", "LOD Migrate",
                      "Migrating the LOD has been aborted.",
                      zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
         CurrentLPLR.LPLR.wMergeComponentError  = ""
         CurrentLPLR.LPLR.wMergeER_ModifiedFlag = ""
         RETURN -1
      END
      CurrentLPLR.LPLR.wMergeER_ModifiedFlag = ""
   END
   DropView( CurrentLPLR )

   IF ErrorFlag = 0
      CommitMetaOI( vSubtask, NewMainLOD, 7 )
   ELSE
      RETURN -1
   END

   //CommitMetaOI( vSubtask, NewMainLOD, 7 )

   // For every VOR for the original source LOD in the original LPLR, either update or create the
   // corresponding VOR in the new LPLR.
   GET VIEW SourceVOR_LPLR NAMED "SourceVOR_LPLR"
   GET VIEW TargetVOR_LPLR NAMED "TargetVOR_LPLR"
   SourceName = NewMainLOD.LOD.Name
   FOR EACH SourceVOR_LPLR.W_MetaDef
      IF SourceVOR_LPLR.W_MetaDef.MigrateWorkName = SourceName
         SET CURSOR FIRST TargetVOR_LPLR.W_MetaDef WHERE TargetVOR_LPLR.W_MetaDef.Name = SourceVOR_LPLR.W_MetaDef.Name
         IF RESULT >= zCURSOR_SET
            ActivateMetaOI( vSubtask, NewVOR, TargetVOR_LPLR, zSOURCE_VOR_META, zSINGLE )
            NAME VIEW NewVOR "NewVOR"
            EXCLUDE NewVOR.LOD
            INCLUDE NewVOR.LOD FROM NewMainLOD.LOD
            CommitMetaOI( vSubtask, NewVOR, 9 )
         ELSE
            ActivateEmptyMetaOI( vSubtask, NewVOR, zSOURCE_VOR_META, zSINGLE )
            CreateMetaEntity( vSubtask, NewVOR, "ViewObjRef", zPOS_AFTER )
            NewVOR.ViewObjRef.Name = SourceVOR_LPLR.W_MetaDef.Name
            INCLUDE NewVOR.LOD FROM NewMainLOD.LOD
            CommitMetaOI( vSubtask, NewVOR, 9 )
         END
         DropMetaOI( vSubtask, NewVOR )
      END
   END

END

TRANSFORMATION OPERATION
LOD_OperationCopy( VIEW vSubtask,
                   VIEW NewMainLOD BASED ON LOD TZZOLODO,
                   VIEW OldMainLOD BASED ON LOD TZZOLODO,
                   VIEW SourceLPLR BASED ON LOD TZCMLPLO )

   VIEW DirLPLR BASED ON LOD TZCMLPLO

   STRING ( 40 )  SourceName
   STRING ( 32 )  MetaName
   STRING ( 9 )   ExtensionName
   STRING ( 513 ) SourceFileName1           // zMAX_FILESPEC_LTH+1
   STRING ( 513 ) SourceFileName2           // zMAX_FILESPEC_LTH+1

   FOR EACH OldMainLOD.SourceFile

      // If there is no structure underneath the SourceFile entity in the
      // old LOD, ignore it..
      // If there is a structure underneath the SourceFile entity in the old LOD,
      // simply copy it over.

      IF OldMainLOD.Operation EXISTS

         ExtensionName = OldMainLOD.SourceFile.Extension
         MetaName = OldMainLOD.SourceFile.Name

         CreateMetaEntity( vSubtask, NewMainLOD, "SourceFile", zPOS_AFTER )
         SetMatchingAttributesByName ( NewMainLOD, "SourceFile",
                                       OldMainLOD, "SourceFile", zSET_NULL )

         FOR EACH OldMainLOD.Operation

            CreateMetaEntity( vSubtask, NewMainLOD, "Operation", zPOS_AFTER )
            SetMatchingAttributesByName ( NewMainLOD, "Operation",
                                          OldMainLOD, "Operation", zSET_NULL )
            FOR EACH OldMainLOD.Parameter
               CreateMetaEntity( vSubtask, NewMainLOD, "Parameter", zPOS_AFTER )
               SetMatchingAttributesByName ( NewMainLOD, "Parameter",
                                             OldMainLOD, "Parameter", zSET_NULL )
            END

         END

      END

      // Copy the .C file or the .VML file, if it exists, from the source directory to the
      // target directory.
      // Note that if it isn't there (it wasn't created in the source LPLR), we're going to
      // just ignore it; we're not going to return an error message.
      RetrieveViewForMetaList( vSubtask, DirLPLR, zSOURCE_ERD_META ) // Get a view for directory info.
      ResetViewFromSubobject( DirLPLR ) // Get visibility to root.
      IF ExtensionName = "C"
         SourceName = MetaName + ".C"
      ELSE
         SourceName = MetaName + ".VML"
      END
      SourceFileName1 = SourceLPLR.LPLR.PgmSrcDir + "\" + SourceName
      SourceFileName2 = DirLPLR.LPLR.PgmSrcDir + "\" + SourceName
      SysCopyFile( vSubtask, SourceFileName1, SourceFileName2, TRUE )
      DropView( DirLPLR )

      IF OldMainLOD.LOD_ConstraintOper EXISTS AND
         OldMainLOD.SourceFileForOCOper.Name = OldMainLOD.SourceFile.Name

         SET CURSOR FIRST NewMainLOD.Operation WHERE
                NewMainLOD.Operation.Name = OldMainLOD.LOD_ConstraintOper.Name

         INCLUDE NewMainLOD.LOD_ConstraintOper FROM NewMainLOD.Operation

      END

   END

END

/*************************************************************************************************
**
**    OPERATION: fnCopyPOD_Entity
**
*************************************************************************************************/
LOCAL OPERATION
fnCopyPOD_Entity( VIEW vSubtask,
                  VIEW NewLOD  BASED ON LOD TZZOLODO,
                  VIEW OldLOD  BASED ON LOD TZZOLODO,
                  VIEW NewDTE  BASED ON LOD TZTENVRO )

   SHORT  nFoundDataSource

   // Copy POD_Entities ( Join Definitions )
   IF NewDTE = 0
      RETURN 0
   END

   IF NewDTE.TE_DBMS_Source EXISTS
      AND NewLOD.LOD_EntityParent.Work != "Y"
      AND NewLOD.LOD_EntityParent.Derived != "Y"

      FOR EACH OldLOD.POD_Entity

          nFoundDataSource = 0
          SET CURSOR FIRST NewDTE.TE_DBMS_Source
                     WHERE NewDTE.TE_DBMS_Source.ZKey = OldLOD.TE_DBMS_SourceForEntity.ZKey

          IF RESULT >= zCURSOR_SET
             nFoundDataSource = 1
          ELSE
             SET CURSOR FIRST NewDTE.TE_DBMS_Source
                        WHERE NewDTE.TE_DBMS_Source.Name = OldLOD.TE_DBMS_SourceForEntity.Name

             LOOP WHILE RESULT >= zCURSOR_SET AND nFoundDataSource = 0

                  IF NewDTE.TE_DBMS_Source.DBMS = OldLOD.TE_DBMS_SourceForEntity.DBMS
                     nFoundDataSource = 1
                  ELSE
                     SET CURSOR NEXT  NewDTE.TE_DBMS_Source
                                WHERE NewDTE.TE_DBMS_Source.Name = OldLOD.TE_DBMS_SourceForEntity.Name
                  END
             END
          END

          IF nFoundDataSource = 1
             CreateMetaEntity( vSubtask, NewLOD, "POD_Entity", zPOS_AFTER )
             SetMatchingAttributesByName ( NewLOD, "POD_Entity",
                                           OldLOD, "POD_Entity", zSET_NULL )
             INCLUDE NewLOD.TE_DBMS_SourceForEntity FROM NewDTE.TE_DBMS_Source
          END
      END
   END

   RETURN 0
END

/*************************************************************************************************
**
**    OPERATION: LOD_EntityCopy
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_EntityCopy( VIEW        NewMainLOD      BASED ON LOD TZZOLODO,
                VIEW        NewRecursiveLOD BASED ON LOD TZZOLODO,
                VIEW        OldMainLOD      BASED ON LOD TZZOLODO,
                VIEW        OldRecursiveLOD BASED ON LOD TZZOLODO,
                VIEW        SourceLPLR      BASED ON LOD TZCMLPLO,
                VIEW        CurrentLPLR     BASED ON LOD TZCMLPLO,
                VIEW        NewERD          BASED ON LOD TZEREMDO,
                VIEW        SourceERD       BASED ON LOD TZEREMDO,
                VIEW        NewDTE          BASED ON LOD TZTENVRO,
                VIEW        vSubtask,
                STRING (32) ParentName,
                STRING ( 1 ) szAddER_EntityFlag )

/*  This is actually the main part of LOD Migration that copies the Entity subobject.  */

   VIEW NewERD2   BASED ON LOD TZEREMDO
   VIEW TempLOD   BASED ON LOD TZZOLODO

   SHORT      ErrorFlag
   SHORT      FoundFlag
   SHORT      CreateIdentifiersFlag
   SHORT      n
   SHORT      nRC
   STRING (254) szMsg
   STRING (32)  OrigParentName
   STRING (32)  RelationshipName
   STRING (32)  EREntityName
   STRING (32)  ERAttributeName
   STRING (32)  DomainName

   ErrorFlag = 0

   SET CURSOR LAST NewRecursiveLOD.LOD_EntityParent
   CreateMetaEntity( vSubtask, NewRecursiveLOD, "LOD_EntityParent", zPOS_AFTER )
   SetMatchingAttributesByName( NewRecursiveLOD, "LOD_EntityParent", OldRecursiveLOD,
                                "LOD_EntityParent", zSET_NULL )

   INCLUDE NewMainLOD.LOD_Entity FROM NewRecursiveLOD.LOD_EntityParent

   // Copy POD_Entities (Join Definitions), if there is a DTE.
   IF NewDTE != 0
      fnCopyPOD_Entity( vSubtask, NewRecursiveLOD, OldRecursiveLOD, NewDTE )
   END

   // Process ER Entity for LOD, if it exists.
   IF OldRecursiveLOD.ER_EntityRec EXISTS

      // Always position on the ER_Entity in the Source ERD, if it exists. Otherwise skip the code.
      IF SourceERD != 0

         // Position on entity in Source ERD.
         EREntityName = OldRecursiveLOD.ER_EntityRec.Name
         SET CURSOR FIRST SourceERD.ER_Entity WHERE SourceERD.ER_Entity.Name = EREntityName
         IF RESULT < zCURSOR_SET
            szMsg = "ER Entity (" + EREntityName +
                    ") does not exist in source ERD." +
                    NEW_LINE + "LOD (" + OldMainLOD.LOD.Name +
                    ") will not be migrated."
            MessageSend( vSubtask, "ZO00404", "Entity Copy",
                         szMsg,
                         zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            DELETE ENTITY NewRecursiveLOD.LOD_EntityParent NONE
            RETURN 0
         END

         // If the source ER_Entity is not in the target, we will add the Entity and Relationship to the ER.
         // Note that we won't do this if we didn't pass in a source ER.
         SET CURSOR FIRST NewERD.ER_Entity WHERE NewERD.ER_Entity.Name = EREntityName
         IF RESULT < zCURSOR_SET

            // Create ER Entity from LOD Entity. Create entity in alphabetical order.
            SET CURSOR FIRST NewERD.ER_Entity WHERE NewERD.ER_Entity.Name > EREntityName
            CreateMetaEntity( vSubtask, NewERD, "ER_Entity", zPOS_BEFORE )
            SetMatchingAttributesByName ( NewERD,    "ER_Entity",
                                          SourceERD, "ER_Entity", zSET_NULL )
            FOR EACH OldRecursiveLOD.LOD_AttributeRec
               IF OldRecursiveLOD.LOD_AttributeRec.Work != "Y" AND
                  OldRecursiveLOD.ER_AttributeRec.Work  != "Y"

                  // This is an ER Attribute so add it to ER.
                  nRC = LOD_CreateER_Attribute( OldRecursiveLOD,
                                                SourceLPLR,
                                                CurrentLPLR,
                                                NewERD,
                                                vSubtask )
                  IF nRC < 0
                     RETURN nRC
                  END
               END
            END

            // Set flag to create Identifiers.
            // Since we created the ER Entity, we must also create Identifiers. However, these need to be created AFTER the
            // ER Relationship is created because an Identifier can reference a relationship. But a Relationship may need to
            // be added even though the ER Entity is not added, so that code exists further down below. Thus, instead of
            // creating the Identifiers here, we will only set a flag and process the Identifier code after the
            // Relationship code.
            CreateIdentifiersFlag = 1

            CurrentLPLR.LPLR.wMergeER_ModifiedFlag = "Y"    // Indicate that the ER has been modified.
         ELSE
            // Since there is no Source ERD and the source ER_Entity is not in the target, we will give an
            // error message and ignore the Entity.
            IF RESULT < zCURSOR_SET
               szMsg = "ER Entity (" + OldRecursiveLOD.ER_EntityRec.Name +
                       ") does not exist in new ERD." +
                       NEW_LINE + "LOD (" + OldMainLOD.LOD.Name +
                       ") will not be migrated."
               MessageSend( vSubtask, "ZO00404", "Entity Copy",
                            szMsg,
                            zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
               DELETE ENTITY NewRecursiveLOD.LOD_EntityParent NONE
               RETURN 0
            END
         END
      END
   END

   // Process ER Relationship for LOD, if it exists.
   // If the LOD Entity is part of an ER relationship, make sure that relationship is also in the new ER.
   // We will use the relationship in the LOD to locate the relationship in the ER and then copy the relationship from the ER.
   // Note that we might also have to create the ER Entity at the other end of the relationship. If we do, we
   // won't create attributes here, as they will be added when that entity is processed for the LOD.
   // We will call the ERD_RelationshipCopy operation in TZEREM2O to actually create the relationship, as the
   // process is very complicated.
   IF OldRecursiveLOD.ER_RelLinkRec EXISTS AND SourceERD != 0
      RelationshipName = OldRecursiveLOD.ER_RelLinkRec.Name

      // To locate a match on the relationship, we will need to find a match on the relationship name and
      // on both the source and target entity of the relationship.
      FoundFlag = 0
      RelationshipName = OldRecursiveLOD.ER_RelLinkRec.Name
      SET CURSOR FIRST NewERD.ER_RelType
      LOOP WHILE FoundFlag = 0 AND RESULT >= zCURSOR_SET
         // Now make sure the entity on the other side of the RelLink is correct.
         // If not, continue searching.

         // First look for match on relationship name and parent Entity name.
         SET CURSOR FIRST NewERD.ER_RelLink_2
                    WHERE NewERD.ER_RelLink_2.Name = RelationshipName AND
                          NewERD.ER_Entity_2.Name  = ParentName
         IF RESULT >= zCURSOR_SET
            // There was a match, so see if the other RelLink is for he entity itself.
            CreateViewFromViewForTask( NewERD2, NewERD, 0 )
            SET CURSOR NEXT NewERD2.ER_RelLink_2
            IF RESULT < zCURSOR_SET
               SET CURSOR PREVIOUS NewERD2.ER_RelLink_2
            END
            IF NewERD2.ER_Entity_2.Name = EREntityName
               FoundFlag = 1
            END
            DropView ( NewERD2 )
         END
         IF FoundFlag = 0
            // Continue to next RelType if we have no yet found a match.
            SET CURSOR NEXT NewERD.ER_RelType
         END
      END
      IF FoundFlag = 0

         // The relationship is NOT in the ER.
         // Note that the Entity at the other end of the Relationship is already in the ER, either because
         // it is not new with this LOD or it was added earlier when the Parent Entity was processed.

         // We need to position on the relationship in the SourceERD that we are to copy. We are already positioned
         // on the entity.
         SET CURSOR FIRST SourceERD.ER_RelLink_Other WITHIN SourceERD.ER_Entity
                    WHERE SourceERD.ER_RelLink_Other.Name = RelationshipName
                      AND SourceERD.ER_Entity_Other.Name  = ParentName

         // Go to create the relationship.
         ERD_RelationshipCopy( NewERD, SourceERD, vSubtask )

         // We now need to position on the correct relationship from the Source LOD, which is the "other"
         // relationship from that in the LOD, which is RelationshipName.
         SET CURSOR FIRST NewERD.ER_RelLink_2 WHERE NewERD.ER_RelLink_2.Name != RelationshipName

         CurrentLPLR.LPLR.wMergeER_ModifiedFlag = "Y"    // Indicate that the ER has been modified.
      END

      // Whether we added the RelLink or it was already there, include it in the LOD.
      SET CURSOR FIRST NewERD.ER_Entity WHERE NewERD.ER_Entity.Name = OldRecursiveLOD.ER_EntityRec.Name
      IF RESULT < zCURSOR_SET
         IssueError( NewRecursiveLOD,0,0, "Programming Include Error 1" )
         RETURN -1
      END
      INCLUDE NewRecursiveLOD.ER_EntityRec FROM NewERD.ER_Entity

      IF OldRecursiveLOD.ER_RelLinkRec EXISTS
         // It's complex to position on the correct RelType in the Target ERD, as there is no name.
         // Thus, we'll first position on the RelType in the Source ERD, and then position on the Target ERD by
         // RelLink Name and other ER_Entity Name.
         SET CURSOR FIRST SourceERD.ER_Entity WHERE SourceERD.ER_Entity.Name = OldRecursiveLOD.ER_EntityRec.Name
         SET CURSOR FIRST SourceERD.ER_RelType_1 WITHIN SourceERD.ER_Entity
                    WHERE SourceERD.ER_RelType_1.ZKey = OldRecursiveLOD.ER_RelTypeRec.ZKey
         SET CURSOR FIRST NewERD.ER_Entity_Other WITHIN NewERD.ER_Entity
                    WHERE NewERD.ER_Entity_Other.Name  = SourceERD.ER_Entity_Other.Name
                      AND NewERD.ER_RelLink_Other.Name = SourceERD.ER_RelLink_Other.Name
         IF RESULT < zCURSOR_SET
            IssueError( NewRecursiveLOD,0,0, "Programming Include Error 2" )
            RETURN -1
         END
         INCLUDE NewRecursiveLOD.ER_RelLinkRec FROM NewERD.ER_RelLink_Other
         IF NewRecursiveLOD.ER_RelTypeRec DOES NOT EXIST
            INCLUDE NewRecursiveLOD.ER_RelTypeRec FROM NewERD.ER_RelType_1
         END
      END

   END

   // If Identifiers were flagged above to be created, create them here.
   IF CreateIdentifiersFlag = 1
      FOR EACH SourceERD.ER_EntIdentifier
         CreateMetaEntity( vSubtask, NewERD, "ER_EntIdentifier", zPOS_AFTER )
         SetMatchingAttributesByName( NewERD, "ER_EntIdentifier", SourceERD, "ER_EntIdentifier", zSET_NULL )
         FOR EACH SourceERD.ER_FactType
            CreateMetaEntity( vSubtask, NewERD, "ER_FactType", zPOS_AFTER )
            SetMatchingAttributesByName( NewERD, "ER_FactType", SourceERD, "ER_FactType", zSET_NULL )
            IF SourceERD.ER_AttributeIdentifier EXISTS
               SET CURSOR FIRST NewERD.ER_Attribute WHERE NewERD.ER_Attribute.Name = SourceERD.ER_AttributeIdentifier.Name
               IF RESULT < zCURSOR_SET
                  szMsg = "ER Entity (" + EREntityName +
                          ") Identifier (" + SourceERD.ER_AttributeIdentifier.Name + ") does not exist in new ERD." +
                          NEW_LINE + "LOD (" + OldMainLOD.LOD.Name +
                          ") will not be migrated."
                  MessageSend( vSubtask, "ZO00404", "Entity Copy",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
                  DELETE ENTITY NewRecursiveLOD.LOD_EntityParent NONE
                  RETURN 0
               END
               INCLUDE NewERD.ER_AttributeIdentifier FROM NewERD.ER_Attribute
            END
            IF SourceERD.ER_RelLinkIdentifier EXISTS
               SET CURSOR FIRST NewERD.ER_RelLink_Other WITHIN NewERD.ER_Entity
                          WHERE NewERD.ER_RelLink_Other.Name = SourceERD.ER_RelLinkIdentifier.Name
                            AND NewERD.ER_Entity_Other.Name  = SourceERD.ER_Entity_Other_Identifier.Name
               IF RESULT < zCURSOR_SET
                  szMsg = "ER Entity (" + EREntityName +
                          ") Identifier (" + SourceERD.ER_RelLinkIdentifier.Name + "-" + SourceERD.ER_Entity_Other_Identifier.Name +
                          ") does not exist in new ERD." +
                          NEW_LINE + "LOD (" + OldMainLOD.LOD.Name +
                          ") will not be migrated."
                  MessageSend( vSubtask, "ZO00404", "Entity Copy",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
                  DELETE ENTITY NewRecursiveLOD.LOD_EntityParent NONE
                  RETURN 0
               END
               INCLUDE NewERD.ER_AttributeIdentifier FROM NewERD.ER_Attribute
            END
         END
      END
   END

   // Include the ER Entity and ER_RelLink into the new LOD, if it wasn't done above.
   IF OldRecursiveLOD.ER_EntityRec EXISTS
      // We will check if we've already included the ER_EntityRec, as it may have been included above when the
      // RelLink was included.
      IF NewRecursiveLOD.ER_EntityRec DOES NOT EXIST
         SET CURSOR FIRST NewERD.ER_Entity WHERE NewERD.ER_Entity.Name = OldRecursiveLOD.ER_EntityRec.Name
         IF RESULT < zCURSOR_SET
            IssueError( NewRecursiveLOD,0,0, "Programming Include Error 1" )
            RETURN -1
         END
         INCLUDE NewRecursiveLOD.ER_EntityRec FROM NewERD.ER_Entity

         IF OldRecursiveLOD.ER_RelLinkRec EXISTS
            // It's complex to position on the correct RelType in the Target ERD, as there is no name.
            // Thus, we'll first position on the RelType in the Source ERD, and then position on the Target ERD by
            // RelLink Name and other ER_Entity Name.
            SET CURSOR FIRST SourceERD.ER_Entity WHERE SourceERD.ER_Entity.Name = OldRecursiveLOD.ER_EntityRec.Name
            SET CURSOR FIRST SourceERD.ER_RelType_1 WITHIN SourceERD.ER_Entity
                       WHERE SourceERD.ER_RelType_1.ZKey = OldRecursiveLOD.ER_RelTypeRec.ZKey
            SET CURSOR FIRST NewERD.ER_Entity_Other WITHIN NewERD.ER_Entity
                       WHERE NewERD.ER_Entity_Other.Name  = SourceERD.ER_Entity_Other.Name
                         AND NewERD.ER_RelLink_Other.Name = SourceERD.ER_RelLink_Other.Name
            IF RESULT < zCURSOR_SET
               IssueError( NewRecursiveLOD,0,0, "Programming Include Error 2" )
               RETURN -1
            END
            INCLUDE NewRecursiveLOD.ER_RelLinkRec FROM NewERD.ER_RelLink_Other
            IF NewRecursiveLOD.ER_RelTypeRec DOES NOT EXIST
               INCLUDE NewRecursiveLOD.ER_RelTypeRec FROM NewERD.ER_RelType_1
            END
         END
      END
   END

   //  Create each LOD Attribute
   FOR EACH OldRecursiveLOD.LOD_AttributeRec
      LOD_AttributeCopy( vSubtask,
                         NewMainLOD,
                         NewRecursiveLOD,
                         OldMainLOD,
                         OldRecursiveLOD,
                         SourceLPLR,
                         CurrentLPLR,
                         NewERD,
                         "Y" )

   END

   // Loop again through old LOD_Attribute entities and process DB_ER_AttributeRec entities.
   FOR EACH OldRecursiveLOD.LOD_AttributeRec
      // If DB_ER_AttributeRec exists in the old, include it in the new.
      IF  OldRecursiveLOD.DB_ER_AttributeRec EXISTS
         CreateViewFromViewForTask( TempLOD, NewRecursiveLOD, 0 )
         SET CURSOR FIRST NewRecursiveLOD.ER_AttributeRec WITHIN NewRecursiveLOD.LOD_EntityParent WHERE
              NewRecursiveLOD.ER_AttributeRec.Name = OldRecursiveLOD.ER_AttributeRec.Name
         SET CURSOR FIRST TempLOD.ER_AttributeRec WITHIN TempLOD.LOD_EntityParent WHERE
              TempLOD.ER_AttributeRec.Name = OldRecursiveLOD.DB_ER_AttributeRec.Name
         INCLUDE NewRecursiveLOD.DB_ER_AttributeRec FROM TempLOD.ER_AttributeRec
         DropView ( TempLOD )
      END
   END

   //  If OldRecursiveLOD.LOD_EntityConstraintOperRec exists, create a relationship to the
   //  corresponding operation in the new LOD.
   //  If the operation doesn't exist in the new LOD, ignore the LOD_EntityConstraintOperRec.
   IF OldRecursiveLOD.LOD_EntityConstraintOperRec EXISTS
      SET CURSOR FIRST NewMainLOD.Operation WITHIN NewMainLOD.LOD WHERE
                       NewMainLOD.Operation.Name = OldRecursiveLOD.LOD_EntityConstraintOperRec.Name
      IF RESULT >= zCURSOR_SET
         INCLUDE NewRecursiveLOD.LOD_EntityConstraintOperRec FROM NewMainLOD.Operation
      END
   END

   // Process any LOD_EntityChild entities recursively.
   // We need to make sure children are processed after parents are completed, because the children may need
   // the ER Entities processed by the parents.
   FOR EACH OldRecursiveLOD.LOD_EntityChild
      IF OldRecursiveLOD.ER_EntityRec EXISTS
         OrigParentName = OldRecursiveLOD.ER_EntityRec.Name
      ELSE
         OrigParentName = ""
      END
      SetViewToSubobject( OldRecursiveLOD, "LOD_EntityChild" )
      SetViewToSubobject( NewRecursiveLOD, "LOD_EntityChild" )

      nRC = LOD_EntityCopy( NewMainLOD,
                            NewRecursiveLOD,
                            OldMainLOD,
                            OldRecursiveLOD,
                            SourceLPLR,
                            CurrentLPLR,
                            NewERD,
                            SourceERD,
                            NewDTE,
                            vSubtask,
                            OrigParentName,
                            szAddER_EntityFlag )

      IF nRC < 0
         RETURN nRC
      ELSE
         IF nRC != 0        // Pass along Domain errors
            ErrorFlag = 1
         END
      END

      ResetViewFromSubobject( OldRecursiveLOD )
      ResetViewFromSubobject( NewRecursiveLOD )
   END

   Return ErrorFlag

END

/*************************************************************************************************
**
**    OPERATION: LOD_CreateER_Attribute
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_CreateER_Attribute( VIEW OldRecursiveLOD BASED ON LOD TZZOLODO,
                        VIEW SourceLPLR      BASED ON LOD TZCMLPLO,
                        VIEW CurrentLPLR     BASED ON LOD TZCMLPLO,
                        VIEW NewERD          BASED ON LOD TZEREMDO,
                        VIEW vSubtask )

   VIEW NewDomain BASED ON LOD TZDGSRCO
   SHORT nRC
   STRING ( 254)  szMsg

   // First make sure that the Domain exists.
   nRC = ActivateMetaOI_ByName( vSubtask, NewDomain, 0, zREFER_DOMAIN_META, zSINGLE, OldRecursiveLOD.DomainRec.Name, 0 )
   IF nRC < 0
      // The Domain was not found, so prompt User whether or not to add it.
      IF SourceLPLR != 0
         // There is a Source LPLR, so add the Domain
         DomainAddForMerge( NewDomain, SourceLPLR, CurrentLPLR,
                            CurrentLPLR.LPLR.wFullyQualifiedFileName,
                            OldRecursiveLOD.DomainRec.Name, vSubtask )
         IF nRC < 0
            RETURN nRC
         END
      ELSE
         // The Domain was not found, so give error and don't copy attribute.
         szMsg = "Domain (" + OldRecursiveLOD.DomainRec.Name + ") does not exist. Attribute (" +
                 OldRecursiveLOD.ER_AttributeRec.Name + ") will not be copied."
         MessageSend( vSubtask, "ZO00403", "Entity Copy", szMsg, zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
         RETURN -1   // Return indicating an error has occurred so the attribute will be dropped later.
      END
   END

   // Since the Domain was either found or created, continue with add of ER Attribute
   // Create ER Attribute from LOD Attribute. Create as last Attribute for Entity.
   SET CURSOR LAST NewERD.ER_Attribute
   CreateMetaEntity( vSubtask, NewERD, "ER_Attribute", zPOS_AFTER )
   SetMatchingAttributesByName ( NewERD,          "ER_Attribute",
                                 OldRecursiveLOD, "ER_AttributeRec", zSET_NULL )
   INCLUDE NewERD.Domain FROM NewDomain.Domain
   CurrentLPLR.LPLR.wMergeER_ModifiedFlag = "Y"    // Indicate that the ER has been modified.
   DropMetaOI( vSubtask, NewDomain )

END

/*************************************************************************************************
**
**    OPERATION: LOD_AttributeCopy
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_AttributeCopy( VIEW        vSubtask,
                   VIEW        NewMainLOD      BASED ON LOD TZZOLODO,
                   VIEW        NewRecursiveLOD BASED ON LOD TZZOLODO,
                   VIEW        OldMainLOD      BASED ON LOD TZZOLODO,
                   VIEW        OldRecursiveLOD BASED ON LOD TZZOLODO,
                   VIEW        SourceLPLR      BASED ON LOD TZCMLPLO,
                   VIEW        CurrentLPLR     BASED ON LOD TZCMLPLO,
                   VIEW        NewERD          BASED ON LOD TZEREMDO,
                   STRING ( 1 ) szAddER_AttributeFlag )

   VIEW NewDomain BASED ON LOD TZDGSRCO

   SHORT      ErrorFlag
   SHORT      FoundFlag
   SHORT      n
   SHORT      nRC
   STRING ( 254)  szMsg
   STRING ( 32 )  RelationshipName
   STRING ( 32 )  ERAttributeName
   STRING ( 32 )  DomainName

   CreateMetaEntity( vSubtask, NewRecursiveLOD, "LOD_AttributeRec", zPOS_AFTER )
       NewRecursiveLOD.LOD_AttributeRec.Work             = OldRecursiveLOD.LOD_AttributeRec.Work
       NewRecursiveLOD.LOD_AttributeRec.Update           = OldRecursiveLOD.LOD_AttributeRec.Update
       NewRecursiveLOD.LOD_AttributeRec.Init             = OldRecursiveLOD.LOD_AttributeRec.Init
       NewRecursiveLOD.LOD_AttributeRec.SeqPriority      = OldRecursiveLOD.LOD_AttributeRec.SeqPriority
       NewRecursiveLOD.LOD_AttributeRec.Hidden           = OldRecursiveLOD.LOD_AttributeRec.Hidden
       NewRecursiveLOD.LOD_AttributeRec.SeqOrder         = OldRecursiveLOD.LOD_AttributeRec.SeqOrder
       NewRecursiveLOD.LOD_AttributeRec.DIL_Text         = OldRecursiveLOD.LOD_AttributeRec.DIL_Text
       NewRecursiveLOD.LOD_AttributeRec.SeqNo_LOD_Entity = OldRecursiveLOD.LOD_AttributeRec.SeqNo_LOD_Entity
       NewRecursiveLOD.LOD_AttributeRec.DB_DerivedValue  = OldRecursiveLOD.LOD_AttributeRec.DB_DerivedValue

   IF OldRecursiveLOD.ER_AttributeRec EXISTS

      IF OldRecursiveLOD.LOD_AttributeRec.Work = "Y" OR
         OldRecursiveLOD.LOD_EntityParent.Work = "Y"

         CreateMetaEntity( vSubtask, NewRecursiveLOD, "ER_AttributeRec", zPOS_AFTER )
         SetMatchingAttributesByName ( NewRecursiveLOD, "ER_AttributeRec", OldRecursiveLOD,
                                       "ER_AttributeRec", zSET_NULL )
         IF OldRecursiveLOD.DomainRec EXISTS
            ErrorFlag = 1  // Initialize an error for Domain not found. If it is found, we'll reset it to 0.

            NAME VIEW CurrentLPLR "DomainCurrentLPLR"
            SET CURSOR FIRST CurrentLPLR.W_MetaType
                       WHERE CurrentLPLR.W_MetaType.Type = 2003

            // If there is a SourceLPLR, get the Domain Name from there.
            // Otherwise, use the Domain Name from the LOD.
            IF SourceLPLR = 0
               DomainName = OldRecursiveLOD.DomainRec.Name
               SET CURSOR FIRST CurrentLPLR.W_MetaDef
                          WHERE CurrentLPLR.W_MetaDef.Name = DomainName
               IF RESULT >= zCURSOR_SET
                  ErrorFlag = 0  // Indicate Domain found.
               END
            ELSE

               NAME VIEW SourceLPLR "DomainSourceLPLR"
               SET CURSOR FIRST SourceLPLR.W_MetaType
                          WHERE SourceLPLR.W_MetaType.Type = 2003
               SET CURSOR FIRST SourceLPLR.W_MetaDef
                          WHERE SourceLPLR.W_MetaDef.CPLR_ZKey = OldRecursiveLOD.DomainRec.ZKey
               IF RESULT >= zCURSOR_SET
                  DomainName = SourceLPLR.W_MetaDef.Name
                  SET CURSOR FIRST CurrentLPLR.W_MetaDef
                             WHERE CurrentLPLR.W_MetaDef.Name = DomainName
                  IF RESULT >= zCURSOR_SET
                     ErrorFlag = 0  // Indicate Domain found.
                  END
               END
            END
            IF ErrorFlag = 0
               ActivateMetaOI( vSubtask, NewDomain, CurrentLPLR, zREFER_DOMAIN_META, 0 )
               INCLUDE NewRecursiveLOD.DomainRec FROM NewDomain.Domain
               DropMetaOI( vSubtask, NewDomain )

            ELSE
               IF szAddER_AttributeFlag = "Y" AND SourceLPLR != 0
                  // The request is to add ER entities and Domains as necessary.
                  DomainAddForMerge( NewDomain, SourceLPLR, CurrentLPLR,
                                     CurrentLPLR.LPLR.wFullyQualifiedFileName,
                                     DomainName, vSubtask )
               ELSE
                  szMsg = "Domain (" + DomainName + ") does not exist."
                  MessageSend( vSubtask, "ZO00403", "Entity Copy",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
                  szMsg = "LOD (" + OldMainLOD.LOD.Name +
                          ") will not be migrated."
                  MessageSend( vSubtask, "ZO00404", "Entity Copy",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
               END
            END
         END

      ELSE
         // Include the ER Attr by name
         //  might fail if the ER attr was renamed without re-save of the LOD
         n = 0
         SET CURSOR FIRST NewERD.ER_Attribute
                    WHERE NewERD.ER_Attribute.Name = OldRecursiveLOD.ER_AttributeRec.Name
         IF RESULT < zCURSOR_SET
            // If the request is to add the ER Attribute, do so here.
            IF szAddER_AttributeFlag = "Y"
               // This is an ER Attribute so add it to ER.
               nRC = LOD_CreateER_Attribute( OldRecursiveLOD,
                                             SourceLPLR,
                                             CurrentLPLR,
                                             NewERD,
                                             vSubtask )
               IF nRC < 0
                  RETURN nRC
               END
            ELSE
               IF SourceLPLR = 0
                  // There is no SourceLPLR, so skip this step and indicate attribute was not found.
                  n = 2    // 1 and 2 are not found. 0 is found.
               ELSE
                  n = GetERAttributeName( SourceLPLR, OldRecursiveLOD, ERAttributeName )
               END
               IF n = 0
                  SET CURSOR FIRST NewERD.ER_Attribute
                             WHERE NewERD.ER_Attribute.Name = ERAttributeName
                  IF RESULT < zCURSOR_SET
                     n = 1
                  END
               END
            END
         END
         IF n = 0
            INCLUDE NewRecursiveLOD.ER_AttributeRec FROM NewERD.ER_Attribute
         ELSE
            // If the ER AttributeRec in the Source does not exist in the target, drop the LOD_AttributeRec entry.
            DELETE ENTITY NewRecursiveLOD.LOD_AttributeRec NONE
            //szMsg = "The following attribute in the Source E/R was not found in the Target E/R." +
            //  NEW_LINE + NEW_LINE + OldRecursiveLOD.ER_AttributeRec.Name
            //MessageSend( vSubtask, "ZO00406", "Entity Copy",
            //             szMsg,
            //             zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            //ErrorFlag = 1
         END
      END
   END

   //  If OldRecursiveLOD.LOD_AttrDerivationOperRec exists, create a relationship to the
   //  corresponding operation in the new LOD.
   //  If the operation doesn't exist in the new LOD, ignore the LOD_AttrDerivationOperRec.
   IF OldRecursiveLOD.LOD_AttrDerivationOperRec EXISTS

      SET CURSOR FIRST NewMainLOD.Operation WITHIN NewMainLOD.LOD WHERE
                       NewMainLOD.Operation.Name = OldRecursiveLOD.LOD_AttrDerivationOperRec.Name
      IF RESULT >= 0
         INCLUDE NewRecursiveLOD.LOD_AttrDerivationOperRec FROM NewMainLOD.Operation
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_RelinkDelete
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_RelinkDelete( VIEW vLOD BASED ON LOD TZZOLODO, VIEW vSubtask )

// The code below has some relink code commented out.  At this point I do not totally understand why.
// The original comment said it existed for test purposes, but this doesn't make sense to me now.
// We need to re-evaluate the commented code at some point.  I think it has something to do with the
// incomplete functionality or performance of RelinkInstanceToInstance. (DonC 8/11/95)

   VIEW        vERD         BASED ON LOD TZEREMDO
   VIEW        DomainLPLR   BASED ON LOD TZCMLPLO
   VIEW        vLPLR        BASED ON LOD TZCMLPLO
   VIEW        vDTE         BASED ON LOD TZTENVRO

   INTEGER     DeleteFlag
   INTEGER     nERD_Flag
   INTEGER     nDTE_Flag
   STRING (200) szMsg
   STRING (32)  szSourceName

   DeleteFlag = 0
   RetrieveViewForMetaList( vSubtask, vLPLR, zREFER_ERD_META )
   NAME VIEW vLPLR "vERD_LPLR"

   // Check if there is an ERD, because we will skip certain relinking if
   // there is not.
   IF vLPLR.W_MetaDef EXISTS
      nERD_Flag = ActivateMetaOI( vSubtask, vERD, vLPLR, zREFER_ERD_META, 0 )
   ELSE
      nERD_Flag = -1
   END

   DropView ( vLPLR )

   // Note that we are not relinking the vLOD.TE_DB_Environ entity, as this
   // is only necessary at XOD build, where it is already activated.

   // Relink subobjects against ERD.  This code should go away when a RelinkInstanceToInstance
   // operation is created that can reset include flags.
   IF nERD_Flag >= zCURSOR_SET
      RelinkAllSubobjectsForOI ( vLOD, "ER_RelLinkRec", vERD, "ER_RelLink_2" )
      RelinkAllSubobjectsForOI ( vLOD, "ER_AttributeRec", vERD, "ER_Attribute" )
   END

   RetrieveViewForMetaList( vSubtask, DomainLPLR, zREFER_DOMAIN_META )
   NAME VIEW DomainLPLR "DomainLPLR"

   // Relink Each LOD Entity and subordinate entities
   FOR EACH vLOD.LOD_Entity
      IF vLOD.ER_Entity EXISTS AND nERD_Flag >= zCURSOR_SET
         // The following relink is only done if there is an ERD
         SET CURSOR FIRST vERD.ER_Entity WHERE
             vERD.ER_Entity.ZKey = vLOD.ER_Entity.ZKey

         IF RESULT >= zCURSOR_SET
            RelinkInstanceToInstance( vLOD, "ER_Entity", vERD, "ER_Entity" )

            // Attributes
            fnRelinkAttributes( vSubtask, vLOD, vERD, DomainLPLR )

            // Relationship
            fnRelinkRelationships( vSubtask, vLOD, vERD )

         ELSE
            // No match on ER_Entity ZKey
            IF vLOD.LOD_Entity.Work = "Y"
               FOR EACH vLOD.LOD_Attribute
                  // Relink Domains for attributes under a work entity.
                  fnRelinkWorkAttrib( vLOD, DomainLPLR, vSubtask )
               END
            ELSE
               // If we are here, this must be an ER type LOD_Attribute with
               // no match on ER_Attribute ZKey.
               // Since there is no match on ZKey, try to find a match on
               // ER_Attribute name, in case the Attribute had been deleted
               // and recreated.
               SET CURSOR FIRST vERD.ER_Entity WHERE
                                vERD.ER_Entity.Name = vLOD.ER_Entity.Name
               IF RESULT >= zCURSOR_SET

                  // First reinclude the ER_Entity
                  EXCLUDE vLOD.ER_Entity
                  INCLUDE vLOD.ER_Entity FROM vERD.ER_Entity

                  // Attributes.
                  fnRelinkAttributes( vSubtask, vLOD, vERD, DomainLPLR )

                  // Relationships
                  fnRelinkRelationships( vSubtask, vLOD, vERD )

               ELSE
                  szMsg = "Deleting LOD Entity: " + vLOD.LOD_Entity.Name
                  MessageSend( vSubtask, "ZO00413", "LOD Relink",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
                  DELETE ENTITY vLOD.LOD_Entity NONE
                  DeleteFlag = 1
               END
            END
         END
      ELSE
         IF vLOD.LOD_Entity.Work = "Y"
            FOR EACH vLOD.LOD_Attribute
               // Relink Domains for attributes under a work entity.
               fnRelinkWorkAttrib( vLOD, DomainLPLR, vSubtask )
            END

         ELSE
            // Since this is not a work entity, it is an error to have a
            // LOD_Entity without a corresponding ER_Entity.
            // If this happens, there is some kind of Zeidon error.
            szMsg = "Deleting LOD Entity for logic error.| Entity: " +
                    vLOD.LOD_Entity.Name
            MessageSend( vSubtask, "ZO00414", "LOD Relink",
                         szMsg,
                         zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            DELETE ENTITY vLOD.LOD_Entity NONE
            DeleteFlag = 1
         END
      END
      // IF vLOD.ER_RelLink EXISTS
      //    relink ER_RelLink & ER_RelType
      // END
   END
   DropView ( DomainLPLR )
   IF nERD_Flag >= zCURSOR_SET
      DropMetaOI( vSubtask, vERD )
   END


   //BL, 2000.01.03 Relink TE
   RetrieveViewForMetaList( vSubtask, vLPLR, zREFER_DTE_META )
   NAME VIEW vLPLR "vDTE_LPLR"

   // Check if there is an DTE, because we will skip certain relinking if
   // there is not.
   IF vLPLR.W_MetaDef EXISTS
      nDTE_Flag = ActivateMetaOI( vSubtask, vDTE, vLPLR, zREFER_DTE_META, 0 )
   ELSE
      nDTE_Flag = -1
   END

   DropView ( vLPLR )

   // Relink subobjects against DTE.  This code should go away when a RelinkInstanceToInstance
   // operation is created that can reset include flags.
   IF nDTE_Flag >= zCURSOR_SET
      // The relink below may cause the vLOD.POD.TE_SourceZKey value to become invalid.
      // This could occur because a DBMS_Source entry was deleted and recreated. We will
      // thus save the DBMS_Source name for the vLOD.POD.TE_SourceZKey value to alter the
      // value as necessary.
      IF vLOD.POD EXISTS
         SET CURSOR FIRST vLOD.TE_DBMS_Source
             WHERE vLOD.TE_DBMS_Source.ZKey = vLOD.POD.TE_SourceZKey
         szSourceName = vLOD.TE_DBMS_Source.Name
         RelinkAllSubobjectsForOI ( vLOD, "TE_DB_Environ", vDTE, "TE_DB_Environ" )
         SET CURSOR FIRST vLOD.TE_DBMS_Source
             WHERE vLOD.TE_DBMS_Source.ZKey = vLOD.POD.TE_SourceZKey
         IF RESULT < zCURSOR_SET
            SET CURSOR FIRST vLOD.TE_DBMS_Source
                WHERE vLOD.TE_DBMS_Source.Name = szSourceName
            IF RESULT >= zCURSOR_SET
               vLOD.POD.TE_SourceZKey = vLOD.TE_DBMS_Source.ZKey
            END
         END
      END
   END

   IF nDTE_Flag >= zCURSOR_SET
      DropMetaOI( vSubtask, vDTE )
   END

END


LOCAL OPERATION
fnRelinkWorkAttrib( VIEW vLOD       BASED ON LOD TZZOLODO,
                    VIEW DomainLPLR BASED ON LOD TZCMLPLO,
                    VIEW vSubtask )

   VIEW  DomainLPLR2  BASED ON LOD TZCMLPLO
   VIEW  vDomain      BASED ON LOD TZDGSRCO

   // Relink Domains for attributes under a work entity.
   IF vLOD.Domain  EXISTS
      SET CURSOR FIRST DomainLPLR.W_MetaDef WHERE
          DomainLPLR.W_MetaDef.CPLR_ZKey = vLOD.Domain.ZKey
      IF RESULT = zCURSOR_SET
         CreateViewFromViewForTask( DomainLPLR2, DomainLPLR, 0 )
         ActivateMetaOI( vSubtask, vDomain, DomainLPLR2, zREFER_DOMAIN_META, 0 )
         DropView ( DomainLPLR2 )
         RelinkInstanceToInstance( vLOD, "Domain", vDomain, "Domain" )
         DropMetaOI( vSubtask, vDomain )

      ELSE
         SET CURSOR FIRST DomainLPLR.W_MetaDef WHERE
             DomainLPLR.W_MetaDef.Name = vLOD.Domain.Name
         IF RESULT < zCURSOR_SET
            SET CURSOR FIRST DomainLPLR.W_MetaDef WHERE
                DomainLPLR.W_MetaDef.Name = "Text"
         END
         IF RESULT = zCURSOR_SET
            CreateViewFromViewForTask( DomainLPLR2, DomainLPLR, 0 )
            ActivateMetaOI( vSubtask, vDomain, DomainLPLR2, zREFER_DOMAIN_META, 0 )
            DropView( DomainLPLR2 )
            EXCLUDE vLOD.Domain
            INCLUDE vLOD.Domain FROM vDomain.Domain
            DropMetaOI( vSubtask, vDomain )
        ELSE
            // If the Domain isn't in LPLR, it must have been deleted.  Thereby
            // exclude the Domain entity.  We'll leave the LOD_Attribute without
            // any Domain.
            MessageSend( vSubtask, "ZO00412", "LOD Relink",
                         "Excluding Domain",
                         zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            EXCLUDE vLOD.Domain
         END
      END
   END

END


ENTITY CONSTRAINT OPERATION
AttributeConstraints( VIEW   vLOD BASED ON LOD TZZOLODO,
                      STRING ( 32 ) sEntityName,
                      SHORT Event,
                      SHORT State )

   STRING (32) szValue
   SHORT  nRC

   CASE Event
   OF   zECE_ACCEPT:

        TraceLineS( "DGC Accept constraint entity = ", sEntityName )

        // Validate that there are no two attributes with the same name.
        GetStringFromAttribute ( szValue, vLOD, "ER_Attribute", "Name" )
        nRC = CheckDuplicateEntityByString( vLOD, "ER_Attribute", "Name", szValue, "LOD_Entity" )
        IF nRC < 0
           MessageSend( vLOD, "ZO00415", "Zeidon Object Maintenance",
                        "Duplicate Attribute for Entity",
                        zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
           RETURN -1
        END

        // Don't allow a derived operation on an attribute that was
        // derived at the ER level (ie., has a DerivedExpression value that
        // isn't null.
        IF vLOD.ER_Attribute.DerivedExpression != "" AND
           vLOD.LOD_AttrDerivationOper EXISTS

           MessageSend( vLOD, "ZO00416", "Zeidon Object Maintenance",
                        "A Derived Operation is not valid if ER Entity is a Derived Expression.",
                        zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
           RETURN -1
        END

        // If insert new Attribute, then set new Attribute Sequence
        NewAttributeSequence( vLOD )

        /* end zECE_ACCEPT */
   OF   zECE_CANCEL:

        /* end zECE_CANCEL */
   OF   zECE_CREATE:

        /* end zECE_CREATE */
   OF   zECE_DELETE:

        // If delete Attribute, then set new Attribute Sequence
        DelAttribFromSequence( vLOD )

        /* end zECE_DELETE */
   OF   zECE_EXCLUDE:

        /* end zECE_EXCLUDE */
   OF   zECE_INCLUDE:

        /* end zECE_INCLUDE */
   END  /* case */

END

/*************************************************************************************************
**
**    OPERATION: fnLocateParentName
**
**
*************************************************************************************************/
LOCAL OPERATION
fnLocateParentName( VIEW vRecursLOD BASED ON LOD TZZOLODO,
                    INTEGER RelationshipZKey,
                    INTEGER ChildEntityZKey,
                    STRING ( 32 ) ReturnedParentName )

   VIEW vParentLOD BASED ON LOD TZZOLODO

   // Recursive routine to locate the parent entity name for a particular RelationshipName and
   // ChildEntityName.
   // Keep searching recursively until there is a match on entity name and relationship name.
   // When a match is found, get the entity name of the parent and return.
   FOR EACH vRecursLOD.LOD_EntityParent

      // Evaluate each LOD_EntityParent
      IF vRecursLOD.ER_RelLinkRec EXISTS
         IF vRecursLOD.LOD_EntityParent.ZKey = ChildEntityZKey AND
            vRecursLOD.ER_RelLinkRec.ZKey    = RelationshipZKey

            CreateViewFromViewForTask( vParentLOD, vRecursLOD, 0 )
            ResetViewFromSubobject( vParentLOD )
            ReturnedParentName = vParentLOD.ER_EntityRec.Name
            DropView( vParentLOD )
            RETURN 0
         END
      END

      // Process LOD_EntityChild subobjects
      IF vRecursLOD.LOD_EntityChild EXISTS
         SetViewToSubobject( vRecursLOD, "LOD_EntityChild" )
         fnLocateParentName( vRecursLOD,
                             RelationshipZKey,
                             ChildEntityZKey,
                             ReturnedParentName )
         ResetViewFromSubobject( vRecursLOD )
         IF ReturnedParentName != ""
            RETURN 0
         END
      END

   END

END

/*************************************************************************************************
**
**    OPERATION: fnRelinkAttributes
**
**
*************************************************************************************************/
LOCAL OPERATION
fnRelinkAttributes( VIEW vSubtask,
                    VIEW vLOD       BASED ON LOD TZZOLODO,
                    VIEW vERD       BASED ON LOD TZEREMDO,
                    VIEW DomainLPLR BASED ON LOD TZCMLPLO )

   INTEGER      DeleteFlag
   INTEGER      nRemapFlag
   STRING (200) szMsg

   FOR EACH vLOD.LOD_Attribute
      IF vLOD.ER_Attribute EXISTS
         SET CURSOR FIRST vERD.ER_Attribute WHERE
                 vERD.ER_Attribute.ZKey = vLOD.ER_Attribute.ZKey
         IF RESULT >= zCURSOR_SET
            //RelinkInstanceToInstance( vLOD, "ER_Attribute", vERD, "ER_Attribute" )
            //RelinkInstanceToInstance( vLOD, "Domain", vERD, "Domain" )
         ELSE
            IF vLOD.LOD_Attribute.Work = "Y"
               // Relink Domains for work attributes.
               fnRelinkWorkAttrib( vLOD, DomainLPLR, vSubtask )

            ELSE
               // Since there was no match on ZKey, try to find a match on ER Entity
               // name and ER Attribute name, in case the Attribute had been deleted
               // and recreated.  In this case, re-include the Attribute.
               SET CURSOR FIRST vERD.ER_Entity WHERE
                                vERD.ER_Entity.Name = vLOD.ER_Entity.Name
               IF RESULT >= zCURSOR_SET
                  SET CURSOR FIRST vERD.ER_Attribute WHERE
                                   vERD.ER_Attribute.Name = vLOD.ER_Attribute.Name
                  IF RESULT >= zCURSOR_SET
                     nRemapFlag = 0
                     EXCLUDE vLOD.ER_Attribute
                     INCLUDE vLOD.ER_Attribute FROM vERD.ER_Attribute
                  ELSE
                     nRemapFlag = -1
                  END
               ELSE
                  nRemapFlag = -1
               END
               IF nRemapFlag = -1
                  szMsg = "Deleting LOD Entity/Attribute: " +
                          vLOD.LOD_Entity.Name + "/" + vLOD.ER_Attribute.Name
                  MessageSend( vSubtask, "ZO00410", "LOD Relink",
                               szMsg,
                               zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
                  DELETE ENTITY vLOD.LOD_Attribute NONE
                  DeleteFlag = 1
               END
            END
         END
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: fnRelinkRelationships
**
*************************************************************************************************/
LOCAL OPERATION
fnRelinkRelationships( VIEW vSubtask,
                       VIEW vLOD BASED ON LOD TZZOLODO,
                       VIEW vERD BASED ON LOD TZEREMDO )

   STRING (32) ReturnedParentName
   INTEGER     RelationshipZKey
   INTEGER     ChildEntityZKey
   STRING (200) szMsg

   FOR EACH vLOD.ER_RelLink
      SET CURSOR FIRST vERD.ER_RelLink_Other WITHIN vERD.ER_Entity WHERE
          vERD.ER_RelLink_Other.ZKey = vLOD.ER_RelLink.ZKey
      IF RESULT < zCURSOR_SET
         // There is no match on ZKey, so try to match on Relationship name.
         // If a match, re-include. If not, give error message.
         // This is going to require locating the parent entity name by looking
         // through the recursive subobject structure.
         RelationshipZKey = vLOD.ER_RelLink.ZKey
         ChildEntityZKey  = vLOD.LOD_Entity.ZKey
         SetViewToSubobject( vLOD, "LOD_EntityChild" )
         ReturnedParentName = ""
         fnLocateParentName( vLOD,
                             RelationshipZKey,
                             ChildEntityZKey,
                             ReturnedParentName )
         ResetViewFromSubobject( vLOD )
         SET CURSOR FIRST vERD.ER_RelLink_Other WITHIN vERD.ER_Entity WHERE
             vERD.ER_RelLink_Other.Name = vLOD.ER_RelLink.Name AND
             vERD.ER_Entity_Other.Name  = ReturnedParentName
         IF RESULT >= zCURSOR_SET
            SET CURSOR FIRST vERD.ER_RelLink_2 WITHIN vERD.EntpER_Model
                 WHERE vERD.ER_RelLink_2.ZKey = vERD.ER_RelLink_Other.ZKey
            EXCLUDE vLOD.ER_RelLink
            INCLUDE vLOD.ER_RelLink FROM vERD.ER_RelLink_2
         ELSE
            szMsg = "There is no entity/relationship name match in the ERD for LOD " +
                    vLOD.LOD.Name + ", with relationship: " + NEW_LINE +
                    ReturnedParentName + "  " +
                    vLOD.ER_RelLink.Name + "  " +
                    vLOD.ER_Entity.Name + NEW_LINE +
                    "The LOD Entity will be deleted."
            MessageSend( vSubtask, "ZO00410", "LOD Relink",
                         szMsg,
                         zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            DELETE ENTITY vLOD.LOD_Entity
         END
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: SetAttributeSequence
**
**    set Attribute Sequence for LOD's without Attribute Sequence
**
*************************************************************************************************/
TRANSFORMATION OPERATION
SetAttributeSequence( VIEW vTZZOLODO BASED ON LOD TZZOLODO )

  VIEW vTZZOLODO_Copy BASED ON LOD TZZOLODO
  INTEGER lSequence

  CreateViewFromViewForTask( vTZZOLODO_Copy, vTZZOLODO, 0 )

  FOR EACH vTZZOLODO_Copy.LOD_Entity
      lSequence = 1
      FOR EACH vTZZOLODO_Copy.LOD_Attribute
          FOR EACH vTZZOLODO_Copy.ER_Attribute
              vTZZOLODO_Copy.LOD_Attribute.wkSequence = lSequence
              lSequence = lSequence + 1
          END
      END
  END

  DropView( vTZZOLODO_Copy )

END

/*************************************************************************************************
**
**    OPERATION: NewAttributeSequence
**
**    if insert new Attribute, then set new Attribute Sequence
**
*************************************************************************************************/
TRANSFORMATION OPERATION
NewAttributeSequence( VIEW vTZZOLODO BASED ON LOD TZZOLODO )
   VIEW    vTZZOLODO_Copy BASED ON LOD TZZOLODO
   INTEGER lSequenceNo
   INTEGER lNewSequenceNo

   IF vTZZOLODO.LOD_Attribute.wkSequence = ""

      CreateViewFromViewForTask( vTZZOLODO_Copy, vTZZOLODO, 0 )

      // set cursor on previous attribute and get the sequence number
      SET CURSOR PREVIOUS vTZZOLODO_Copy.LOD_Attribute
      IF RESULT = zCURSOR_SET
         lSequenceNo = vTZZOLODO_Copy.LOD_Attribute.wkSequence
         lSequenceNo = lSequenceNo + 1
      ELSE
         lSequenceNo = 1
      END

      // set new sequence number for the attribute with greater number
      FOR EACH vTZZOLODO_Copy.LOD_Attribute
          IF vTZZOLODO_Copy.LOD_Attribute.wkSequence >= lSequenceNo
             lNewSequenceNo = vTZZOLODO_Copy.LOD_Attribute.wkSequence
             lNewSequenceNo = lNewSequenceNo + 1
             vTZZOLODO_Copy.LOD_Attribute.wkSequence = lNewSequenceNo
         END
      END

      // set sequence number for new attribute
      vTZZOLODO.LOD_Attribute.wkSequence = lSequenceNo

      DropView( vTZZOLODO_Copy )

   END
END

/*************************************************************************************************
**
**    OPERATION: DelAttribFromSequence
**
**    if delete Attribute, then set new Attribute Sequence
**
*************************************************************************************************/
TRANSFORMATION OPERATION
DelAttribFromSequence( VIEW vTZZOLODO BASED ON LOD TZZOLODO )
   VIEW    vTZZOLODO_Copy BASED ON LOD TZZOLODO
   INTEGER lSequenceNo
   INTEGER lNewSequenceNo

   IF vTZZOLODO.LOD_Attribute.wkSequence > 0

      CreateViewFromViewForTask( vTZZOLODO_Copy, vTZZOLODO, 0 )

      lSequenceNo = vTZZOLODO.LOD_Attribute.wkSequence

      // set new sequence number for the attribute with greater number
      FOR EACH vTZZOLODO_Copy.LOD_Attribute
          IF vTZZOLODO_Copy.LOD_Attribute.wkSequence > lSequenceNo
             lNewSequenceNo = vTZZOLODO_Copy.LOD_Attribute.wkSequence
             lNewSequenceNo = lNewSequenceNo - 1
             vTZZOLODO_Copy.LOD_Attribute.wkSequence = lNewSequenceNo
         END
      END

      DropView( vTZZOLODO_Copy )

   END
END

/*************************************************************************************************
**
**    OPERATION: SortAttributes
**
**
*************************************************************************************************/
TRANSFORMATION OPERATION
SortAttributes( VIEW vTZZOLODO BASED ON LOD TZZOLODO )

   VIEW vTZZOLODO_Copy BASED ON LOD TZZOLODO

   CreateViewFromViewForTask( vTZZOLODO_Copy, vTZZOLODO, 0 )
   FOR EACH vTZZOLODO_Copy.LOD_Entity
       IF vTZZOLODO.LOD_Attribute EXISTS AND vTZZOLODO.LOD_Attribute.wkSequence > 0
          OrderEntityForView( vTZZOLODO_Copy, "LOD_Attribute", "wkSequence A" )
       END
   END
   DropView( vTZZOLODO_Copy )
END

/*************************************************************************************************
**
**    OPERATION: MoveAttribInSequence
**
**    move Attribute from a Sequence No to a other Sequence No
**
*************************************************************************************************/
TRANSFORMATION OPERATION
MoveAttribInSequence( VIEW vTZZOLODO BASED ON LOD TZZOLODO )
   VIEW    vTZZOLODO_Copy BASED ON LOD TZZOLODO
   INTEGER lNewSequenceNo

   CreateViewFromViewForTask( vTZZOLODO_Copy, vTZZOLODO, 0 )
   // tmv
   lNewSequenceNo = 1
   // set new sequence number for the attribute with greater number
   FOR EACH vTZZOLODO_Copy.LOD_Attribute
       vTZZOLODO_Copy.LOD_Attribute.wkSequence = lNewSequenceNo
       lNewSequenceNo = lNewSequenceNo + 1
   END

   DropView( vTZZOLODO_Copy )

END

/*************************************************************************************************
**
**    OPERATION: GetRelationshipName
**
**    get the relationship name from old ERD
**
*************************************************************************************************/
LOCAL OPERATION
GetRelationshipName( VIEW SourceLPLR BASED ON LOD TZCMLPLO,
                     VIEW OldLOD BASED ON LOD TZZOLODO,
                     STRING ( 32 ) RelationshipName,
                     STRING( 32) ParentName )

   VIEW vOldER      BASED ON LOD TZEREMDO
   VIEW SourceLPLR2 BASED ON LOD TZCMLPLO
   STRING ( 513 ) SourceFileName            // zMAX_FILESPEC_LTH+1

   CreateViewFromViewForTask( SourceLPLR2, SourceLPLR, 0 )
   SET CURSOR FIRST SourceLPLR2.W_MetaType
     WHERE SourceLPLR2.W_MetaType.Type = 2004 // zREFER_ERD_META

   IF RESULT < zCURSOR_SET
      DropView( SourceLPLR2 )
      RETURN 1
   END

   SourceFileName = SourceLPLR2.LPLR.MetaSrcDir + "\" + SourceLPLR2.W_MetaDef.Name + ".PMD"
   ActivateOI_FromFile ( vOldER, "TZEREMDO", SourceLPLR, SourceFileName, 8192 )
   DropView( SourceLPLR2 )

   SET CURSOR FIRST vOldER.ER_Entity_2 WITHIN vOldER.EntpER_Model WHERE
           vOldER.ER_Entity_2.Name = ParentName AND
           vOldER.ER_RelLink_2.ZKey = OldLOD.ER_RelLinkRec.ZKey

   IF RESULT < zCURSOR_SET
      DropObjectInstance( vOldER )
      RETURN 2
   END

   RelationshipName = vOldER.ER_RelLink_2.Name
   DropObjectInstance( vOldER )
   RETURN 0
END

/*************************************************************************************************
**
**    OPERATION: GetERAttributeName
**
**    get the ER attribute name from old ERD
**
*************************************************************************************************/
LOCAL OPERATION
GetERAttributeName( VIEW SourceLPLR BASED ON LOD TZCMLPLO,
                    VIEW OldLOD BASED ON LOD TZZOLODO,
                    STRING ( 32 ) ERAttributeName )

   VIEW vOldER      BASED ON LOD TZEREMDO
   VIEW SourceLPLR2 BASED ON LOD TZCMLPLO
   STRING ( 513 ) SourceFileName            // zMAX_FILESPEC_LTH+1

   CreateViewFromViewForTask( SourceLPLR2, SourceLPLR, 0 )
   SET CURSOR FIRST SourceLPLR2.W_MetaType
     WHERE SourceLPLR2.W_MetaType.Type = 2004 // zREFER_ERD_META

   IF RESULT < zCURSOR_SET
      DropView( SourceLPLR2 )
      RETURN 1
   END

   SourceFileName = SourceLPLR2.LPLR.MetaSrcDir + "\" + SourceLPLR2.W_MetaDef.Name + ".PMD"
   ActivateOI_FromFile ( vOldER, "TZEREMDO", SourceLPLR, SourceFileName, 8192 )
   DropView( SourceLPLR2 )

   SET CURSOR FIRST vOldER.ER_Attribute WITHIN vOldER.EntpER_Model WHERE
           vOldER.ER_Attribute.ZKey = OldLOD.ER_AttributeRec.ZKey

   IF RESULT < zCURSOR_SET
      DropObjectInstance( vOldER )
      RETURN 2
   END

   ERAttributeName = vOldER.ER_Attribute.Name
   DropObjectInstance( vOldER )
   RETURN 0
END

/*************************************************************************************************
**
**    OPERATION: dAttributeTextMapName
**
**
*************************************************************************************************/
DERIVED ATTRIBUTE OPERATION
dAttributeTextMapName( VIEW TZZOLODO BASED ON LOD TZZOLODO,
                       STRING ( 32 ) InternalEntityStructure,
                       STRING ( 32 ) InternalAttribStructure,
                       SHORT GetOrSetFlag )

   STRING ( 50 ) szTextMapName

   CASE GetOrSetFlag
   OF   zDERIVED_GET:

   szTextMapName = "[Z:" +
                   TZZOLODO.LOD_Entity.Name + "." +
                   TZZOLODO.ER_Attribute.Name + "]"
   StoreStringInRecord( TZZOLODO,
                        InternalEntityStructure,
                        InternalAttribStructure,
                        szTextMapName )

        /* end zDERIVED_GET */
   OF   zDERIVED_SET:

        /* end zDERIVED_SET */
   END  /* case */

END

/*************************************************************************************************
**
**    OPERATION: LOD_Compare
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_Compare( VIEW TargetLOD BASED ON LOD TZZOLODO,
             VIEW SourceLOD BASED ON LOD TZZOLODO )

   VIEW TargetLOD_Root BASED ON LOD TZZOLODO
   STRING ( 1 ) szSecondLineFlag
   INTEGER      AttributeCount

   // Compare the Source LOD to the Target LOD, formatting the difference in the Target LOD.

   // First make sure we delete any previous work entries.
   FOR EACH TargetLOD.CompareEntityResult
      DELETE ENTITY TargetLOD.CompareEntityResult NONE
   END
   FOR EACH TargetLOD.CompareOperationResult
      DELETE ENTITY TargetLOD.CompareOperationResult NONE
   END

   // Go to process LOD_Entity/LOD_Attribute differences.
   CreateViewFromView( TargetLOD_Root, TargetLOD )
   NAME VIEW TargetLOD_Root "TargetLOD_Root"

   LOD_CompareReus( TargetLOD, SourceLOD, TargetLOD_Root, "" )

   DropView( TargetLOD_Root )

   // Compare Operations and Parameters.
   LOD_CompareOperations( TargetLOD, SourceLOD )

   // Remove any Result entries that do not show a difference.
   FOR EACH TargetLOD.CompareEntityResult
      FOR EACH TargetLOD.CompareAttributeResult
         IF TargetLOD.CompareAttributeResult.DifferenceFlag = ""
            // Delete Attribute entries that don't show a difference.
            DELETE ENTITY TargetLOD.CompareAttributeResult NONE
         END
      END
      SET CURSOR FIRST TargetLOD.CompareAttributeResult
      IF RESULT < zCURSOR_SET AND TargetLOD.CompareEntityResult.DifferenceFlag = ""
         // Delete Entity entries that don't show a difference and don't have Attributes with a difference.
         DELETE ENTITY TargetLOD.CompareEntityResult NONE
      END
   END

   // Build the Display entries for Entity and Attribute.
   // First delete current entries.
   FOR EACH TargetLOD.DisplayCompareResult
      DELETE ENTITY TargetLOD.DisplayCompareResult NONE
   END
   // Build new entries.
   FOR EACH TargetLOD.CompareEntityResult

      // Build Entity Differences
      CREATE ENTITY TargetLOD.DisplayCompareResult
      TargetLOD.DisplayCompareResult.EntityAttributeType = "E"
      TargetLOD.DisplayCompareResult.MetaID = TargetLOD.CompareEntityResult.EntityID
      IF TargetLOD.CompareEntityResult.DifferenceFlag = "T"
         // Entity exists in Target, but not in Source.
         TargetLOD.DisplayCompareResult.TargetEntityName = TargetLOD.CompareEntityResult.EntityName
         TargetLOD.DisplayCompareResult.Difference       = "Target Entity not in Source"
      ELSE
         IF TargetLOD.CompareEntityResult.DifferenceFlag = "S"
            // Entity exists in Source, but not in Target.
            TargetLOD.DisplayCompareResult.SourceEntityName = TargetLOD.CompareEntityResult.EntityName
            TargetLOD.DisplayCompareResult.Difference       = "Source Entity not in Target"
         ELSE
            // If we get to here, always display Source Entity Name.
            TargetLOD.DisplayCompareResult.SourceEntityName = TargetLOD.CompareEntityResult.EntityName
            IF TargetLOD.CompareEntityResult.DifferenceFlag = "D"
               // There is a difference in the two Entities.
               IF TargetLOD.CompareEntityResult.TargetDifferentName != ""
                  // There is a difference in names.
                  TargetLOD.DisplayCompareResult.TargetEntityName = TargetLOD.CompareEntityResult.TargetDifferentName
                  TargetLOD.DisplayCompareResult.Difference = "Name Change"
               END
               IF TargetLOD.CompareEntityResult.SourceDifferentPermissions != "" OR
                  TargetLOD.CompareEntityResult.TargetDifferentPermissions != ""

                  TargetLOD.DisplayCompareResult.Difference = "Permissions: " +
                                                              TargetLOD.CompareEntityResult.SourceDifferentPermissions + " : " +
                                                              TargetLOD.CompareEntityResult.TargetDifferentPermissions
               END
            END
         END
      END

      // Build Attribute Differences.
      AttributeCount = 0
      FOR EACH TargetLOD.CompareAttributeResult
         AttributeCount = AttributeCount + 1
         IF AttributeCount > 1 OR TargetLOD.DisplayCompareResult.Difference != ""
            // Don't create display entry for first attribute, unless the Entity had a difference.
            // This will put attribute data on entity display entry when there are only attribute differences.
            CREATE ENTITY TargetLOD.DisplayCompareResult
         END
         TargetLOD.DisplayCompareResult.EntityAttributeType   = "A"
         TargetLOD.DisplayCompareResult.MetaID = TargetLOD.CompareAttributeResult.AttributeID

         IF TargetLOD.CompareAttributeResult.DifferenceFlag = "T"
            // Attribute exists in Target, but not in Source.
            TargetLOD.DisplayCompareResult.TargetAttributeName = TargetLOD.CompareAttributeResult.AttributeName
            TargetLOD.DisplayCompareResult.Difference          = "Target Attribute not in Source"
            //TargetLOD.DisplayCompareResult.TargetEntityName    = TargetLOD.CompareEntityResult.EntityName
         ELSE
            //TargetLOD.DisplayCompareResult.SourceEntityName = TargetLOD.CompareEntityResult.EntityName
            IF TargetLOD.CompareAttributeResult.DifferenceFlag = "S"
               // Attribute exists in Source, but not in Target.
               TargetLOD.DisplayCompareResult.SourceAttributeName = TargetLOD.CompareAttributeResult.AttributeName
               TargetLOD.DisplayCompareResult.Difference          = "Source Attribute not in Target"
            ELSE
               // If we get to here, always display Source Entity Name.
               TargetLOD.DisplayCompareResult.SourceAttributeName = TargetLOD.CompareAttributeResult.AttributeName

               // The current line will only reflect one type of difference. If there are other differences, they will each
               // generate an additional line without Source Name or Target Name.
               // Permissions
               IF TargetLOD.CompareAttributeResult.SourceDifferentPermissions != "" OR
                  TargetLOD.CompareAttributeResult.TargetDifferentPermissions != ""

                  TargetLOD.DisplayCompareResult.Difference = "Permissions: " +
                                                              TargetLOD.CompareAttributeResult.SourceDifferentPermissions + " : " +
                                                              TargetLOD.CompareAttributeResult.TargetDifferentPermissions
                  szSecondLineFlag = "Y"
               END
               // Operation
               IF TargetLOD.CompareAttributeResult.SourceDifferentOperationName != "" OR
                  TargetLOD.CompareAttributeResult.TargetDifferentOperationName != ""

                  IF szSecondLineFlag = "Y"
                     CREATE ENTITY TargetLOD.DisplayCompareResult
                  END
                  TargetLOD.DisplayCompareResult.Difference = "Operation: " +
                                                              TargetLOD.CompareAttributeResult.SourceDifferentOperationName + " : " +
                                                              TargetLOD.CompareAttributeResult.TargetDifferentOperationName
                  szSecondLineFlag = "Y"
               END
               // Domain
               IF TargetLOD.CompareAttributeResult.SourceDifferentDomainName != "" OR
                  TargetLOD.CompareAttributeResult.TargetDifferentDomainName != ""

                  IF szSecondLineFlag = "Y"
                     CREATE ENTITY TargetLOD.DisplayCompareResult
                  END
                  TargetLOD.DisplayCompareResult.Difference = "Domain: " +
                                                              TargetLOD.CompareAttributeResult.SourceDifferentDomainName + " : " +
                                                              TargetLOD.CompareAttributeResult.TargetDifferentDomainName
                  szSecondLineFlag = "Y"
               END
               // String Length
               IF TargetLOD.CompareAttributeResult.SourceDifferentStringLength != "" OR
                  TargetLOD.CompareAttributeResult.TargetDifferentStringLength != ""

                  IF szSecondLineFlag = "Y"
                     CREATE ENTITY TargetLOD.DisplayCompareResult
                  END
                  TargetLOD.DisplayCompareResult.Difference = "Str Lth: " +
                                                              TargetLOD.CompareAttributeResult.SourceDifferentStringLength + " : " +
                                                              TargetLOD.CompareAttributeResult.TargetDifferentStringLength
                  szSecondLineFlag = "Y"
               END
            END
         END


      END

   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_CompareReus
**
*************************************************************************************************/
LOCAL OPERATION
LOD_CompareReus( VIEW TargetLOD      BASED ON LOD TZZOLODO,
                 VIEW SourceLOD      BASED ON LOD TZZOLODO,
                 VIEW TargetLOD_Root BASED ON LOD TZZOLODO,
                 STRING ( 1000 ) szParentNames )

   STRING ( 1000 ) szNewParentNames
   STRING ( 1 )    szER_EntityFound
   STRING ( 32 )   szSourceEntityName
   STRING ( 32 )   szTargetEntityName

   // Compare LOD's at current level.

   // First try to match the Source entries to the Target Entries.
   FOR EACH SourceLOD.LOD_EntityParent

      // Create compare entry
      CREATE ENTITY TargetLOD_Root.CompareEntityResult
      TargetLOD_Root.CompareEntityResult.EntityName = SourceLOD.LOD_EntityParent.Name
      TargetLOD_Root.CompareEntityResult.EntityID   = SourceLOD.LOD_EntityParent.ZKey

      // If the Source Entity is a work entity (ie., not tied to an ER_Entity), look for a match on name.
      // If the Source Entity is an ER Entity, find a match on ER Entity Name.
      IF SourceLOD.ER_EntityRec EXISTS AND SourceLOD.ER_RelLinkRec EXISTS
         // This is an ER Entity. We can't do a simple set cursor so we'll loop through entries for a match.
         szER_EntityFound = ""
         SET CURSOR FIRST TargetLOD.LOD_EntityParent
         LOOP WHILE RESULT >= zCURSOR_SET AND szER_EntityFound = ""
            // Compare ER_Entities.
            IF TargetLOD.ER_EntityRec EXISTS AND TargetLOD.ER_RelLinkRec EXISTS
               IF TargetLOD.ER_EntityRec.Name  = SourceLOD.ER_EntityRec.Name AND
                  TargetLOD.ER_RelLinkRec.Name = SourceLOD.ER_RelLinkRec.Name

                  szER_EntityFound = "Y"
               END
            END
            // Set next cursor if we haven't found a match.
            IF szER_EntityFound = ""
               SET CURSOR NEXT TargetLOD.LOD_EntityParent
            END
         END
         IF szER_EntityFound = "Y"
            // Set szSourceEntityName and szTargetEntityName, if the LOD Entity Name has changed.
            IF TargetLOD.LOD_EntityParent.Name = SourceLOD.LOD_EntityParent.Name
               szSourceEntityName = ""
               szTargetEntityName = ""
            ELSE
               szSourceEntityName = SourceLOD.LOD_EntityParent.Name
               szTargetEntityName = TargetLOD.LOD_EntityParent.Name
               TargetLOD_Root.CompareEntityResult.DifferenceFlag = "D"
            END

            RESULT = 0     // This forces the equal case below.
         ELSE
            RESULT = -1
         END
      ELSE
         // This is a work entity so just do set cursor on LOD Entity Name.
         SET CURSOR FIRST TargetLOD.LOD_EntityParent
                    WHERE TargetLOD.LOD_EntityParent.Name = SourceLOD.LOD_EntityParent.Name
         // We don't use szSourceEntityName or szTargetEntityName in this case, so just null them.
         szSourceEntityName = ""
         szTargetEntityName = ""
      END
      IF RESULT >= zCURSOR_SET

         // Source entity is found as Target entity, so compare detail.
         LOD_CompareEntity( TargetLOD, SourceLOD, TargetLOD_Root )

         // Set Source and Target names to capture any differences determined above.
         TargetLOD_Root.CompareEntityResult.SourceDifferentName = szSourceEntityName
         TargetLOD_Root.CompareEntityResult.TargetDifferentName = szTargetEntityName

         // Next process any subobjects.
         IF szParentNames = ""
            szNewParentNames = TargetLOD.LOD_EntityParent.Name
         ELSE
            szNewParentNames = szParentNames + "/" + TargetLOD.LOD_EntityParent.Name
         END

         SetViewToSubobject( SourceLOD, "LOD_EntityChild" )
         SetViewToSubobject( TargetLOD, "LOD_EntityChild" )
         LOD_CompareReus( TargetLOD, SourceLOD, TargetLOD_Root, szNewParentNames )
         ResetViewFromSubobject( SourceLOD )
         ResetViewFromSubobject( TargetLOD )

      ELSE
         // Source entity does not exist as Target entity.
         TargetLOD_Root.CompareEntityResult.DifferenceFlag = "S"
         TargetLOD_Root.CompareEntityResult.ParentsConcatenatedName = szParentNames
      END
   END

   // Next, try to match the Target entries to the Source Entries.
   FOR EACH TargetLOD.LOD_EntityParent

      // If the Target Entity is a work entity (ie., not tied to an ER_Entity, look for a match on name.
      // If the Target Entity is an ER Entity, find a match on ER Entity Name.
      IF TargetLOD.ER_EntityRec EXISTS AND TargetLOD.ER_RelLinkRec EXISTS
         // This is an ER Entity. We can't do a simple set cursor so we'll loop through entries for a match.
         szER_EntityFound = ""
         SET CURSOR FIRST SourceLOD.LOD_EntityParent
         LOOP WHILE RESULT >= zCURSOR_SET AND szER_EntityFound = ""
            // Compare ER_Entities.
            IF SourceLOD.ER_EntityRec EXISTS AND SourceLOD.ER_RelLinkRec EXISTS
               IF SourceLOD.ER_EntityRec.Name  = TargetLOD.ER_EntityRec.Name AND
                  SourceLOD.ER_RelLinkRec.Name = TargetLOD.ER_RelLinkRec.Name

                  szER_EntityFound = "Y"
               END
            END
            // Set next cursor if we haven't found a match.
            IF szER_EntityFound = ""
               SET CURSOR NEXT SourceLOD.LOD_EntityParent
            END
         END
         IF szER_EntityFound = "Y"
            // We skip the match condition here because it was processed above.
            RESULT = 0     // This forces the equal case below.
         ELSE
            RESULT = -1
         END
      ELSE
         // This is a work entity so just do set cursor on LOD Entity Name.
         SET CURSOR FIRST SourceLOD.LOD_EntityParent
                    WHERE SourceLOD.LOD_EntityParent.Name = TargetLOD.LOD_EntityParent.Name
      END
      IF RESULT < zCURSOR_SET
         // Target Entity  does not exist as Source entity.
         // This is the only case we  care about in this pass.
         CREATE ENTITY TargetLOD_Root.CompareEntityResult
         TargetLOD_Root.CompareEntityResult.EntityName = TargetLOD.LOD_EntityParent.Name
         TargetLOD_Root.CompareEntityResult.EntityID   = TargetLOD.LOD_EntityParent.ZKey
         TargetLOD_Root.CompareEntityResult.DifferenceFlag = "T"
         TargetLOD_Root.CompareEntityResult.ParentsConcatenatedName = szParentNames
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_CompareOperations
**
*************************************************************************************************/
LOCAL OPERATION
LOD_CompareOperations( VIEW TargetLOD BASED ON LOD TZZOLODO,
                       VIEW SourceLOD BASED ON LOD TZZOLODO )

   // First try to match the Source entries to the Target Entries.
   FOR EACH SourceLOD.SourceFile
      FOR EACH SourceLOD.Operation

         // Create compare entry
         CREATE ENTITY TargetLOD.CompareOperationResult
         TargetLOD.CompareOperationResult.OperationName = SourceLOD.Operation.Name

         SET CURSOR FIRST TargetLOD.Operation WITHIN TargetLOD.LOD
                    WHERE TargetLOD.Operation.Name = SourceLOD.Operation.Name
         IF RESULT >= zCURSOR_SET
            // Source Operation is found as Target Operation, so compare Parameters.
            // First look for Source in Target.
            FOR EACH SourceLOD.Parameter
               SET CURSOR FIRST TargetLOD.Parameter WHERE TargetLOD.Parameter.ShortDesc = SourceLOD.Parameter.ShortDesc
               IF RESULT < zCURSOR_SET
                  // Source Parameter is not found in Target.
                  CREATE ENTITY TargetLOD.CompareParameterResult
                  TargetLOD.CompareParameterResult.ParameterName  = SourceLOD.Parameter.ShortDesc
                  TargetLOD.CompareParameterResult.Difference     = "Parameter Only in Source"
               END
            END
            // Next look for Target in Source
            FOR EACH TargetLOD.Parameter
               SET CURSOR FIRST SourceLOD.Parameter WHERE SourceLOD.Parameter.ShortDesc = TargetLOD.Parameter.ShortDesc
               IF RESULT < zCURSOR_SET
                  // Source Parameter is not found in Target.
                  CREATE ENTITY TargetLOD.CompareParameterResult
                  TargetLOD.CompareParameterResult.ParameterName  = TargetLOD.Parameter.ShortDesc
                  TargetLOD.CompareParameterResult.Difference     = "Parameter Only in Target"
               END
            END
            // Remove Results entry if no Parameter difference.
            SET CURSOR FIRST TargetLOD.CompareParameterResult
            IF RESULT < zCURSOR_SET
               DELETE ENTITY TargetLOD.CompareOperationResult
            END
         ELSE
            // Source Operation does not exist as Target Operation. Create CompareParameterResult parameter for
            // displaying result.
            CREATE ENTITY TargetLOD.CompareParameterResult
            TargetLOD.CompareParameterResult.Difference = "Operation Only in Source"
         END
      END
   END

   // Next, try to match Target to Source.
   FOR EACH TargetLOD.SourceFile
      FOR EACH TargetLOD.Operation
         SET CURSOR FIRST SourceLOD.Operation WITHIN SourceLOD.LOD
                    WHERE SourceLOD.Operation.Name = TargetLOD.Operation.Name
         IF RESULT < zCURSOR_SET
            // The only result we care about here is when the Target Operation is not in the Source.
            CREATE ENTITY TargetLOD.CompareOperationResult
            TargetLOD.CompareOperationResult.OperationName = TargetLOD.Operation.Name
            CREATE ENTITY TargetLOD.CompareParameterResult
            TargetLOD.CompareParameterResult.Difference = "Operation Only in Target"
         END
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_CompareEntity
**
*************************************************************************************************/
LOCAL OPERATION
LOD_CompareEntity( VIEW TargetLOD      BASED ON LOD TZZOLODO,
                   VIEW SourceLOD      BASED ON LOD TZZOLODO,
                   VIEW TargetLOD_Root BASED ON LOD TZZOLODO )

   STRING ( 50 ) szPermissionsTarget
   STRING ( 50 ) szPermissionsSource
   STRING ( 50 ) szOperationTarget
   STRING ( 50 ) szOperationSource

   // Compare LOD Entities.
   // Compare add/update permissions of form, "Create/Update/Delete/Include/Exclude" for comparison.

   // Set Target Permissions
   IF TargetLOD.LOD_EntityParent.Create = "Y"
      IF szPermissionsTarget = ""
         szPermissionsTarget = "Create"
      ELSE
         szPermissionsTarget = szPermissionsTarget + "/Create"
      END
   END
   IF TargetLOD.LOD_EntityParent.Update = "Y"
      IF szPermissionsTarget = ""
         szPermissionsTarget = "Update"
      ELSE
         szPermissionsTarget = szPermissionsTarget + "/Update"
      END
   END
   IF TargetLOD.LOD_EntityParent.Delete = "Y"
      IF szPermissionsTarget = ""
         szPermissionsTarget = "Delete"
      ELSE
         szPermissionsTarget = szPermissionsTarget + "/Delete"
      END
   END
   IF TargetLOD.LOD_EntityParent.Include = "Y"
      IF szPermissionsTarget = ""
         szPermissionsTarget = "Include"
      ELSE
         szPermissionsTarget = szPermissionsTarget + "/Include"
      END
   END
   IF TargetLOD.LOD_EntityParent.Exclude = "Y"
      IF szPermissionsTarget = ""
         szPermissionsTarget = "Exclude"
      ELSE
         szPermissionsTarget = szPermissionsTarget + "/Exclude"
      END
   END

   // Set Source Permissions
   IF SourceLOD.LOD_EntityParent.Create = "Y"
      IF szPermissionsSource = ""
         szPermissionsSource = "Create"
      ELSE
         szPermissionsSource = szPermissionsSource + "/Create"
      END
   END
   IF SourceLOD.LOD_EntityParent.Update = "Y"
      IF szPermissionsSource = ""
         szPermissionsSource = "Update"
      ELSE
         szPermissionsSource = szPermissionsSource + "/Update"
      END
   END
   IF SourceLOD.LOD_EntityParent.Delete = "Y"
      IF szPermissionsSource = ""
         szPermissionsSource = "Delete"
      ELSE
         szPermissionsSource = szPermissionsSource + "/Delete"
      END
   END
   IF SourceLOD.LOD_EntityParent.Include = "Y"
      IF szPermissionsSource = ""
         szPermissionsSource = "Include"
      ELSE
         szPermissionsSource = szPermissionsSource + "/Include"
      END
   END
   IF SourceLOD.LOD_EntityParent.Exclude = "Y"
      IF szPermissionsSource = ""
         szPermissionsSource = "Exclude"
      ELSE
         szPermissionsSource = szPermissionsSource + "/Exclude"
      END
   END

   // Compare Permissions
   IF szPermissionsTarget != szPermissionsSource
      TargetLOD_Root.CompareEntityResult.DifferenceFlag = "D"
      TargetLOD_Root.CompareEntityResult.SourceDifferentPermissions = szPermissionsSource
      TargetLOD_Root.CompareEntityResult.TargetDifferentPermissions = szPermissionsTarget
   END

   // First try to match the Source Attributes to the Target Attributes.
   FOR EACH SourceLOD.LOD_AttributeRec

      // Create compare entry.
      CREATE ENTITY TargetLOD_Root.CompareAttributeResult
      TargetLOD_Root.CompareAttributeResult.AttributeName = SourceLOD.ER_AttributeRec.Name
      TargetLOD_Root.CompareAttributeResult.AttributeID   = SourceLOD.LOD_AttributeRec.ZKey

      SET CURSOR FIRST TargetLOD.LOD_AttributeRec WHERE TargetLOD.ER_AttributeRec.Name = SourceLOD.ER_AttributeRec.Name
      IF RESULT >= zCURSOR_SET
         // Source Attribute is found in Target, so compare other data.

         // Check Work/Update Permissions.
         // Target
         szPermissionsTarget = ""
         IF TargetLOD.LOD_AttributeRec.Work  = "Y"
            IF szPermissionsTarget = ""
               szPermissionsTarget = "Work"
            ELSE
               szPermissionsTarget = szPermissionsTarget + "/Work"
            END
         END
         IF TargetLOD.LOD_AttributeRec.Update  = "Y"
            IF szPermissionsTarget = ""
               szPermissionsTarget = "Update"
            ELSE
               szPermissionsTarget = szPermissionsTarget + "/Update"
            END
         END
         // Source
         szPermissionsSource = ""
         IF SourceLOD.LOD_AttributeRec.Work  = "Y"
            IF szPermissionsSource = ""
               szPermissionsSource = "Work"
            ELSE
               szPermissionsSource = szPermissionsSource + "/Work"
            END
         END
         IF SourceLOD.LOD_AttributeRec.Update  = "Y"
            IF szPermissionsSource = ""
               szPermissionsSource = "Update"
            ELSE
               szPermissionsSource = szPermissionsSource + "/Update"
            END
         END
         // Compare Permissions
         IF szPermissionsTarget != szPermissionsSource
            TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "D"
            TargetLOD_Root.CompareAttributeResult.SourceDifferentPermissions = szPermissionsSource
            TargetLOD_Root.CompareAttributeResult.TargetDifferentPermissions = szPermissionsTarget
         END

         // Check Domain
         IF TargetLOD.DomainRec.Name != SourceLOD.DomainRec.Name
            TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "D"
            TargetLOD_Root.CompareAttributeResult.SourceDifferentDomainName = SourceLOD.DomainRec.Name
            TargetLOD_Root.CompareAttributeResult.TargetDifferentDomainName = TargetLOD.DomainRec.Name
         END

         // Check String Length
         IF TargetLOD.ER_AttributeRec.Lth != SourceLOD.ER_AttributeRec.Lth
            TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "D"
            TargetLOD_Root.CompareAttributeResult.SourceDifferentStringLength = SourceLOD.ER_AttributeRec.Lth
            TargetLOD_Root.CompareAttributeResult.TargetDifferentStringLength = TargetLOD.ER_AttributeRec.Lth
         END

         // Check Operation
         // Target
         IF TargetLOD.LOD_AttrDerivationOperRec EXISTS
            szOperationTarget = TargetLOD.LOD_AttrDerivationOperRec.Name
         ELSE
            szOperationTarget = ""
         END
         // Source
         IF SourceLOD.LOD_AttrDerivationOperRec EXISTS
            szOperationSource = SourceLOD.LOD_AttrDerivationOperRec.Name
         ELSE
            szOperationSource = ""
         END
         // Compare Operations
         IF szOperationTarget != szOperationSource
            TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "D"
            TargetLOD_Root.CompareAttributeResult.SourceDifferentOperationName = szOperationSource
            TargetLOD_Root.CompareAttributeResult.TargetDifferentOperationName = szOperationTarget
         END

      ELSE
         // Source is not found in Target.
         TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "S"
      END
   END

   // Next try to match the Target Attributes to the Source Attributes.
   FOR EACH TargetLOD.LOD_AttributeRec

      SET CURSOR FIRST SourceLOD.LOD_AttributeRec WHERE SourceLOD.ER_AttributeRec.Name = TargetLOD.ER_AttributeRec.Name
      IF RESULT < zCURSOR_SET
         // Target Attribute is not found in Source.
         // This is the only case we  care about in this pass.
         CREATE ENTITY TargetLOD_Root.CompareAttributeResult
         TargetLOD_Root.CompareAttributeResult.AttributeName = TargetLOD.ER_AttributeRec.Name
         TargetLOD_Root.CompareAttributeResult.AttributeID   = TargetLOD.LOD_AttributeRec.ZKey
         TargetLOD_Root.CompareAttributeResult.DifferenceFlag = "T"
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_Compare
**
*************************************************************************************************/
TRANSFORMATION OPERATION
LOD_Merge( VIEW TargetLOD BASED ON LOD TZZOLODO,
           VIEW SourceLOD BASED ON LOD TZZOLODO,
           VIEW vSubtask )

   VIEW TargetLOD_Root BASED ON LOD TZZOLODO
   VIEW SourceLOD_Root BASED ON LOD TZZOLODO
   VIEW CurrentLPLR    BASED ON LOD TZCMLPLO
   VIEW SourceLPLR     BASED ON LOD TZCMLPLO
   VIEW TempLPLR       BASED ON LOD TZCMLPLO
   VIEW NewERD         BASED ON LOD TZEREMDO
   VIEW SourceERD      BASED ON LOD TZEREMDO
   STRING ( 1 )   szSecondLineFlag
   STRING ( 200 ) szFileName
   INTEGER        AttributeCount
   SHORT          nRC

   // Merge the SourceLOD into the TargetLOD based on the selection specified in the
   // CompareEntityResult and CompareOperationResult subobjects in TargetLOD.

   // If an LPLR Name has been specified, activate the XLP and pass the File Directory structure to any
   // sub-operations so that necessary Domains can be imported.
   // Also activate the Source ERD.
   GET VIEW CurrentLPLR NAMED "TaskLPLR"
   IF CurrentLPLR.LPLR.wMergeSourceLPLR_Name != ""
      szFileName = CurrentLPLR.LPLR.wFullyQualifiedFileName + "\bin\" +
                   CurrentLPLR.LPLR.wMergeSourceLPLR_Name + ".XLP"
      nRC = ActivateOI_FromFile( SourceLPLR, "TZCMLPLO", TargetLOD, szFileName, zSINGLE )
      IF nRC >= 0
         NAME VIEW SourceLPLR "SourceLPLR"

         // Activate Source ERD.
         szFileName = CurrentLPLR.LPLR.wFullyQualifiedFileName + "\" +
                      CurrentLPLR.LPLR.wMergeSourceLPLR_Name + ".PMD"
         nRC = ActivateOI_FromFile( SourceERD, "TZEREMDO", TargetLOD, szFileName, zSINGLE )
         IF nRC >= 0
            NAME VIEW SourceERD "SourceERD"
         ELSE
            SourceERD = 0
         END
      ELSE
         MessageSend( TargetLOD, "", "LOD Merge",
                      "The LPLR Name specified does not have an XLP file. No Source ERD will be used.",
                      zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
         SourceLPLR = 0
         SourceERD  = 0
      END
   ELSE
      MessageSend( TargetLOD, "", "LOD Merge",
                   "Note that NO LPLR Name was specified, so NO Source ERD will be used during the merge.",
                   zMSGQ_OBJECT_CONSTRAINT_ERROR, 0 )
      SourceLPLR = 0
      SourceERD  = 0
   END

   // Set up views needed for Merge and Copy processing.
   CreateViewFromView( TargetLOD_Root, TargetLOD )
   NAME VIEW TargetLOD_Root "TargetLOD_Root"
   CreateViewFromView( SourceLOD_Root, SourceLOD )
   NAME VIEW SourceLOD_Root "SourceLOD_Root"
   GET VIEW NewERD NAMED "NewERD"
   IF RESULT < 0
      GET VIEW NewERD NAMED "TZEREMDO_REF"
      NAME VIEW NewERD "NewERD"
   END

   // Initialize flags prior to merge processing.
   CurrentLPLR.LPLR.wMergeComponentError     = ""
   CurrentLPLR.LPLR.wModifiedER_NotSavedFlag = ""
   CurrentLPLR.LPLR.wMergeER_ModifiedFlag    = ""

   // Go to merge LOD entities.
   LOD_MergeEntity( TargetLOD,
                    SourceLOD,
                    TargetLOD_Root,
                    SourceLOD_Root,
                    SourceLPLR,
                    CurrentLPLR,
                    NewERD,
                    SourceERD,
                    vSubtask )

   DropView( TargetLOD_Root )

   // If the ER has been modified, prompt the User to see if it should be saved. Don't do this if
   // component errors have occurred.
   IF CurrentLPLR.LPLR.wMergeER_ModifiedFlag = "Y" AND CurrentLPLR.LPLR.wMergeComponentError != "Y"
      nRC = MessagePrompt( vSubtask, "", "LOD Merge",
                           "The ER was modified in the process of merging the LOD's. Do you want to save the ER?",
                           0, zBUTTONS_YESNOCANCEL, 0, zICON_QUESTION )
      IF nRC = zRESPONSE_YES
         // Commit the ER.
         // We will not use CommitMetaOI because it requires getting an updatable version of the ER, which creates
         // all sorts of meta problems because we already have a LOD which is referencing a "referencable" version
         // of the ER. We thus have made our changes to the "referencable" version (GET VIEW NewERD NAMED "TZEREMDO_REF" above)
         // and will commit it here.
         szFileName = CurrentLPLR.LPLR.MetaSrcDir + "\" +
                      CurrentLPLR.LPLR.Name + ".PMD"
         nRC = CommitOI_ToFile( NewERD, szFileName, zASCII )
         IF nRC < 0
            MessageSend( vSubtask, "", "LOD Merge",
                         "An error occurred during the save of the ER. Merging the LOD will be aborted.",
                         zMSGQ_OBJECT_CONSTRAINT_WARNING, 0 )
            CurrentLPLR.LPLR.wMergeComponentError     = ""
            RETURN -1
         END
      ELSE
         // Since changes were made to the ER that were not saved, mark the LOD so that it can NOT be saved,
         // because saving a LOD with ER changes without saving the ER will create inconsistencies in the LPLR.
         CurrentLPLR.LPLR.wModifiedER_NotSavedFlag = "Y"
      END
   END

END

/*************************************************************************************************
**
**    OPERATION: LOD_MergeEntity
**
*************************************************************************************************/
LOCAL OPERATION
LOD_MergeEntity( VIEW TargetLOD      BASED ON LOD TZZOLODO,
                 VIEW SourceLOD      BASED ON LOD TZZOLODO,
                 VIEW TargetLOD_Root BASED ON LOD TZZOLODO,
                 VIEW SourceLOD_Root BASED ON LOD TZZOLODO,
                 VIEW SourceLPLR     BASED ON LOD TZCMLPLO,
                 VIEW CurrentLPLR    BASED ON LOD TZCMLPLO,
                 VIEW NewERD         BASED ON LOD TZEREMDO,
                 VIEW SourceERD      BASED ON LOD TZEREMDO,
                 VIEW vSubtask )

   VIEW TargetLOD2 BASED ON LOD TZZOLODO
   STRING ( 1 )  szER_EntityFound
   STRING ( 1 )  szAddAttributeFlag
   STRING ( 32 ) ParentName
   SHORT         nRC
   INTEGER       Count

   // Loop through each Source LOD Entity, checking to see if there is a corresponding LOD Entity in
   // the Target LOD and if the User has requested that it be merged as follows.
   // 1. If the LOD Entity does NOT exist in the Target, copy it and all Attributes and LOD Entity subobjects
   //    to the Target.
   // 2, If the LOD Entity DOES exist in the Target, set the all attributes from the Source into the Target.
   //    We will not do any further processing of attributes and LOD Entity subobjects, unless those entries have
   //    been selected for merge processing.

   // Check if Source LOD Entity is in Target.
   // If the Source Entity is a work entity (ie., not tied to an ER_Entity), look for a match on name.
   // If the Source Entity is an ER Entity, find a match on ER Entity Name.
   szER_EntityFound = ""
   IF SourceLOD.ER_EntityRec EXISTS AND SourceLOD.ER_RelLinkRec EXISTS
      // This is an ER Entity. We can't do a simple set cursor so we'll loop through entries for a match.
      SET CURSOR FIRST TargetLOD.LOD_EntityParent
      LOOP WHILE RESULT >= zCURSOR_SET AND szER_EntityFound = ""
         // Compare ER_Entities.
         IF TargetLOD.ER_EntityRec EXISTS AND TargetLOD.ER_RelLinkRec EXISTS
            IF TargetLOD.ER_EntityRec.Name  = SourceLOD.ER_EntityRec.Name AND
               TargetLOD.ER_RelLinkRec.Name = SourceLOD.ER_RelLinkRec.Name

               szER_EntityFound = "Y"
            END
         END
         // Set next cursor if we haven't found a match.
         IF szER_EntityFound = ""
            SET CURSOR NEXT TargetLOD.LOD_EntityParent
         END
      END
   ELSE
      // This is a work entity or the root of the LOD, so just do set cursor on LOD Entity Name.
      SET CURSOR FIRST TargetLOD.LOD_EntityParent
                 WHERE TargetLOD.LOD_EntityParent.Name = SourceLOD.LOD_EntityParent.Name
      IF RESULT >= zCURSOR_SET
         szER_EntityFound = "Y"
      END
   END

   // Check if request is to merge.
   SET CURSOR FIRST TargetLOD_Root.DisplayCompareResult
              WHERE TargetLOD_Root.DisplayCompareResult.MetaID       = SourceLOD.LOD_EntityParent.ZKey
                AND TargetLOD_Root.DisplayCompareResult.SelectedFlag = "Y"
   IF RESULT >= zCURSOR_SET
      // Request is to merge Entity.
      IF szER_EntityFound = ""

         // Case 1: The LOD Entity does NOT exist in the Target. Copy entity and subobjects.

         // Get the Parent Name of the entity, if there is on
         CreateViewFromView( TargetLOD2, TargetLOD )
         nRC = ResetViewFromSubobject( TargetLOD2 )
         IF nRC = 0
            IF TargetLOD2.ER_EntityRec EXISTS
               ParentName = TargetLOD2.ER_EntityRec.Name    // Parent Name is used in LOD_EntityCopy.
            ELSE
               ParentName = ""
            END
         ELSE
            ParentName = ""
         END
         DropView( TargetLOD2 )

         LOD_EntityCopy( TargetLOD_Root,
                         TargetLOD,
                         SourceLOD_Root,
                         SourceLOD,
                         SourceLPLR,
                         CurrentLPLR,
                         NewERD,
                         SourceERD,
                         0,                // There is no target DTE for Merge.
                         vSubtask,
                         ParentName,
                         "Y" )             // The request is to add ER entities and relationships as necessary.
         RETURN     // After a copy, we're done, so we'll just go back to process next entity.
      ELSE

         // Case 2: The LOD Entity DOES exist in the Target. Set LOD Entity values.

         SetMatchingAttributesByName( TargetLOD, "LOD_EntityParent",
                                      SourceLOD, "LOD_EntityParent", zSET_NOTNULL )
      END
   END

   // Whether or not we merged the Entity, continue to process Attributes and LOD subobjects.

   // Position on ER Entity for the LOD_Attribute about to be processed.
   IF TargetLOD.ER_EntityRec EXISTS
      SET CURSOR FIRST NewERD.ER_Entity WHERE NewERD.ER_Entity.ZKey = TargetLOD.ER_EntityRec.ZKey
   END

   szAddAttributeFlag = ""
   FOR EACH SourceLOD.LOD_AttributeRec

      // Merge Attribute as requested.
      SET CURSOR FIRST TargetLOD_Root.DisplayCompareResult
                 WHERE TargetLOD_Root.DisplayCompareResult.MetaID       = SourceLOD.LOD_AttributeRec.ZKey
                   AND TargetLOD_Root.DisplayCompareResult.SelectedFlag = "Y"
      IF RESULT >= zCURSOR_SET
         SET CURSOR FIRST TargetLOD.ER_AttributeRec WITHIN TargetLOD.LOD_EntityParent
                    WHERE TargetLOD.ER_AttributeRec.Name = SourceLOD.ER_AttributeRec.Name
         IF RESULT >= zCURSOR_SET
            // The attribute exist in the Target. We are going to delete it and re-add it.
            DELETE ENTITY TargetLOD.LOD_AttributeRec NONE
         END
         SET CURSOR LAST TargetLOD.LOD_AttributeRec
         szAddAttributeFlag = "Y"

         // Go to copy the Source Attribute.
         LOD_AttributeCopy( vSubtask,
                            TargetLOD_Root,
                            TargetLOD,
                            SourceLOD_Root,
                            SourceLOD,
                            SourceLPLR,
                            CurrentLPLR,
                            NewERD,
                            "Y" )
      END
   END

   // If we added an attribute, reset sequence numbers.
   IF szAddAttributeFlag = "Y"
      Count = 1
      SET CURSOR FIRST TargetLOD_Root.LOD_Entity WHERE TargetLOD_Root.LOD_Entity.ZKey = TargetLOD.LOD_EntityParent.ZKey
      FOR EACH TargetLOD_Root.LOD_Attribute
         TargetLOD_Root.LOD_Attribute.wkSequence = Count
         Count = Count + 1
      END
   END

   // Process any LOD Entity subobjects recursively.
   SetViewToSubobject( SourceLOD, "LOD_EntityChild" )
   SetViewToSubobject( TargetLOD, "LOD_EntityChild" )
   FOR EACH SourceLOD.LOD_EntityParent

      // Process merge for LOD Entity.
      LOD_MergeEntity( TargetLOD,
                       SourceLOD,
                       TargetLOD_Root,
                       SourceLOD_Root,
                       SourceLPLR,
                       CurrentLPLR,
                       NewERD,
                       SourceERD,
                       vSubtask )

   END
   ResetViewFromSubobject( SourceLOD )
   ResetViewFromSubobject( TargetLOD )

END
